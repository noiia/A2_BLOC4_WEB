{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts Gantt JS v11.4.0 (2024-03-04)\n *\n * Gantt series\n *\n * (c) 2016-2024 Lars A. V. Cabrera\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/gantt', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Extensions/ArrowSymbols.js', [], function () {\n        /* *\n         *\n         *  (c) 2017 Highsoft AS\n         *  Authors: Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Creates an arrow symbol. Like a triangle, except not filled.\n         * ```\n         *                   o\n         *             o\n         *       o\n         * o\n         *       o\n         *             o\n         *                   o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the arrow\n         *\n         * @param {number} y\n         *        y position of the arrow\n         *\n         * @param {number} w\n         *        width of the arrow\n         *\n         * @param {number} h\n         *        height of the arrow\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function arrow(x, y, w, h) {\n            return [\n                ['M', x, y + h / 2],\n                ['L', x + w, y],\n                ['L', x, y + h / 2],\n                ['L', x + w, y + h]\n            ];\n        }\n        /**\n         * Creates a half-width arrow symbol. Like a triangle, except not filled.\n         * ```\n         *       o\n         *    o\n         * o\n         *    o\n         *       o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the arrow\n         *\n         * @param {number} y\n         *        y position of the arrow\n         *\n         * @param {number} w\n         *        width of the arrow\n         *\n         * @param {number} h\n         *        height of the arrow\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function arrowHalf(x, y, w, h) {\n            return arrow(x, y, w / 2, h);\n        }\n        /**\n         * @private\n         */\n        function compose(SVGRendererClass) {\n            const symbols = SVGRendererClass.prototype.symbols;\n            symbols.arrow = arrow;\n            symbols['arrow-filled'] = triangleLeft;\n            symbols['arrow-filled-half'] = triangleLeftHalf;\n            symbols['arrow-half'] = arrowHalf;\n            symbols['triangle-left'] = triangleLeft;\n            symbols['triangle-left-half'] = triangleLeftHalf;\n        }\n        /**\n         * Creates a left-oriented triangle.\n         * ```\n         *             o\n         *       ooooooo\n         * ooooooooooooo\n         *       ooooooo\n         *             o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the triangle\n         *\n         * @param {number} y\n         *        y position of the triangle\n         *\n         * @param {number} w\n         *        width of the triangle\n         *\n         * @param {number} h\n         *        height of the triangle\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function triangleLeft(x, y, w, h) {\n            return [\n                ['M', x + w, y],\n                ['L', x, y + h / 2],\n                ['L', x + w, y + h],\n                ['Z']\n            ];\n        }\n        /**\n         * Creates a half-width, left-oriented triangle.\n         * ```\n         *       o\n         *    oooo\n         * ooooooo\n         *    oooo\n         *       o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the triangle\n         *\n         * @param {number} y\n         *        y position of the triangle\n         *\n         * @param {number} w\n         *        width of the triangle\n         *\n         * @param {number} h\n         *        height of the triangle\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function triangleLeftHalf(x, y, w, h) {\n            return triangleLeft(x, y, w / 2, h);\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const ArrowSymbols = {\n            compose\n        };\n\n        return ArrowSymbols;\n    });\n    _registerModule(_modules, 'Gantt/Connection.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Ã˜ystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { defined, error, merge, objectEach } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const deg2rad = H.deg2rad, max = Math.max, min = Math.min;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The Connection class. Used internally to represent a connection between two\n         * points.\n         *\n         * @private\n         * @class\n         * @name Highcharts.Connection\n         *\n         * @param {Highcharts.Point} from\n         *        Connection runs from this Point.\n         *\n         * @param {Highcharts.Point} to\n         *        Connection runs to this Point.\n         *\n         * @param {Highcharts.ConnectorsOptions} [options]\n         *        Connection options.\n         */\n        class Connection {\n            constructor(from, to, options) {\n                this.init(from, to, options);\n            }\n            /**\n             * Initialize the Connection object. Used as constructor only.\n             *\n             * @function Highcharts.Connection#init\n             *\n             * @param {Highcharts.Point} from\n             *        Connection runs from this Point.\n             *\n             * @param {Highcharts.Point} to\n             *        Connection runs to this Point.\n             *\n             * @param {Highcharts.ConnectorsOptions} [options]\n             *        Connection options.\n             */\n            init(from, to, options) {\n                this.fromPoint = from;\n                this.toPoint = to;\n                this.options = options;\n                this.chart = from.series.chart;\n                this.pathfinder = this.chart.pathfinder;\n            }\n            /**\n             * Add (or update) this connection's path on chart. Stores reference to the\n             * created element on this.graphics.path.\n             *\n             * @function Highcharts.Connection#renderPath\n             *\n             * @param {Highcharts.SVGPathArray} path\n             *        Path to render, in array format. E.g. ['M', 0, 0, 'L', 10, 10]\n             *\n             * @param {Highcharts.SVGAttributes} [attribs]\n             *        SVG attributes for the path.\n             *\n             * @param {Partial<Highcharts.AnimationOptionsObject>} [animation]\n             *        Animation options for the rendering.\n             */\n            renderPath(path, attribs) {\n                const connection = this, chart = this.chart, styledMode = chart.styledMode, pathfinder = this.pathfinder, anim = {};\n                let pathGraphic = connection.graphics && connection.graphics.path;\n                // Add the SVG element of the pathfinder group if it doesn't exist\n                if (!pathfinder.group) {\n                    pathfinder.group = chart.renderer.g()\n                        .addClass('highcharts-pathfinder-group')\n                        .attr({ zIndex: -1 })\n                        .add(chart.seriesGroup);\n                }\n                // Shift the group to compensate for plot area.\n                // Note: Do this always (even when redrawing a path) to avoid issues\n                // when updating chart in a way that changes plot metrics.\n                pathfinder.group.translate(chart.plotLeft, chart.plotTop);\n                // Create path if does not exist\n                if (!(pathGraphic && pathGraphic.renderer)) {\n                    pathGraphic = chart.renderer.path()\n                        .add(pathfinder.group);\n                    if (!styledMode) {\n                        pathGraphic.attr({\n                            opacity: 0\n                        });\n                    }\n                }\n                // Set path attribs and animate to the new path\n                pathGraphic.attr(attribs);\n                anim.d = path;\n                if (!styledMode) {\n                    anim.opacity = 1;\n                }\n                pathGraphic.animate(anim);\n                // Store reference on connection\n                this.graphics = this.graphics || {};\n                this.graphics.path = pathGraphic;\n            }\n            /**\n             * Calculate and add marker graphics for connection to the chart. The\n             * created/updated elements are stored on this.graphics.start and\n             * this.graphics.end.\n             *\n             * @function Highcharts.Connection#addMarker\n             *\n             * @param {string} type\n             *        Marker type, either 'start' or 'end'.\n             *\n             * @param {Highcharts.ConnectorsMarkerOptions} options\n             *        All options for this marker. Not calculated or merged with other\n             *        options.\n             *\n             * @param {Highcharts.SVGPathArray} path\n             *        Connection path in array format. This is used to calculate the\n             *        rotation angle of the markers.\n             */\n            addMarker(type, options, path) {\n                const connection = this, chart = connection.fromPoint.series.chart, pathfinder = chart.pathfinder, renderer = chart.renderer, point = (type === 'start' ?\n                    connection.fromPoint :\n                    connection.toPoint), anchor = point.getPathfinderAnchorPoint(options);\n                let markerVector, radians, rotation, box, width, height, pathVector, segment;\n                if (!options.enabled) {\n                    return;\n                }\n                // Last vector before start/end of path, used to get angle\n                if (type === 'start') {\n                    segment = path[1];\n                }\n                else { // 'end'\n                    segment = path[path.length - 2];\n                }\n                if (segment && segment[0] === 'M' || segment[0] === 'L') {\n                    pathVector = {\n                        x: segment[1],\n                        y: segment[2]\n                    };\n                    // Get angle between pathVector and anchor point and use it to\n                    // create marker position.\n                    radians = point.getRadiansToVector(pathVector, anchor);\n                    markerVector = point.getMarkerVector(radians, options.radius, anchor);\n                    // Rotation of marker is calculated from angle between pathVector\n                    // and markerVector.\n                    // (Note:\n                    //  Used to recalculate radians between markerVector and pathVector,\n                    //  but this should be the same as between pathVector and anchor.)\n                    rotation = -radians / deg2rad;\n                    if (options.width && options.height) {\n                        width = options.width;\n                        height = options.height;\n                    }\n                    else {\n                        width = height = options.radius * 2;\n                    }\n                    // Add graphics object if it does not exist\n                    connection.graphics = connection.graphics || {};\n                    box = {\n                        x: markerVector.x - (width / 2),\n                        y: markerVector.y - (height / 2),\n                        width: width,\n                        height: height,\n                        rotation: rotation,\n                        rotationOriginX: markerVector.x,\n                        rotationOriginY: markerVector.y\n                    };\n                    if (!connection.graphics[type]) {\n                        // Create new marker element\n                        connection.graphics[type] = renderer\n                            .symbol(options.symbol)\n                            .addClass('highcharts-point-connecting-path-' + type + '-marker' +\n                            ' highcharts-color-' + this.fromPoint.colorIndex)\n                            .attr(box)\n                            .add(pathfinder.group);\n                        if (!renderer.styledMode) {\n                            connection.graphics[type].attr({\n                                fill: options.color || connection.fromPoint.color,\n                                stroke: options.lineColor,\n                                'stroke-width': options.lineWidth,\n                                opacity: 0\n                            })\n                                .animate({\n                                opacity: 1\n                            }, point.series.options.animation);\n                        }\n                    }\n                    else {\n                        connection.graphics[type].animate(box);\n                    }\n                }\n            }\n            /**\n             * Calculate and return connection path.\n             * Note: Recalculates chart obstacles on demand if they aren't calculated.\n             *\n             * @function Highcharts.Connection#getPath\n             *\n             * @param {Highcharts.ConnectorsOptions} options\n             *        Connector options. Not calculated or merged with other options.\n             *\n             * @return {object|undefined}\n             *         Calculated SVG path data in array format.\n             */\n            getPath(options) {\n                const pathfinder = this.pathfinder, chart = this.chart, algorithm = pathfinder.algorithms[options.type];\n                let chartObstacles = pathfinder.chartObstacles;\n                if (typeof algorithm !== 'function') {\n                    error('\"' + options.type + '\" is not a Pathfinder algorithm.');\n                    return {\n                        path: [],\n                        obstacles: []\n                    };\n                }\n                // This function calculates obstacles on demand if they don't exist\n                if (algorithm.requiresObstacles && !chartObstacles) {\n                    chartObstacles =\n                        pathfinder.chartObstacles =\n                            pathfinder.getChartObstacles(options);\n                    // If the algorithmMargin was computed, store the result in default\n                    // options.\n                    chart.options.connectors.algorithmMargin =\n                        options.algorithmMargin;\n                    // Cache some metrics too\n                    pathfinder.chartObstacleMetrics =\n                        pathfinder.getObstacleMetrics(chartObstacles);\n                }\n                // Get the SVG path\n                return algorithm(\n                // From\n                this.fromPoint.getPathfinderAnchorPoint(options.startMarker), \n                // To\n                this.toPoint.getPathfinderAnchorPoint(options.endMarker), merge({\n                    chartObstacles: chartObstacles,\n                    lineObstacles: pathfinder.lineObstacles || [],\n                    obstacleMetrics: pathfinder.chartObstacleMetrics,\n                    hardBounds: {\n                        xMin: 0,\n                        xMax: chart.plotWidth,\n                        yMin: 0,\n                        yMax: chart.plotHeight\n                    },\n                    obstacleOptions: {\n                        margin: options.algorithmMargin\n                    },\n                    startDirectionX: pathfinder.getAlgorithmStartDirection(options.startMarker)\n                }, options));\n            }\n            /**\n             * (re)Calculate and (re)draw the connection.\n             *\n             * @function Highcharts.Connection#render\n             */\n            render() {\n                const connection = this, fromPoint = connection.fromPoint, series = fromPoint.series, chart = series.chart, pathfinder = chart.pathfinder, attribs = {};\n                let options = merge(chart.options.connectors, series.options.connectors, fromPoint.options.connectors, connection.options);\n                // Set path attribs\n                if (!chart.styledMode) {\n                    attribs.stroke = options.lineColor || fromPoint.color;\n                    attribs['stroke-width'] = options.lineWidth;\n                    if (options.dashStyle) {\n                        attribs.dashstyle = options.dashStyle;\n                    }\n                }\n                attribs['class'] = // eslint-disable-line dot-notation\n                    'highcharts-point-connecting-path ' +\n                        'highcharts-color-' + fromPoint.colorIndex;\n                options = merge(attribs, options);\n                // Set common marker options\n                if (!defined(options.marker.radius)) {\n                    options.marker.radius = min(max(Math.ceil((options.algorithmMargin || 8) / 2) - 1, 1), 5);\n                }\n                // Get the path\n                const pathResult = connection.getPath(options), path = pathResult.path;\n                // Always update obstacle storage with obstacles from this path.\n                // We don't know if future calls will need this for their algorithm.\n                if (pathResult.obstacles) {\n                    pathfinder.lineObstacles =\n                        pathfinder.lineObstacles || [];\n                    pathfinder.lineObstacles =\n                        pathfinder.lineObstacles.concat(pathResult.obstacles);\n                }\n                // Add the calculated path to the pathfinder group\n                connection.renderPath(path, attribs);\n                // Render the markers\n                connection.addMarker('start', merge(options.marker, options.startMarker), path);\n                connection.addMarker('end', merge(options.marker, options.endMarker), path);\n            }\n            /**\n             * Destroy connection by destroying the added graphics elements.\n             *\n             * @function Highcharts.Connection#destroy\n             */\n            destroy() {\n                if (this.graphics) {\n                    objectEach(this.graphics, function (val) {\n                        val.destroy();\n                    });\n                    delete this.graphics;\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * The default pathfinder algorithm to use for a chart. It is possible to define\n         * your own algorithms by adding them to the\n         * `Highcharts.Pathfinder.prototype.algorithms`\n         * object before the chart has been created.\n         *\n         * The default algorithms are as follows:\n         *\n         * `straight`:      Draws a straight line between the connecting\n         *                  points. Does not avoid other points when drawing.\n         *\n         * `simpleConnect`: Finds a path between the points using right angles\n         *                  only. Takes only starting/ending points into\n         *                  account, and will not avoid other points.\n         *\n         * `fastAvoid`:     Finds a path between the points using right angles\n         *                  only. Will attempt to avoid other points, but its\n         *                  focus is performance over accuracy. Works well with\n         *                  less dense datasets.\n         *\n         * @typedef {\"fastAvoid\"|\"simpleConnect\"|\"straight\"|string} Highcharts.PathfinderTypeValue\n         */\n        ''; // Keeps doclets above in JS file\n\n        return Connection;\n    });\n    _registerModule(_modules, 'Extensions/CurrentDateIndication.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *\n         *  Author: Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { composed } = H;\n        const { addEvent, merge, pushUnique, wrap } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * Show an indicator on the axis for the current date and time. Can be a\n         * boolean or a configuration object similar to\n         * [xAxis.plotLines](#xAxis.plotLines).\n         *\n         * @sample gantt/current-date-indicator/demo\n         *         Current date indicator enabled\n         * @sample gantt/current-date-indicator/object-config\n         *         Current date indicator with custom options\n         *\n         * @declare   Highcharts.CurrentDateIndicatorOptions\n         * @type      {boolean|CurrentDateIndicatorOptions}\n         * @default   true\n         * @extends   xAxis.plotLines\n         * @excluding value\n         * @product   gantt\n         * @apioption xAxis.currentDateIndicator\n         */\n        const defaultOptions = {\n            color: \"#ccd3ff\" /* Palette.highlightColor20 */,\n            width: 2,\n            /**\n             * @declare Highcharts.AxisCurrentDateIndicatorLabelOptions\n             */\n            label: {\n                /**\n                 * Format of the label. This options is passed as the fist argument to\n                 * [dateFormat](/class-reference/Highcharts.Time#dateFormat) function.\n                 *\n                 * @type      {string}\n                 * @default   %a, %b %d %Y, %H:%M\n                 * @product   gantt\n                 * @apioption xAxis.currentDateIndicator.label.format\n                 */\n                format: '%a, %b %d %Y, %H:%M',\n                formatter: function (value, format) {\n                    return this.axis.chart.time.dateFormat(format || '', value);\n                },\n                rotation: 0,\n                /**\n                 * @type {Highcharts.CSSObject}\n                 */\n                style: {\n                    /** @internal */\n                    fontSize: '0.7em'\n                }\n            }\n        };\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function compose(AxisClass, PlotLineOrBandClass) {\n            if (pushUnique(composed, 'CurrentDateIndication')) {\n                addEvent(AxisClass, 'afterSetOptions', onAxisAfterSetOptions);\n                addEvent(PlotLineOrBandClass, 'render', onPlotLineOrBandRender);\n                wrap(PlotLineOrBandClass.prototype, 'getLabelText', wrapPlotLineOrBandGetLabelText);\n            }\n        }\n        /**\n         * @private\n         */\n        function onAxisAfterSetOptions() {\n            const options = this.options, cdiOptions = options.currentDateIndicator;\n            if (cdiOptions) {\n                const plotLineOptions = typeof cdiOptions === 'object' ?\n                    merge(defaultOptions, cdiOptions) :\n                    merge(defaultOptions);\n                plotLineOptions.value = Date.now();\n                plotLineOptions.className = 'highcharts-current-date-indicator';\n                if (!options.plotLines) {\n                    options.plotLines = [];\n                }\n                options.plotLines.push(plotLineOptions);\n            }\n        }\n        /**\n         * @private\n         */\n        function onPlotLineOrBandRender() {\n            // If the label already exists, update its text\n            if (this.label) {\n                this.label.attr({\n                    text: this.getLabelText(this.options.label)\n                });\n            }\n        }\n        /**\n         * @private\n         */\n        function wrapPlotLineOrBandGetLabelText(defaultMethod, defaultLabelOptions) {\n            const options = this.options;\n            if (options &&\n                options.className &&\n                options.className.indexOf('highcharts-current-date-indicator') !== -1 &&\n                options.label &&\n                typeof options.label.formatter === 'function') {\n                options.value = Date.now();\n                return options.label.formatter\n                    .call(this, options.value, options.label.format);\n            }\n            return defaultMethod.call(this, defaultLabelOptions);\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const CurrentDateIndication = {\n            compose\n        };\n\n        return CurrentDateIndication;\n    });\n    _registerModule(_modules, 'Core/Chart/GanttChart.js', [_modules['Core/Chart/Chart.js'], _modules['Core/Defaults.js'], _modules['Core/Utilities.js']], function (Chart, D, U) {\n        /* *\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *\n         *  Author: Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { defaultOptions } = D;\n        const { isArray, merge, splat } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Gantt-optimized chart. Use {@link Highcharts.Chart|Chart} for common charts.\n         *\n         * @requires modules/gantt\n         *\n         * @class\n         * @name Highcharts.GanttChart\n         * @extends Highcharts.Chart\n         */\n        class GanttChart extends Chart {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Initializes the chart. The constructor's arguments are passed on\n             * directly.\n             *\n             * @function Highcharts.GanttChart#init\n             *\n             * @param {Highcharts.Options} userOptions\n             *        Custom options.\n             *\n             * @param {Function} [callback]\n             *        Function to run when the chart has loaded and all external\n             *        images are loaded.\n             *\n             *\n             * @emits Highcharts.GanttChart#event:init\n             * @emits Highcharts.GanttChart#event:afterInit\n             */\n            init(userOptions, callback) {\n                const xAxisOptions = userOptions.xAxis, yAxisOptions = userOptions.yAxis;\n                let defaultLinkedTo;\n                // Avoid doing these twice\n                userOptions.xAxis = userOptions.yAxis = void 0;\n                const options = merge(true, {\n                    chart: {\n                        type: 'gantt'\n                    },\n                    title: {\n                        text: ''\n                    },\n                    legend: {\n                        enabled: false\n                    },\n                    navigator: {\n                        series: { type: 'gantt' },\n                        // Bars were clipped, #14060.\n                        yAxis: {\n                            type: 'category'\n                        }\n                    }\n                }, userOptions, // User's options\n                // forced options\n                {\n                    isGantt: true\n                });\n                userOptions.xAxis = xAxisOptions;\n                userOptions.yAxis = yAxisOptions;\n                // Apply X axis options to both single and multi x axes If user hasn't\n                // defined axes as array, make it into an array and add a second axis by\n                // default.\n                options.xAxis = (!isArray(userOptions.xAxis) ?\n                    [userOptions.xAxis || {}, {}] :\n                    userOptions.xAxis).map((xAxisOptions, i) => {\n                    if (i === 1) { // Second xAxis\n                        defaultLinkedTo = 0;\n                    }\n                    return merge(\n                    // Defaults\n                    {\n                        grid: {\n                            borderColor: \"#cccccc\" /* Palette.neutralColor20 */,\n                            enabled: true\n                        },\n                        opposite: defaultOptions.xAxis?.opposite ??\n                            xAxisOptions.opposite ??\n                            true,\n                        linkedTo: defaultLinkedTo\n                    }, \n                    // User options\n                    xAxisOptions, \n                    // Forced options\n                    {\n                        type: 'datetime'\n                    });\n                });\n                // Apply Y axis options to both single and multi y axes\n                options.yAxis = (splat(userOptions.yAxis || {})).map((yAxisOptions) => merge(\n                // Defaults\n                {\n                    grid: {\n                        borderColor: \"#cccccc\" /* Palette.neutralColor20 */,\n                        enabled: true\n                    },\n                    staticScale: 50,\n                    reversed: true,\n                    // Set default type treegrid, but only if 'categories' is\n                    // undefined\n                    type: yAxisOptions.categories ? yAxisOptions.type : 'treegrid'\n                }, \n                // User options\n                yAxisOptions));\n                super.init(options, callback);\n            }\n        }\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        (function (GanttChart) {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable jsdoc/check-param-names */\n            /**\n             * The factory function for creating new gantt charts. Creates a new {@link\n             * Highcharts.GanttChart|GanttChart} object with different default options\n             * than the basic Chart.\n             *\n             * @example\n             * // Render a chart in to div#container\n             * let chart = Highcharts.ganttChart('container', {\n             *     title: {\n             *         text: 'My chart'\n             *     },\n             *     series: [{\n             *         data: ...\n             *     }]\n             * });\n             *\n             * @function Highcharts.ganttChart\n             *\n             * @param {string|Highcharts.HTMLDOMElement} renderTo\n             *        The DOM element to render to, or its id.\n             *\n             * @param {Highcharts.Options} options\n             *        The chart options structure.\n             *\n             * @param {Highcharts.ChartCallbackFunction} [callback]\n             *        Function to run when the chart has loaded and all external\n             *        images are loaded. Defining a\n             *        [chart.events.load](https://api.highcharts.com/highcharts/chart.events.load)\n             *        handler is equivalent.\n             *\n             * @return {Highcharts.GanttChart}\n             *         Returns the Chart object.\n             */\n            function ganttChart(a, b, c) {\n                return new GanttChart(a, b, c);\n            }\n            GanttChart.ganttChart = ganttChart;\n            /* eslint-enable jsdoc/check-param-names */\n        })(GanttChart || (GanttChart = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return GanttChart;\n    });\n    _registerModule(_modules, 'Stock/Navigator/ChartNavigatorComposition.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { isTouchDevice } = H;\n        const { addEvent, merge, pick } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const composedMembers = [];\n        /* *\n         *\n         *  Variables\n         *\n         * */\n        let NavigatorConstructor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function compose(ChartClass, NavigatorClass) {\n            if (U.pushUnique(composedMembers, ChartClass)) {\n                const chartProto = ChartClass.prototype;\n                NavigatorConstructor = NavigatorClass;\n                chartProto.callbacks.push(onChartCallback);\n                addEvent(ChartClass, 'afterAddSeries', onChartAfterAddSeries);\n                addEvent(ChartClass, 'afterSetChartSize', onChartAfterSetChartSize);\n                addEvent(ChartClass, 'afterUpdate', onChartAfterUpdate);\n                addEvent(ChartClass, 'beforeRender', onChartBeforeRender);\n                addEvent(ChartClass, 'beforeShowResetZoom', onChartBeforeShowResetZoom);\n                addEvent(ChartClass, 'update', onChartUpdate);\n            }\n        }\n        /**\n         * Handle adding new series.\n         * @private\n         */\n        function onChartAfterAddSeries() {\n            if (this.navigator) {\n                // Recompute which series should be shown in navigator, and add them\n                this.navigator.setBaseSeries(null, false);\n            }\n        }\n        /**\n         * For stock charts, extend the Chart.setChartSize method so that we can set the\n         * final top position of the navigator once the height of the chart, including\n         * the legend, is determined. #367. We can't use Chart.getMargins, because\n         * labels offsets are not calculated yet.\n         * @private\n         */\n        function onChartAfterSetChartSize() {\n            const legend = this.legend, navigator = this.navigator;\n            let legendOptions, xAxis, yAxis;\n            if (navigator) {\n                legendOptions = legend && legend.options;\n                xAxis = navigator.xAxis;\n                yAxis = navigator.yAxis;\n                const { scrollbarHeight, scrollButtonSize } = navigator;\n                // Compute the top position\n                if (this.inverted) {\n                    navigator.left = navigator.opposite ?\n                        this.chartWidth - scrollbarHeight -\n                            navigator.height :\n                        this.spacing[3] + scrollbarHeight;\n                    navigator.top = this.plotTop + scrollButtonSize;\n                }\n                else {\n                    navigator.left = pick(xAxis.left, this.plotLeft + scrollButtonSize);\n                    navigator.top = navigator.navigatorOptions.top ||\n                        this.chartHeight -\n                            navigator.height -\n                            scrollbarHeight -\n                            (this.scrollbar?.options.margin || 0) -\n                            this.spacing[2] -\n                            (this.rangeSelector && this.extraBottomMargin ?\n                                this.rangeSelector.getHeight() :\n                                0) -\n                            ((legendOptions &&\n                                legendOptions.verticalAlign === 'bottom' &&\n                                legendOptions.layout !== 'proximate' && // #13392\n                                legendOptions.enabled &&\n                                !legendOptions.floating) ?\n                                legend.legendHeight +\n                                    pick(legendOptions.margin, 10) :\n                                0) -\n                            (this.titleOffset ? this.titleOffset[2] : 0);\n                }\n                if (xAxis && yAxis) { // false if navigator is disabled (#904)\n                    if (this.inverted) {\n                        xAxis.options.left = yAxis.options.left = navigator.left;\n                    }\n                    else {\n                        xAxis.options.top = yAxis.options.top = navigator.top;\n                    }\n                    xAxis.setAxisSize();\n                    yAxis.setAxisSize();\n                }\n            }\n        }\n        /**\n         * Initialize navigator, if no scrolling exists yet.\n         * @private\n         */\n        function onChartAfterUpdate(event) {\n            if (!this.navigator && !this.scroller &&\n                (this.options.navigator.enabled ||\n                    this.options.scrollbar.enabled)) {\n                this.scroller = this.navigator = new NavigatorConstructor(this);\n                if (pick(event.redraw, true)) {\n                    this.redraw(event.animation); // #7067\n                }\n            }\n        }\n        /**\n         * Initialize navigator for stock charts\n         * @private\n         */\n        function onChartBeforeRender() {\n            const options = this.options;\n            if (options.navigator.enabled ||\n                options.scrollbar.enabled) {\n                this.scroller = this.navigator = new NavigatorConstructor(this);\n            }\n        }\n        /**\n         * For Stock charts. For x only zooming, do not to create the zoom button\n         * because X axis zooming is already allowed by the Navigator and Range\n         * selector. (#9285)\n         * @private\n         */\n        function onChartBeforeShowResetZoom() {\n            const chartOptions = this.options, navigator = chartOptions.navigator, rangeSelector = chartOptions.rangeSelector;\n            if (((navigator && navigator.enabled) ||\n                (rangeSelector && rangeSelector.enabled)) &&\n                ((!isTouchDevice &&\n                    this.zooming.type === 'x') ||\n                    (isTouchDevice && this.zooming.pinchType === 'x'))) {\n                return false;\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartCallback(chart) {\n            const navigator = chart.navigator;\n            // Initialize the navigator\n            if (navigator && chart.xAxis[0]) {\n                const extremes = chart.xAxis[0].getExtremes();\n                navigator.render(extremes.min, extremes.max);\n            }\n        }\n        /**\n         * Merge options, if no scrolling exists yet\n         * @private\n         */\n        function onChartUpdate(e) {\n            const navigatorOptions = (e.options.navigator || {}), scrollbarOptions = (e.options.scrollbar || {});\n            if (!this.navigator && !this.scroller &&\n                (navigatorOptions.enabled || scrollbarOptions.enabled)) {\n                merge(true, this.options.navigator, navigatorOptions);\n                merge(true, this.options.scrollbar, scrollbarOptions);\n                delete e.options.navigator;\n                delete e.options.scrollbar;\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const ChartNavigatorComposition = {\n            compose\n        };\n\n        return ChartNavigatorComposition;\n    });\n    _registerModule(_modules, 'Core/Axis/NavigatorAxisComposition.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { isTouchDevice } = H;\n        const { addEvent, correctFloat, defined, isNumber, pick } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function onAxisInit() {\n            const axis = this;\n            if (!axis.navigatorAxis) {\n                axis.navigatorAxis = new NavigatorAxisAdditions(axis);\n            }\n        }\n        /**\n         * For Stock charts, override selection zooming with some special features\n         * because X axis zooming is already allowed by the Navigator and Range\n         * selector.\n         * @private\n         */\n        function onAxisSetExtremes(e) {\n            const axis = this, chart = axis.chart, chartOptions = chart.options, navigator = chartOptions.navigator, navigatorAxis = axis.navigatorAxis, pinchType = chart.zooming.pinchType, rangeSelector = chartOptions.rangeSelector, zoomType = chart.zooming.type;\n            let zoomed;\n            if (axis.isXAxis &&\n                (navigator?.enabled || rangeSelector?.enabled)) {\n                // For y only zooming, ignore the X axis completely\n                if (zoomType === 'y' && e.trigger === 'zoom') {\n                    zoomed = false;\n                    // For xy zooming, record the state of the zoom before zoom selection,\n                    // then when the reset button is pressed, revert to this state. This\n                    // should apply only if the chart is initialized with a range (#6612),\n                    // otherwise zoom all the way out.\n                }\n                else if (((e.trigger === 'zoom' && zoomType === 'xy') ||\n                    (isTouchDevice && pinchType === 'xy')) &&\n                    axis.options.range) {\n                    const previousZoom = navigatorAxis.previousZoom;\n                    // Minimum defined, zooming in\n                    if (defined(e.min)) {\n                        navigatorAxis.previousZoom = [axis.min, axis.max];\n                        // Minimum undefined, resetting zoom\n                    }\n                    else if (previousZoom) {\n                        e.min = previousZoom[0];\n                        e.max = previousZoom[1];\n                        navigatorAxis.previousZoom = void 0;\n                    }\n                }\n            }\n            if (typeof zoomed !== 'undefined') {\n                e.preventDefault();\n            }\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         */\n        class NavigatorAxisAdditions {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            static compose(AxisClass) {\n                if (!AxisClass.keepProps.includes('navigatorAxis')) {\n                    AxisClass.keepProps.push('navigatorAxis');\n                    addEvent(AxisClass, 'init', onAxisInit);\n                    addEvent(AxisClass, 'setExtremes', onAxisSetExtremes);\n                }\n            }\n            /* *\n             *\n             *  Constructors\n             *\n             * */\n            constructor(axis) {\n                this.axis = axis;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            destroy() {\n                this.axis = void 0;\n            }\n            /**\n             * Add logic to normalize the zoomed range in order to preserve the pressed\n             * state of range selector buttons\n             *\n             * @private\n             * @function Highcharts.Axis#toFixedRange\n             */\n            toFixedRange(pxMin, pxMax, fixedMin, fixedMax) {\n                const axis = this.axis, chart = axis.chart, overscroll = pick(axis.ordinal?.convertOverscroll(axis.options.overscroll), 0);\n                let newMin = pick(fixedMin, axis.translate(pxMin, true, !axis.horiz)), newMax = pick(fixedMax, axis.translate(pxMax, true, !axis.horiz));\n                const fixedRange = chart && chart.fixedRange, halfPointRange = (axis.pointRange || 0) / 2;\n                // Add/remove half point range to/from the extremes (#1172)\n                if (!defined(fixedMin)) {\n                    newMin = correctFloat(newMin + halfPointRange);\n                }\n                if (!defined(fixedMax)) {\n                    newMax = correctFloat(newMax - halfPointRange);\n                }\n                // Make sure panning to the edges does not decrease the zoomed range\n                if (fixedRange && axis.dataMin && axis.dataMax) {\n                    const maxWithOverscroll = axis.dataMax + overscroll;\n                    if (newMax >= maxWithOverscroll) {\n                        newMin = correctFloat(maxWithOverscroll - fixedRange);\n                        newMax = correctFloat(maxWithOverscroll);\n                    }\n                    if (newMin <= axis.dataMin) {\n                        newMax = correctFloat(axis.dataMin + fixedRange);\n                    }\n                }\n                if (!isNumber(newMin) || !isNumber(newMax)) { // #1195, #7411\n                    newMin = newMax = void 0;\n                }\n                return {\n                    min: newMin,\n                    max: newMax\n                };\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return NavigatorAxisAdditions;\n    });\n    _registerModule(_modules, 'Stock/Navigator/NavigatorDefaults.js', [_modules['Core/Color/Color.js'], _modules['Core/Series/SeriesRegistry.js']], function (Color, SeriesRegistry) {\n        /* *\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { parse: color } = Color;\n        const { seriesTypes } = SeriesRegistry;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * The navigator is a small series below the main series, displaying\n         * a view of the entire data set. It provides tools to zoom in and\n         * out on parts of the data as well as panning across the dataset.\n         *\n         * @product      highstock gantt\n         * @optionparent navigator\n         */\n        const NavigatorDefaults = {\n            /**\n             * Whether the navigator and scrollbar should adapt to updated data\n             * in the base X axis. When loading data async, as in the demo below,\n             * this should be `false`. Otherwise new data will trigger navigator\n             * redraw, which will cause unwanted looping. In the demo below, the\n             * data in the navigator is set only once. On navigating, only the main\n             * chart content is updated.\n             *\n             * @sample {highstock} stock/demo/lazy-loading/\n             *         Set to false with async data loading\n             *\n             * @type      {boolean}\n             * @default   true\n             * @apioption navigator.adaptToUpdatedData\n             */\n            /**\n             * An integer identifying the index to use for the base series, or a\n             * string representing the id of the series.\n             *\n             * **Note**: As of Highcharts 5.0, this is now a deprecated option.\n             * Prefer [series.showInNavigator](#plotOptions.series.showInNavigator).\n             *\n             * @see [series.showInNavigator](#plotOptions.series.showInNavigator)\n             *\n             * @deprecated\n             * @type      {number|string}\n             * @default   0\n             * @apioption navigator.baseSeries\n             */\n            /**\n             * Enable or disable the navigator.\n             *\n             * @sample {highstock} stock/navigator/enabled/\n             *         Disable the navigator\n             *\n             * @type      {boolean}\n             * @default   true\n             * @apioption navigator.enabled\n             */\n            /**\n             * When the chart is inverted, whether to draw the navigator on the\n             * opposite side.\n             *\n             * @type      {boolean}\n             * @default   false\n             * @since     5.0.8\n             * @apioption navigator.opposite\n             */\n            /**\n             * The height of the navigator.\n             *\n             * @sample {highstock} stock/navigator/height/\n             *         A higher navigator\n             */\n            height: 40,\n            /**\n             * The distance from the nearest element, the X axis or X axis labels.\n             *\n             * @sample {highstock} stock/navigator/margin/\n             *         A margin of 2 draws the navigator closer to the X axis labels\n             */\n            margin: 25,\n            /**\n             * Whether the mask should be inside the range marking the zoomed\n             * range, or outside. In Highcharts Stock 1.x it was always `false`.\n             *\n             * @sample {highstock} stock/demo/maskinside-false/\n             *         False, mask outside\n             *\n             * @since   2.0\n             */\n            maskInside: true,\n            /**\n             * Options for the handles for dragging the zoomed area.\n             *\n             * @sample {highstock} stock/navigator/handles/\n             *         Colored handles\n             */\n            handles: {\n                /**\n                 * Width for handles.\n                 *\n                 * @sample {highstock} stock/navigator/styled-handles/\n                 *         Styled handles\n                 *\n                 * @since   6.0.0\n                 */\n                width: 7,\n                /**\n                 * Height for handles.\n                 *\n                 * @sample {highstock} stock/navigator/styled-handles/\n                 *         Styled handles\n                 *\n                 * @since   6.0.0\n                 */\n                height: 15,\n                /**\n                 * Array to define shapes of handles. 0-index for left, 1-index for\n                 * right.\n                 *\n                 * Additionally, the URL to a graphic can be given on this form:\n                 * `url(graphic.png)`. Note that for the image to be applied to\n                 * exported charts, its URL needs to be accessible by the export\n                 * server.\n                 *\n                 * Custom callbacks for symbol path generation can also be added to\n                 * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then\n                 * used by its method name, as shown in the demo.\n                 *\n                 * @sample {highstock} stock/navigator/styled-handles/\n                 *         Styled handles\n                 *\n                 * @type    {Array<string>}\n                 * @default [\"navigator-handle\", \"navigator-handle\"]\n                 * @since   6.0.0\n                 */\n                symbols: ['navigator-handle', 'navigator-handle'],\n                /**\n                 * Allows to enable/disable handles.\n                 *\n                 * @since   6.0.0\n                 */\n                enabled: true,\n                /**\n                 * The width for the handle border and the stripes inside.\n                 *\n                 * @sample {highstock} stock/navigator/styled-handles/\n                 *         Styled handles\n                 *\n                 * @since     6.0.0\n                 * @apioption navigator.handles.lineWidth\n                 */\n                lineWidth: 1,\n                /**\n                 * The fill for the handle.\n                 *\n                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 */\n                backgroundColor: \"#f2f2f2\" /* Palette.neutralColor5 */,\n                /**\n                 * The stroke for the handle border and the stripes inside.\n                 *\n                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 */\n                borderColor: \"#999999\" /* Palette.neutralColor40 */\n            },\n            /**\n             * The color of the mask covering the areas of the navigator series\n             * that are currently not visible in the main series. The default\n             * color is bluish with an opacity of 0.3 to see the series below.\n             *\n             * @see In styled mode, the mask is styled with the\n             *      `.highcharts-navigator-mask` and\n             *      `.highcharts-navigator-mask-inside` classes.\n             *\n             * @sample {highstock} stock/navigator/maskfill/\n             *         Blue, semi transparent mask\n             *\n             * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             * @default rgba(102,133,194,0.3)\n             */\n            maskFill: color(\"#667aff\" /* Palette.highlightColor60 */).setOpacity(0.3).get(),\n            /**\n             * The color of the line marking the currently zoomed area in the\n             * navigator.\n             *\n             * @sample {highstock} stock/navigator/outline/\n             *         2px blue outline\n             *\n             * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             * @default #cccccc\n             */\n            outlineColor: \"#999999\" /* Palette.neutralColor40 */,\n            /**\n             * The width of the line marking the currently zoomed area in the\n             * navigator.\n             *\n             * @see In styled mode, the outline stroke width is set with the\n             *      `.highcharts-navigator-outline` class.\n             *\n             * @sample {highstock} stock/navigator/outline/\n             *         2px blue outline\n             *\n             * @type    {number}\n             */\n            outlineWidth: 1,\n            /**\n             * Options for the navigator series. Available options are the same\n             * as any series, documented at [plotOptions](#plotOptions.series)\n             * and [series](#series).\n             *\n             * Unless data is explicitly defined on navigator.series, the data\n             * is borrowed from the first series in the chart.\n             *\n             * Default series options for the navigator series are:\n             * ```js\n             * series: {\n             *     type: 'areaspline',\n             *     fillOpacity: 0.05,\n             *     dataGrouping: {\n             *         smoothed: true\n             *     },\n             *     lineWidth: 1,\n             *     marker: {\n             *         enabled: false\n             *     }\n             * }\n             * ```\n             *\n             * @see In styled mode, the navigator series is styled with the\n             *      `.highcharts-navigator-series` class.\n             *\n             * @sample {highstock} stock/navigator/series-data/\n             *         Using a separate data set for the navigator\n             * @sample {highstock} stock/navigator/series/\n             *         A green navigator series\n             *\n             * @type {*|Array<*>|Highcharts.SeriesOptionsType|Array<Highcharts.SeriesOptionsType>}\n             */\n            series: {\n                /**\n                 * The type of the navigator series.\n                 *\n                 * Heads up:\n                 * In column-type navigator, zooming is limited to at least one\n                 * point with its `pointRange`.\n                 *\n                 * @sample {highstock} stock/navigator/column/\n                 *         Column type navigator\n                 *\n                 * @type    {string}\n                 * @default {highstock} `areaspline` if defined, otherwise `line`\n                 * @default {gantt} gantt\n                 */\n                type: (typeof seriesTypes.areaspline === 'undefined' ?\n                    'line' :\n                    'areaspline'),\n                /**\n                 * The fill opacity of the navigator series.\n                 */\n                fillOpacity: 0.05,\n                /**\n                 * The pixel line width of the navigator series.\n                 */\n                lineWidth: 1,\n                /**\n                 * @ignore-option\n                 */\n                compare: null,\n                /**\n                 * @ignore-option\n                 */\n                sonification: {\n                    enabled: false\n                },\n                /**\n                 * Unless data is explicitly defined, the data is borrowed from the\n                 * first series in the chart.\n                 *\n                 * @type      {Array<number|Array<number|string|null>|object|null>}\n                 * @product   highstock\n                 * @apioption navigator.series.data\n                 */\n                /**\n                 * Data grouping options for the navigator series.\n                 *\n                 * @extends plotOptions.series.dataGrouping\n                 */\n                dataGrouping: {\n                    approximation: 'average',\n                    enabled: true,\n                    groupPixelWidth: 2,\n                    // Replace smoothed property by anchors, #12455.\n                    firstAnchor: 'firstPoint',\n                    anchor: 'middle',\n                    lastAnchor: 'lastPoint',\n                    // Day and week differs from plotOptions.series.dataGrouping\n                    units: [\n                        ['millisecond', [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]],\n                        ['second', [1, 2, 5, 10, 15, 30]],\n                        ['minute', [1, 2, 5, 10, 15, 30]],\n                        ['hour', [1, 2, 3, 4, 6, 8, 12]],\n                        ['day', [1, 2, 3, 4]],\n                        ['week', [1, 2, 3]],\n                        ['month', [1, 3, 6]],\n                        ['year', null]\n                    ]\n                },\n                /**\n                 * Data label options for the navigator series. Data labels are\n                 * disabled by default on the navigator series.\n                 *\n                 * @extends plotOptions.series.dataLabels\n                 */\n                dataLabels: {\n                    enabled: false,\n                    zIndex: 2 // #1839\n                },\n                id: 'highcharts-navigator-series',\n                className: 'highcharts-navigator-series',\n                /**\n                 * Sets the fill color of the navigator series.\n                 *\n                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @apioption navigator.series.color\n                 */\n                /**\n                 * Line color for the navigator series. Allows setting the color\n                 * while disallowing the default candlestick setting.\n                 *\n                 * @type {Highcharts.ColorString|null}\n                 */\n                lineColor: null,\n                marker: {\n                    enabled: false\n                },\n                /**\n                 * Since Highcharts Stock v8, default value is the same as default\n                 * `pointRange` defined for a specific type (e.g. `null` for\n                 * column type).\n                 *\n                 * In Highcharts Stock version < 8, defaults to 0.\n                 *\n                 * @extends plotOptions.series.pointRange\n                 * @type {number|null}\n                 * @apioption navigator.series.pointRange\n                 */\n                /**\n                 * The threshold option. Setting it to 0 will make the default\n                 * navigator area series draw its area from the 0 value and up.\n                 *\n                 * @type {number|null}\n                 */\n                threshold: null\n            },\n            /**\n             * Enable or disable navigator sticking to right, while adding new\n             * points. If `undefined`, the navigator sticks to the axis maximum only\n             * if it was already at the maximum prior to adding points.\n             *\n             * @type      {boolean}\n             * @default   undefined\n             * @since 10.2.1\n             * @sample {highstock} stock/navigator/sticktomax-false/\n             * stickToMax set to false\n             * @apioption navigator.stickToMax\n             */\n            /**\n             * Options for the navigator X axis. Default series options for the\n             * navigator xAxis are:\n             * ```js\n             * xAxis: {\n             *     tickWidth: 0,\n             *     lineWidth: 0,\n             *     gridLineWidth: 1,\n             *     tickPixelInterval: 200,\n             *     labels: {\n             *            align: 'left',\n             *         style: {\n             *             color: '#888'\n             *         },\n             *         x: 3,\n             *         y: -4\n             *     }\n             * }\n             * ```\n             *\n             * @extends   xAxis\n             * @excluding linkedTo, maxZoom, minRange, opposite, range, scrollbar,\n             *            showEmpty, maxRange\n             */\n            xAxis: {\n                /**\n                 * Additional range on the right side of the xAxis. Works similar to\n                 * `xAxis.maxPadding`, but the value is set in terms of axis values,\n                 * percentage or pixels.\n                 *\n                 * If it's a number, it is interpreted as axis values, which in a\n                 * datetime axis equals milliseconds.\n                 *\n                 * If it's a percentage string, is interpreted as percentages of the\n                 * axis length. An overscroll of 50% will make a 100px axis 50px longer.\n                 *\n                 * If it's a pixel string, it is interpreted as a fixed pixel value, but\n                 * limited to 90% of the axis length.\n                 *\n                 * If it's undefined, the value is inherited from `xAxis.overscroll`.\n                 *\n                 * Can be set for both, main xAxis and navigator's xAxis.\n                 *\n                 * @type    {number | string | undefined}\n                 * @since   6.0.0\n                 * @apioption navigator.xAxis.overscroll\n                 */\n                className: 'highcharts-navigator-xaxis',\n                tickLength: 0,\n                lineWidth: 0,\n                gridLineColor: \"#e6e6e6\" /* Palette.neutralColor10 */,\n                gridLineWidth: 1,\n                tickPixelInterval: 200,\n                labels: {\n                    align: 'left',\n                    /**\n                     * @type {Highcharts.CSSObject}\n                     */\n                    style: {\n                        /** @ignore */\n                        color: \"#000000\" /* Palette.neutralColor100 */,\n                        /** @ignore */\n                        fontSize: '0.7em',\n                        /** @ignore */\n                        opacity: 0.6,\n                        /** @ignore */\n                        textOutline: '2px contrast'\n                    },\n                    x: 3,\n                    y: -4\n                },\n                crosshair: false\n            },\n            /**\n             * Options for the navigator Y axis. Default series options for the\n             * navigator yAxis are:\n             * ```js\n             * yAxis: {\n             *     gridLineWidth: 0,\n             *     startOnTick: false,\n             *     endOnTick: false,\n             *     minPadding: 0.1,\n             *     maxPadding: 0.1,\n             *     labels: {\n             *         enabled: false\n             *     },\n             *     title: {\n             *         text: null\n             *     },\n             *     tickWidth: 0\n             * }\n             * ```\n             *\n             * @extends   yAxis\n             * @excluding height, linkedTo, maxZoom, minRange, ordinal, range,\n             *            showEmpty, scrollbar, top, units, maxRange, minLength,\n             *            maxLength, resize\n             */\n            yAxis: {\n                className: 'highcharts-navigator-yaxis',\n                gridLineWidth: 0,\n                startOnTick: false,\n                endOnTick: false,\n                minPadding: 0.1,\n                maxPadding: 0.1,\n                labels: {\n                    enabled: false\n                },\n                crosshair: false,\n                title: {\n                    text: null\n                },\n                tickLength: 0,\n                tickWidth: 0\n            }\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Maximum range which can be set using the navigator's handles.\n         * Opposite of [xAxis.minRange](#xAxis.minRange).\n         *\n         * @sample {highstock} stock/navigator/maxrange/\n         *         Defined max and min range\n         *\n         * @type      {number}\n         * @since     6.0.0\n         * @product   highstock gantt\n         * @apioption xAxis.maxRange\n         */\n        (''); // keeps doclets above in JS file\n\n        return NavigatorDefaults;\n    });\n    _registerModule(_modules, 'Stock/Navigator/NavigatorSymbols.js', [], function () {\n        /* *\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * Draw one of the handles on the side of the zoomed range in the navigator.\n         * @private\n         */\n        function navigatorHandle(_x, _y, width, height, options = {}) {\n            const halfWidth = options.width ? options.width / 2 : width, markerPosition = Math.round(halfWidth / 3) + 0.5;\n            height = options.height || height;\n            return [\n                ['M', -halfWidth - 1, 0.5],\n                ['L', halfWidth, 0.5],\n                ['L', halfWidth, height + 0.5],\n                ['L', -halfWidth - 1, height + 0.5],\n                ['L', -halfWidth - 1, 0.5],\n                ['M', -markerPosition, 4],\n                ['L', -markerPosition, height - 3],\n                ['M', markerPosition - 1, 4],\n                ['L', markerPosition - 1, height - 3]\n            ];\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const NavigatorSymbols = {\n            'navigator-handle': navigatorHandle\n        };\n\n        return NavigatorSymbols;\n    });\n    _registerModule(_modules, 'Stock/Utilities/StockUtilities.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { defined } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Sets the chart.fixedRange to the specified value. If the value is larger\n         * than actual range, sets it to the maximum possible range. (#20327)\n         *\n         * @private\n         * @function Highcharts.StockChart#setFixedRange\n         * @param {number|undefined} range\n         *        Range to set in axis units.\n         */\n        function setFixedRange(range) {\n            const xAxis = this.xAxis[0];\n            if (defined(xAxis.dataMax) &&\n                defined(xAxis.dataMin) &&\n                range) {\n                this.fixedRange = Math.min(range, xAxis.dataMax - xAxis.dataMin);\n            }\n            else {\n                this.fixedRange = range;\n            }\n        }\n        const StockUtilities = {\n            setFixedRange\n        };\n\n        return StockUtilities;\n    });\n    _registerModule(_modules, 'Stock/Navigator/NavigatorComposition.js', [_modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Core/Axis/NavigatorAxisComposition.js'], _modules['Stock/Navigator/NavigatorDefaults.js'], _modules['Stock/Navigator/NavigatorSymbols.js'], _modules['Core/Renderer/RendererRegistry.js'], _modules['Stock/Utilities/StockUtilities.js'], _modules['Core/Utilities.js']], function (D, H, NavigatorAxisAdditions, NavigatorDefaults, NavigatorSymbols, RendererRegistry, StockUtilities, U) {\n        /* *\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { setOptions } = D;\n        const { composed } = H;\n        const { getRendererType } = RendererRegistry;\n        const { setFixedRange } = StockUtilities;\n        const { addEvent, extend, pushUnique } = U;\n        /* *\n         *\n         *  Variables\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function compose(ChartClass, AxisClass, SeriesClass) {\n            NavigatorAxisAdditions.compose(AxisClass);\n            if (pushUnique(composed, 'Navigator')) {\n                ChartClass.prototype.setFixedRange = setFixedRange;\n                extend(getRendererType().prototype.symbols, NavigatorSymbols);\n                addEvent(SeriesClass, 'afterUpdate', onSeriesAfterUpdate);\n                setOptions({ navigator: NavigatorDefaults });\n            }\n        }\n        /**\n         * Handle updating series\n         * @private\n         */\n        function onSeriesAfterUpdate() {\n            if (this.chart.navigator && !this.options.isInternal) {\n                this.chart.navigator.setBaseSeries(null, false);\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const NavigatorComposition = {\n            compose\n        };\n\n        return NavigatorComposition;\n    });\n    _registerModule(_modules, 'Core/Axis/ScrollbarAxis.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { composed } = H;\n        const { addEvent, defined, pick, pushUnique } = U;\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        var ScrollbarAxis;\n        (function (ScrollbarAxis) {\n            /* *\n             *\n             *  Variables\n             *\n             * */\n            let Scrollbar;\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Attaches to axis events to create scrollbars if enabled.\n             *\n             * @private\n             *\n             * @param {Highcharts.Axis} AxisClass\n             * Axis class to extend.\n             *\n             * @param {Highcharts.Scrollbar} ScrollbarClass\n             * Scrollbar class to use.\n             */\n            function compose(AxisClass, ScrollbarClass) {\n                if (pushUnique(composed, 'Axis.Scrollbar')) {\n                    Scrollbar = ScrollbarClass;\n                    addEvent(AxisClass, 'afterGetOffset', onAxisAfterGetOffset);\n                    addEvent(AxisClass, 'afterInit', onAxisAfterInit);\n                    addEvent(AxisClass, 'afterRender', onAxisAfterRender);\n                }\n            }\n            ScrollbarAxis.compose = compose;\n            /** @private */\n            function getExtremes(axis) {\n                const axisMin = pick(axis.options && axis.options.min, axis.min);\n                const axisMax = pick(axis.options && axis.options.max, axis.max);\n                return {\n                    axisMin,\n                    axisMax,\n                    scrollMin: defined(axis.dataMin) ?\n                        Math.min(axisMin, axis.min, axis.dataMin, pick(axis.threshold, Infinity)) : axisMin,\n                    scrollMax: defined(axis.dataMax) ?\n                        Math.max(axisMax, axis.max, axis.dataMax, pick(axis.threshold, -Infinity)) : axisMax\n                };\n            }\n            /**\n             * Make space for a scrollbar.\n             * @private\n             */\n            function onAxisAfterGetOffset() {\n                const axis = this, scrollbar = axis.scrollbar, opposite = scrollbar && !scrollbar.options.opposite, index = axis.horiz ? 2 : opposite ? 3 : 1;\n                if (scrollbar) {\n                    // Reset scrollbars offsets\n                    axis.chart.scrollbarsOffsets = [0, 0];\n                    axis.chart.axisOffset[index] +=\n                        scrollbar.size + (scrollbar.options.margin || 0);\n                }\n            }\n            /**\n             * Wrap axis initialization and create scrollbar if enabled.\n             * @private\n             */\n            function onAxisAfterInit() {\n                const axis = this;\n                if (axis.options &&\n                    axis.options.scrollbar &&\n                    axis.options.scrollbar.enabled) {\n                    // Predefined options:\n                    axis.options.scrollbar.vertical = !axis.horiz;\n                    axis.options.startOnTick = axis.options.endOnTick = false;\n                    axis.scrollbar = new Scrollbar(axis.chart.renderer, axis.options.scrollbar, axis.chart);\n                    addEvent(axis.scrollbar, 'changed', function (e) {\n                        const { axisMin, axisMax, scrollMin: unitedMin, scrollMax: unitedMax } = getExtremes(axis), range = unitedMax - unitedMin;\n                        let to, from;\n                        // #12834, scroll when show/hide series, wrong extremes\n                        if (!defined(axisMin) || !defined(axisMax)) {\n                            return;\n                        }\n                        if ((axis.horiz && !axis.reversed) ||\n                            (!axis.horiz && axis.reversed)) {\n                            to = unitedMin + range * this.to;\n                            from = unitedMin + range * this.from;\n                        }\n                        else {\n                            // Y-values in browser are reversed, but this also\n                            // applies for reversed horizontal axis:\n                            to = unitedMin + range * (1 - this.from);\n                            from = unitedMin + range * (1 - this.to);\n                        }\n                        if (this.shouldUpdateExtremes(e.DOMType)) {\n                            // #17977, set animation to undefined instead of true\n                            const animate = e.DOMType === 'mousemove' ||\n                                e.DOMType === 'touchmove' ? false : void 0;\n                            axis.setExtremes(from, to, true, animate, e);\n                        }\n                        else {\n                            // When live redraw is disabled, don't change extremes\n                            // Only change the position of the scrollbar thumb\n                            this.setRange(this.from, this.to);\n                        }\n                    });\n                }\n            }\n            /**\n             * Wrap rendering axis, and update scrollbar if one is created.\n             * @private\n             */\n            function onAxisAfterRender() {\n                const axis = this, { scrollMin, scrollMax } = getExtremes(axis), scrollbar = axis.scrollbar, offset = (axis.axisTitleMargin + (axis.titleOffset || 0)), scrollbarsOffsets = axis.chart.scrollbarsOffsets, axisMargin = axis.options.margin || 0;\n                let offsetsIndex, from, to;\n                if (scrollbar && scrollbarsOffsets) {\n                    if (axis.horiz) {\n                        // Reserve space for labels/title\n                        if (!axis.opposite) {\n                            scrollbarsOffsets[1] += offset;\n                        }\n                        scrollbar.position(axis.left, (axis.top +\n                            axis.height +\n                            2 +\n                            scrollbarsOffsets[1] -\n                            (axis.opposite ? axisMargin : 0)), axis.width, axis.height);\n                        // Next scrollbar should reserve space for margin (if set)\n                        if (!axis.opposite) {\n                            scrollbarsOffsets[1] += axisMargin;\n                        }\n                        offsetsIndex = 1;\n                    }\n                    else {\n                        // Reserve space for labels/title\n                        if (axis.opposite) {\n                            scrollbarsOffsets[0] += offset;\n                        }\n                        let xPosition;\n                        if (!scrollbar.options.opposite) {\n                            xPosition = axis.opposite ? 0 : axisMargin;\n                        }\n                        else {\n                            xPosition = axis.left +\n                                axis.width +\n                                2 +\n                                scrollbarsOffsets[0] -\n                                (axis.opposite ? 0 : axisMargin);\n                        }\n                        scrollbar.position(xPosition, axis.top, axis.width, axis.height);\n                        // Next scrollbar should reserve space for margin (if set)\n                        if (axis.opposite) {\n                            scrollbarsOffsets[0] += axisMargin;\n                        }\n                        offsetsIndex = 0;\n                    }\n                    scrollbarsOffsets[offsetsIndex] += scrollbar.size +\n                        (scrollbar.options.margin || 0);\n                    if (isNaN(scrollMin) ||\n                        isNaN(scrollMax) ||\n                        !defined(axis.min) ||\n                        !defined(axis.max) ||\n                        axis.min === axis.max // #10733\n                    ) {\n                        // Default action: when extremes are the same or there is\n                        // not extremes on the axis, but scrollbar exists, make it\n                        // full size\n                        scrollbar.setRange(0, 1);\n                    }\n                    else {\n                        from = ((axis.min - scrollMin) /\n                            (scrollMax - scrollMin));\n                        to = ((axis.max - scrollMin) /\n                            (scrollMax - scrollMin));\n                        if ((axis.horiz && !axis.reversed) ||\n                            (!axis.horiz && axis.reversed)) {\n                            scrollbar.setRange(from, to);\n                        }\n                        else {\n                            // Inverse vertical axis\n                            scrollbar.setRange(1 - to, 1 - from);\n                        }\n                    }\n                }\n            }\n        })(ScrollbarAxis || (ScrollbarAxis = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ScrollbarAxis;\n    });\n    _registerModule(_modules, 'Stock/Scrollbar/ScrollbarDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Constant\n         *\n         * */\n        /**\n         *\n         * The scrollbar is a means of panning over the X axis of a stock chart.\n         * Scrollbars can also be applied to other types of axes.\n         *\n         * Another approach to scrollable charts is the [chart.scrollablePlotArea](\n         * https://api.highcharts.com/highcharts/chart.scrollablePlotArea) option that\n         * is especially suitable for simpler cartesian charts on mobile.\n         *\n         * In styled mode, all the presentational options for the\n         * scrollbar are replaced by the classes `.highcharts-scrollbar-thumb`,\n         * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,\n         * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.\n         *\n         * @sample stock/yaxis/inverted-bar-scrollbar/\n         *         A scrollbar on a simple bar chart\n         *\n         * @product highstock gantt\n         * @optionparent scrollbar\n         *\n         * @private\n         */\n        const ScrollbarDefaults = {\n            /**\n             * The height of the scrollbar. If `buttonsEnabled` is true , the height\n             * also applies to the width of the scroll arrows so that they are always\n             * squares.\n             *\n             * @sample stock/scrollbar/style/\n             *         Non-default height\n             *\n             * @type    {number}\n             */\n            height: 10,\n            /**\n             * The border rounding radius of the bar.\n             *\n             * @sample stock/scrollbar/style/\n             *         Scrollbar styling\n             */\n            barBorderRadius: 5,\n            /**\n             * The corner radius of the scrollbar buttons.\n             *\n             * @sample stock/scrollbar/style/\n             *         Scrollbar styling\n             */\n            buttonBorderRadius: 0,\n            /**\n             * Enable or disable the buttons at the end of the scrollbar.\n             *\n             * @since 11.0.0\n             */\n            buttonsEnabled: false,\n            /**\n             * Enable or disable the scrollbar.\n             *\n             * @sample stock/scrollbar/enabled/\n             *         Disable the scrollbar, only use navigator\n             *\n             * @type      {boolean}\n             * @default   true\n             * @apioption scrollbar.enabled\n             */\n            /**\n             * Whether to redraw the main chart as the scrollbar or the navigator\n             * zoomed window is moved. Defaults to `true` for modern browsers and\n             * `false` for legacy IE browsers as well as mobile devices.\n             *\n             * @sample stock/scrollbar/liveredraw\n             *         Setting live redraw to false\n             *\n             * @type  {boolean}\n             * @since 1.3\n             */\n            liveRedraw: void 0,\n            /**\n             * The margin between the scrollbar and its axis when the scrollbar is\n             * applied directly to an axis, or the navigator in case that is enabled.\n             * Defaults to 10 for axis, 0 for navigator.\n             *\n             * @type {number|undefined}\n             */\n            margin: void 0,\n            /**\n             * The minimum width of the scrollbar.\n             *\n             * @since 1.2.5\n             */\n            minWidth: 6,\n            /** @ignore-option */\n            opposite: true,\n            /**\n             * Whether to show or hide the scrollbar when the scrolled content is\n             * zoomed out to it full extent.\n             *\n             * @type      {boolean}\n             * @default   true\n             * @apioption scrollbar.showFull\n             */\n            step: 0.2,\n            /**\n             * The z index of the scrollbar group.\n             */\n            zIndex: 3,\n            /**\n             * The background color of the scrollbar itself.\n             *\n             * @sample stock/scrollbar/style/\n             *         Scrollbar styling\n             *\n             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             */\n            barBackgroundColor: \"#cccccc\" /* Palette.neutralColor20 */,\n            /**\n             * The width of the bar's border.\n             *\n             * @sample stock/scrollbar/style/\n             *         Scrollbar styling\n             */\n            barBorderWidth: 0,\n            /**\n             * The color of the scrollbar's border.\n             *\n             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             */\n            barBorderColor: \"#cccccc\" /* Palette.neutralColor20 */,\n            /**\n             * The color of the small arrow inside the scrollbar buttons.\n             *\n             * @sample stock/scrollbar/style/\n             *         Scrollbar styling\n             *\n             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             */\n            buttonArrowColor: \"#333333\" /* Palette.neutralColor80 */,\n            /**\n             * The color of scrollbar buttons.\n             *\n             * @sample stock/scrollbar/style/\n             *         Scrollbar styling\n             *\n             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             */\n            buttonBackgroundColor: \"#e6e6e6\" /* Palette.neutralColor10 */,\n            /**\n             * The color of the border of the scrollbar buttons.\n             *\n             * @sample stock/scrollbar/style/\n             *         Scrollbar styling\n             *\n             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             */\n            buttonBorderColor: \"#cccccc\" /* Palette.neutralColor20 */,\n            /**\n             * The border width of the scrollbar buttons.\n             *\n             * @sample stock/scrollbar/style/\n             *         Scrollbar styling\n             */\n            buttonBorderWidth: 1,\n            /**\n             * The color of the small rifles in the middle of the scrollbar.\n             *\n             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             */\n            rifleColor: 'none',\n            /**\n             * The color of the track background.\n             *\n             * @sample stock/scrollbar/style/\n             *         Scrollbar styling\n             *\n             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             */\n            trackBackgroundColor: 'rgba(255, 255, 255, 0.001)',\n            /**\n             * The color of the border of the scrollbar track.\n             *\n             * @sample stock/scrollbar/style/\n             *         Scrollbar styling\n             *\n             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             */\n            trackBorderColor: \"#cccccc\" /* Palette.neutralColor20 */,\n            /**\n             * The corner radius of the border of the scrollbar track.\n             *\n             * @sample stock/scrollbar/style/\n             *         Scrollbar styling\n             */\n            trackBorderRadius: 5,\n            /**\n             * The width of the border of the scrollbar track.\n             *\n             * @sample stock/scrollbar/style/\n             *         Scrollbar styling\n             */\n            trackBorderWidth: 1\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ScrollbarDefaults;\n    });\n    _registerModule(_modules, 'Stock/Scrollbar/Scrollbar.js', [_modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Core/Axis/ScrollbarAxis.js'], _modules['Stock/Scrollbar/ScrollbarDefaults.js'], _modules['Core/Utilities.js']], function (D, H, ScrollbarAxis, ScrollbarDefaults, U) {\n        /* *\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { defaultOptions } = D;\n        const { addEvent, correctFloat, defined, destroyObjectProperties, fireEvent, merge, pick, removeEvent } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /* eslint-disable no-invalid-this, valid-jsdoc */\n        /**\n         * A reusable scrollbar, internally used in Highcharts Stock's\n         * navigator and optionally on individual axes.\n         *\n         * @private\n         * @class\n         * @name Highcharts.Scrollbar\n         * @param {Highcharts.SVGRenderer} renderer\n         * @param {Highcharts.ScrollbarOptions} options\n         * @param {Highcharts.Chart} chart\n         */\n        class Scrollbar {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            static compose(AxisClass) {\n                ScrollbarAxis.compose(AxisClass, Scrollbar);\n            }\n            /**\n             * When we have vertical scrollbar, rifles and arrow in buttons should be\n             * rotated. The same method is used in Navigator's handles, to rotate them.\n             *\n             * @function Highcharts.swapXY\n             *\n             * @param {Highcharts.SVGPathArray} path\n             * Path to be rotated.\n             *\n             * @param {boolean} [vertical]\n             * If vertical scrollbar, swap x-y values.\n             *\n             * @return {Highcharts.SVGPathArray}\n             * Rotated path.\n             *\n             * @requires modules/stock\n             */\n            static swapXY(path, vertical) {\n                if (vertical) {\n                    path.forEach((seg) => {\n                        const len = seg.length;\n                        let temp;\n                        for (let i = 0; i < len; i += 2) {\n                            temp = seg[i + 1];\n                            if (typeof temp === 'number') {\n                                seg[i + 1] = seg[i + 2];\n                                seg[i + 2] = temp;\n                            }\n                        }\n                    });\n                }\n                return path;\n            }\n            /* *\n             *\n             *  Constructors\n             *\n             * */\n            constructor(renderer, options, chart) {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this._events = [];\n                this.chartX = 0;\n                this.chartY = 0;\n                this.from = 0;\n                this.scrollbarButtons = [];\n                this.scrollbarLeft = 0;\n                this.scrollbarStrokeWidth = 1;\n                this.scrollbarTop = 0;\n                this.size = 0;\n                this.to = 0;\n                this.trackBorderWidth = 1;\n                this.x = 0;\n                this.y = 0;\n                this.init(renderer, options, chart);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Set up the mouse and touch events for the Scrollbar\n             *\n             * @private\n             * @function Highcharts.Scrollbar#addEvents\n             */\n            addEvents() {\n                const buttonsOrder = this.options.inverted ? [1, 0] : [0, 1], buttons = this.scrollbarButtons, bar = this.scrollbarGroup.element, track = this.track.element, mouseDownHandler = this.mouseDownHandler.bind(this), mouseMoveHandler = this.mouseMoveHandler.bind(this), mouseUpHandler = this.mouseUpHandler.bind(this);\n                const _events = [\n                    // Mouse events\n                    [\n                        buttons[buttonsOrder[0]].element,\n                        'click',\n                        this.buttonToMinClick.bind(this)\n                    ],\n                    [\n                        buttons[buttonsOrder[1]].element,\n                        'click',\n                        this.buttonToMaxClick.bind(this)\n                    ],\n                    [track, 'click', this.trackClick.bind(this)],\n                    [bar, 'mousedown', mouseDownHandler],\n                    [bar.ownerDocument, 'mousemove', mouseMoveHandler],\n                    [bar.ownerDocument, 'mouseup', mouseUpHandler],\n                    // Touch events\n                    [bar, 'touchstart', mouseDownHandler],\n                    [bar.ownerDocument, 'touchmove', mouseMoveHandler],\n                    [bar.ownerDocument, 'touchend', mouseUpHandler]\n                ];\n                // Add them all\n                _events.forEach(function (args) {\n                    addEvent.apply(null, args);\n                });\n                this._events = _events;\n            }\n            buttonToMaxClick(e) {\n                const scroller = this;\n                const range = ((scroller.to - scroller.from) *\n                    pick(scroller.options.step, 0.2));\n                scroller.updatePosition(scroller.from + range, scroller.to + range);\n                fireEvent(scroller, 'changed', {\n                    from: scroller.from,\n                    to: scroller.to,\n                    trigger: 'scrollbar',\n                    DOMEvent: e\n                });\n            }\n            buttonToMinClick(e) {\n                const scroller = this;\n                const range = correctFloat(scroller.to - scroller.from) *\n                    pick(scroller.options.step, 0.2);\n                scroller.updatePosition(correctFloat(scroller.from - range), correctFloat(scroller.to - range));\n                fireEvent(scroller, 'changed', {\n                    from: scroller.from,\n                    to: scroller.to,\n                    trigger: 'scrollbar',\n                    DOMEvent: e\n                });\n            }\n            /**\n             * Get normalized (0-1) cursor position over the scrollbar\n             *\n             * @private\n             * @function Highcharts.Scrollbar#cursorToScrollbarPosition\n             *\n             * @param  {*} normalizedEvent\n             *         normalized event, with chartX and chartY values\n             *\n             * @return {Highcharts.Dictionary<number>}\n             *         Local position {chartX, chartY}\n             */\n            cursorToScrollbarPosition(normalizedEvent) {\n                const scroller = this, options = scroller.options, minWidthDifference = options.minWidth > scroller.calculatedWidth ?\n                    options.minWidth :\n                    0; // minWidth distorts translation\n                return {\n                    chartX: (normalizedEvent.chartX - scroller.x -\n                        scroller.xOffset) /\n                        (scroller.barWidth - minWidthDifference),\n                    chartY: (normalizedEvent.chartY - scroller.y -\n                        scroller.yOffset) /\n                        (scroller.barWidth - minWidthDifference)\n                };\n            }\n            /**\n             * Destroys allocated elements.\n             *\n             * @private\n             * @function Highcharts.Scrollbar#destroy\n             */\n            destroy() {\n                const scroller = this, navigator = scroller.chart.scroller;\n                // Disconnect events added in addEvents\n                scroller.removeEvents();\n                // Destroy properties\n                [\n                    'track',\n                    'scrollbarRifles',\n                    'scrollbar',\n                    'scrollbarGroup',\n                    'group'\n                ].forEach(function (prop) {\n                    if (scroller[prop] && scroller[prop].destroy) {\n                        scroller[prop] = scroller[prop].destroy();\n                    }\n                });\n                // #6421, chart may have more scrollbars\n                if (navigator && scroller === navigator.scrollbar) {\n                    navigator.scrollbar = null;\n                    // Destroy elements in collection\n                    destroyObjectProperties(navigator.scrollbarButtons);\n                }\n            }\n            /**\n             * Draw the scrollbar buttons with arrows\n             *\n             * @private\n             * @function Highcharts.Scrollbar#drawScrollbarButton\n             * @param {number} index\n             *        0 is left, 1 is right\n             */\n            drawScrollbarButton(index) {\n                const scroller = this, renderer = scroller.renderer, scrollbarButtons = scroller.scrollbarButtons, options = scroller.options, size = scroller.size, group = renderer.g().add(scroller.group);\n                scrollbarButtons.push(group);\n                if (options.buttonsEnabled) {\n                    // Create a rectangle for the scrollbar button\n                    const rect = renderer.rect()\n                        .addClass('highcharts-scrollbar-button')\n                        .add(group);\n                    // Presentational attributes\n                    if (!scroller.chart.styledMode) {\n                        rect.attr({\n                            stroke: options.buttonBorderColor,\n                            'stroke-width': options.buttonBorderWidth,\n                            fill: options.buttonBackgroundColor\n                        });\n                    }\n                    // Place the rectangle based on the rendered stroke width\n                    rect.attr(rect.crisp({\n                        x: -0.5,\n                        y: -0.5,\n                        // +1 to compensate for crispifying in rect method\n                        width: size + 1,\n                        height: size + 1,\n                        r: options.buttonBorderRadius\n                    }, rect.strokeWidth()));\n                    // Button arrow\n                    const arrow = renderer\n                        .path(Scrollbar.swapXY([[\n                            'M',\n                            size / 2 + (index ? -1 : 1),\n                            size / 2 - 3\n                        ], [\n                            'L',\n                            size / 2 + (index ? -1 : 1),\n                            size / 2 + 3\n                        ], [\n                            'L',\n                            size / 2 + (index ? 2 : -2),\n                            size / 2\n                        ]], options.vertical))\n                        .addClass('highcharts-scrollbar-arrow')\n                        .add(scrollbarButtons[index]);\n                    if (!scroller.chart.styledMode) {\n                        arrow.attr({\n                            fill: options.buttonArrowColor\n                        });\n                    }\n                }\n            }\n            /**\n             * @private\n             * @function Highcharts.Scrollbar#init\n             * @param {Highcharts.SVGRenderer} renderer\n             * @param {Highcharts.ScrollbarOptions} options\n             * @param {Highcharts.Chart} chart\n             */\n            init(renderer, options, chart) {\n                const scroller = this;\n                scroller.scrollbarButtons = [];\n                scroller.renderer = renderer;\n                scroller.userOptions = options;\n                scroller.options = merge(ScrollbarDefaults, defaultOptions.scrollbar, options);\n                scroller.options.margin = pick(scroller.options.margin, 10);\n                scroller.chart = chart;\n                // backward compatibility\n                scroller.size = pick(scroller.options.size, scroller.options.height);\n                // Init\n                if (options.enabled) {\n                    scroller.render();\n                    scroller.addEvents();\n                }\n            }\n            mouseDownHandler(e) {\n                const scroller = this, normalizedEvent = scroller.chart.pointer?.normalize(e) || e, mousePosition = scroller.cursorToScrollbarPosition(normalizedEvent);\n                scroller.chartX = mousePosition.chartX;\n                scroller.chartY = mousePosition.chartY;\n                scroller.initPositions = [scroller.from, scroller.to];\n                scroller.grabbedCenter = true;\n            }\n            /**\n             * Event handler for the mouse move event.\n             * @private\n             */\n            mouseMoveHandler(e) {\n                const scroller = this, normalizedEvent = scroller.chart.pointer?.normalize(e) || e, options = scroller.options, direction = options.vertical ?\n                    'chartY' : 'chartX', initPositions = scroller.initPositions || [];\n                let scrollPosition, chartPosition, change;\n                // In iOS, a mousemove event with e.pageX === 0 is fired when\n                // holding the finger down in the center of the scrollbar. This\n                // should be ignored.\n                if (scroller.grabbedCenter &&\n                    // #4696, scrollbar failed on Android\n                    (!e.touches || e.touches[0][direction] !== 0)) {\n                    chartPosition = scroller.cursorToScrollbarPosition(normalizedEvent)[direction];\n                    scrollPosition = scroller[direction];\n                    change = chartPosition - scrollPosition;\n                    scroller.hasDragged = true;\n                    scroller.updatePosition(initPositions[0] + change, initPositions[1] + change);\n                    if (scroller.hasDragged) {\n                        fireEvent(scroller, 'changed', {\n                            from: scroller.from,\n                            to: scroller.to,\n                            trigger: 'scrollbar',\n                            DOMType: e.type,\n                            DOMEvent: e\n                        });\n                    }\n                }\n            }\n            /**\n             * Event handler for the mouse up event.\n             * @private\n             */\n            mouseUpHandler(e) {\n                const scroller = this;\n                if (scroller.hasDragged) {\n                    fireEvent(scroller, 'changed', {\n                        from: scroller.from,\n                        to: scroller.to,\n                        trigger: 'scrollbar',\n                        DOMType: e.type,\n                        DOMEvent: e\n                    });\n                }\n                scroller.grabbedCenter =\n                    scroller.hasDragged =\n                        scroller.chartX =\n                            scroller.chartY = null;\n            }\n            /**\n             * Position the scrollbar, method called from a parent with defined\n             * dimensions.\n             *\n             * @private\n             * @function Highcharts.Scrollbar#position\n             * @param {number} x\n             *        x-position on the chart\n             * @param {number} y\n             *        y-position on the chart\n             * @param {number} width\n             *        width of the scrollbar\n             * @param {number} height\n             *        height of the scrollbar\n             */\n            position(x, y, width, height) {\n                const scroller = this, options = scroller.options, { buttonsEnabled, margin = 0, vertical } = options, method = scroller.rendered ? 'animate' : 'attr';\n                let xOffset = height, yOffset = 0;\n                // Make the scrollbar visible when it is repositioned, #15763.\n                scroller.group.show();\n                scroller.x = x;\n                scroller.y = y + this.trackBorderWidth;\n                scroller.width = width; // width with buttons\n                scroller.height = height;\n                scroller.xOffset = xOffset;\n                scroller.yOffset = yOffset;\n                // If Scrollbar is a vertical type, swap options:\n                if (vertical) {\n                    scroller.width = scroller.yOffset = width = yOffset = scroller.size;\n                    scroller.xOffset = xOffset = 0;\n                    scroller.yOffset = yOffset = buttonsEnabled ? scroller.size : 0;\n                    // width without buttons\n                    scroller.barWidth = height - (buttonsEnabled ? width * 2 : 0);\n                    scroller.x = x = x + margin;\n                }\n                else {\n                    scroller.height = height = scroller.size;\n                    scroller.xOffset = xOffset = buttonsEnabled ? scroller.size : 0;\n                    // width without buttons\n                    scroller.barWidth = width - (buttonsEnabled ? height * 2 : 0);\n                    scroller.y = scroller.y + margin;\n                }\n                // Set general position for a group:\n                scroller.group[method]({\n                    translateX: x,\n                    translateY: scroller.y\n                });\n                // Resize background/track:\n                scroller.track[method]({\n                    width: width,\n                    height: height\n                });\n                // Move right/bottom button to its place:\n                scroller.scrollbarButtons[1][method]({\n                    translateX: vertical ? 0 : width - xOffset,\n                    translateY: vertical ? height - yOffset : 0\n                });\n            }\n            /**\n             * Removes the event handlers attached previously with addEvents.\n             *\n             * @private\n             * @function Highcharts.Scrollbar#removeEvents\n             */\n            removeEvents() {\n                this._events.forEach(function (args) {\n                    removeEvent.apply(null, args);\n                });\n                this._events.length = 0;\n            }\n            /**\n             * Render scrollbar with all required items.\n             *\n             * @private\n             * @function Highcharts.Scrollbar#render\n             */\n            render() {\n                const scroller = this, renderer = scroller.renderer, options = scroller.options, size = scroller.size, styledMode = scroller.chart.styledMode, group = renderer.g('scrollbar')\n                    .attr({\n                    zIndex: options.zIndex\n                })\n                    .hide() // initially hide the scrollbar #15863\n                    .add();\n                // Draw the scrollbar group\n                scroller.group = group;\n                // Draw the scrollbar track:\n                scroller.track = renderer.rect()\n                    .addClass('highcharts-scrollbar-track')\n                    .attr({\n                    r: options.trackBorderRadius || 0,\n                    height: size,\n                    width: size\n                }).add(group);\n                if (!styledMode) {\n                    scroller.track.attr({\n                        fill: options.trackBackgroundColor,\n                        stroke: options.trackBorderColor,\n                        'stroke-width': options.trackBorderWidth\n                    });\n                }\n                const trackBorderWidth = scroller.trackBorderWidth =\n                    scroller.track.strokeWidth();\n                scroller.track.attr({\n                    x: -trackBorderWidth % 2 / 2,\n                    y: -trackBorderWidth % 2 / 2\n                });\n                // Draw the scrollbar itself\n                scroller.scrollbarGroup = renderer.g().add(group);\n                scroller.scrollbar = renderer.rect()\n                    .addClass('highcharts-scrollbar-thumb')\n                    .attr({\n                    height: size - trackBorderWidth,\n                    width: size - trackBorderWidth,\n                    r: options.barBorderRadius || 0\n                }).add(scroller.scrollbarGroup);\n                scroller.scrollbarRifles = renderer\n                    .path(Scrollbar.swapXY([\n                    ['M', -3, size / 4],\n                    ['L', -3, 2 * size / 3],\n                    ['M', 0, size / 4],\n                    ['L', 0, 2 * size / 3],\n                    ['M', 3, size / 4],\n                    ['L', 3, 2 * size / 3]\n                ], options.vertical))\n                    .addClass('highcharts-scrollbar-rifles')\n                    .add(scroller.scrollbarGroup);\n                if (!styledMode) {\n                    scroller.scrollbar.attr({\n                        fill: options.barBackgroundColor,\n                        stroke: options.barBorderColor,\n                        'stroke-width': options.barBorderWidth\n                    });\n                    scroller.scrollbarRifles.attr({\n                        stroke: options.rifleColor,\n                        'stroke-width': 1\n                    });\n                }\n                scroller.scrollbarStrokeWidth = scroller.scrollbar.strokeWidth();\n                scroller.scrollbarGroup.translate(-scroller.scrollbarStrokeWidth % 2 / 2, -scroller.scrollbarStrokeWidth % 2 / 2);\n                // Draw the buttons:\n                scroller.drawScrollbarButton(0);\n                scroller.drawScrollbarButton(1);\n            }\n            /**\n             * Set scrollbar size, with a given scale.\n             *\n             * @private\n             * @function Highcharts.Scrollbar#setRange\n             * @param {number} from\n             *        scale (0-1) where bar should start\n             * @param {number} to\n             *        scale (0-1) where bar should end\n             */\n            setRange(from, to) {\n                const scroller = this, options = scroller.options, vertical = options.vertical, minWidth = options.minWidth, fullWidth = scroller.barWidth, method = (this.rendered &&\n                    !this.hasDragged &&\n                    !(this.chart.navigator && this.chart.navigator.hasDragged)) ? 'animate' : 'attr';\n                if (!defined(fullWidth)) {\n                    return;\n                }\n                const toPX = fullWidth * Math.min(to, 1);\n                let fromPX, newSize;\n                from = Math.max(from, 0);\n                fromPX = Math.ceil(fullWidth * from);\n                scroller.calculatedWidth = newSize = correctFloat(toPX - fromPX);\n                // We need to recalculate position, if minWidth is used\n                if (newSize < minWidth) {\n                    fromPX = (fullWidth - minWidth + newSize) * from;\n                    newSize = minWidth;\n                }\n                const newPos = Math.floor(fromPX + scroller.xOffset + scroller.yOffset);\n                const newRiflesPos = newSize / 2 - 0.5; // -0.5 -> rifle line width / 2\n                // Store current position:\n                scroller.from = from;\n                scroller.to = to;\n                if (!vertical) {\n                    scroller.scrollbarGroup[method]({\n                        translateX: newPos\n                    });\n                    scroller.scrollbar[method]({\n                        width: newSize\n                    });\n                    scroller.scrollbarRifles[method]({\n                        translateX: newRiflesPos\n                    });\n                    scroller.scrollbarLeft = newPos;\n                    scroller.scrollbarTop = 0;\n                }\n                else {\n                    scroller.scrollbarGroup[method]({\n                        translateY: newPos\n                    });\n                    scroller.scrollbar[method]({\n                        height: newSize\n                    });\n                    scroller.scrollbarRifles[method]({\n                        translateY: newRiflesPos\n                    });\n                    scroller.scrollbarTop = newPos;\n                    scroller.scrollbarLeft = 0;\n                }\n                if (newSize <= 12) {\n                    scroller.scrollbarRifles.hide();\n                }\n                else {\n                    scroller.scrollbarRifles.show();\n                }\n                // Show or hide the scrollbar based on the showFull setting\n                if (options.showFull === false) {\n                    if (from <= 0 && to >= 1) {\n                        scroller.group.hide();\n                    }\n                    else {\n                        scroller.group.show();\n                    }\n                }\n                scroller.rendered = true;\n            }\n            /**\n             * Checks if the extremes should be updated in response to a scrollbar\n             * change event.\n             *\n             * @private\n             * @function Highcharts.Scrollbar#shouldUpdateExtremes\n             */\n            shouldUpdateExtremes(eventType) {\n                return (pick(this.options.liveRedraw, H.svg &&\n                    !H.isTouchDevice &&\n                    !this.chart.boosted) ||\n                    // Mouseup always should change extremes\n                    eventType === 'mouseup' ||\n                    eventType === 'touchend' ||\n                    // Internal events\n                    !defined(eventType));\n            }\n            trackClick(e) {\n                const scroller = this;\n                const normalizedEvent = scroller.chart.pointer?.normalize(e) || e, range = scroller.to - scroller.from, top = scroller.y + scroller.scrollbarTop, left = scroller.x + scroller.scrollbarLeft;\n                if ((scroller.options.vertical && normalizedEvent.chartY > top) ||\n                    (!scroller.options.vertical && normalizedEvent.chartX > left)) {\n                    // On the top or on the left side of the track:\n                    scroller.updatePosition(scroller.from + range, scroller.to + range);\n                }\n                else {\n                    // On the bottom or the right side of the track:\n                    scroller.updatePosition(scroller.from - range, scroller.to - range);\n                }\n                fireEvent(scroller, 'changed', {\n                    from: scroller.from,\n                    to: scroller.to,\n                    trigger: 'scrollbar',\n                    DOMEvent: e\n                });\n            }\n            /**\n             * Update the scrollbar with new options\n             *\n             * @private\n             * @function Highcharts.Scrollbar#update\n             * @param  {Highcharts.ScrollbarOptions} options\n             */\n            update(options) {\n                this.destroy();\n                this.init(this.chart.renderer, merge(true, this.options, options), this.chart);\n            }\n            /**\n             * Update position option in the Scrollbar, with normalized 0-1 scale\n             *\n             * @private\n             * @function Highcharts.Scrollbar#updatePosition\n             * @param  {number} from\n             * @param  {number} to\n             */\n            updatePosition(from, to) {\n                if (to > 1) {\n                    from = correctFloat(1 - correctFloat(to - from));\n                    to = 1;\n                }\n                if (from < 0) {\n                    to = correctFloat(to - from);\n                    from = 0;\n                }\n                this.from = from;\n                this.to = to;\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        Scrollbar.defaultOptions = ScrollbarDefaults;\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        defaultOptions.scrollbar = merge(true, Scrollbar.defaultOptions, defaultOptions.scrollbar);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return Scrollbar;\n    });\n    _registerModule(_modules, 'Stock/Navigator/Navigator.js', [_modules['Core/Axis/Axis.js'], _modules['Stock/Navigator/ChartNavigatorComposition.js'], _modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Core/Axis/NavigatorAxisComposition.js'], _modules['Stock/Navigator/NavigatorComposition.js'], _modules['Stock/Scrollbar/Scrollbar.js'], _modules['Core/Utilities.js']], function (Axis, ChartNavigatorComposition, D, H, NavigatorAxisAdditions, NavigatorComposition, Scrollbar, U) {\n        /* *\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { defaultOptions } = D;\n        const { isTouchDevice } = H;\n        const { addEvent, clamp, correctFloat, defined, destroyObjectProperties, erase, extend, find, fireEvent, isArray, isNumber, merge, pick, removeEvent, splat } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Finding the min or max of a set of variables where we don't know if they are\n         * defined, is a pattern that is repeated several places in Highcharts. Consider\n         * making this a global utility method.\n         * @private\n         */\n        function numExt(extreme, ...args) {\n            const numbers = [].filter.call(args, isNumber);\n            if (numbers.length) {\n                return Math[extreme].apply(0, numbers);\n            }\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The Navigator class\n         *\n         * @private\n         * @class\n         * @name Highcharts.Navigator\n         *\n         * @param {Highcharts.Chart} chart\n         *        Chart object\n         */\n        class Navigator {\n            /* *\n             *\n             *  Static Properties\n             *\n             * */\n            static compose(ChartClass, AxisClass, SeriesClass) {\n                ChartNavigatorComposition.compose(ChartClass, Navigator);\n                NavigatorComposition.compose(ChartClass, AxisClass, SeriesClass);\n            }\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart) {\n                this.scrollbarHeight = 0;\n                this.init(chart);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Draw one of the handles on the side of the zoomed range in the navigator.\n             *\n             * @private\n             * @function Highcharts.Navigator#drawHandle\n             *\n             * @param {number} x\n             *        The x center for the handle\n             *\n             * @param {number} index\n             *        0 for left and 1 for right\n             *\n             * @param {boolean|undefined} inverted\n             *        Flag for chart.inverted\n             *\n             * @param {string} verb\n             *        Use 'animate' or 'attr'\n             */\n            drawHandle(x, index, inverted, verb) {\n                const navigator = this, height = navigator.navigatorOptions.handles.height;\n                // Place it\n                navigator.handles[index][verb](inverted ? {\n                    translateX: Math.round(navigator.left + navigator.height / 2),\n                    translateY: Math.round(navigator.top + parseInt(x, 10) + 0.5 - height)\n                } : {\n                    translateX: Math.round(navigator.left + parseInt(x, 10)),\n                    translateY: Math.round(navigator.top + navigator.height / 2 - height / 2 - 1)\n                });\n            }\n            /**\n             * Render outline around the zoomed range\n             *\n             * @private\n             * @function Highcharts.Navigator#drawOutline\n             *\n             * @param {number} zoomedMin\n             *        in pixels position where zoomed range starts\n             *\n             * @param {number} zoomedMax\n             *        in pixels position where zoomed range ends\n             *\n             * @param {boolean|undefined} inverted\n             *        flag if chart is inverted\n             *\n             * @param {string} verb\n             *        use 'animate' or 'attr'\n             */\n            drawOutline(zoomedMin, zoomedMax, inverted, verb) {\n                const navigator = this, maskInside = navigator.navigatorOptions.maskInside, outlineWidth = navigator.outline.strokeWidth(), halfOutline = outlineWidth / 2, outlineCorrection = (outlineWidth % 2) / 2, // #5800\n                scrollButtonSize = navigator.scrollButtonSize, navigatorSize = navigator.size, navigatorTop = navigator.top, height = navigator.height, lineTop = navigatorTop - halfOutline, lineBtm = navigatorTop + height;\n                let left = navigator.left, verticalMin, path;\n                if (inverted) {\n                    verticalMin = navigatorTop + zoomedMax + outlineCorrection;\n                    zoomedMax = navigatorTop + zoomedMin + outlineCorrection;\n                    path = [\n                        [\n                            'M',\n                            left + height,\n                            navigatorTop - scrollButtonSize - outlineCorrection\n                        ],\n                        // top right of zoomed range\n                        ['L', left + height, verticalMin],\n                        ['L', left, verticalMin],\n                        ['M', left, zoomedMax],\n                        ['L', left + height, zoomedMax],\n                        [\n                            'L',\n                            left + height,\n                            navigatorTop + navigatorSize + scrollButtonSize\n                        ]\n                    ];\n                    if (maskInside) {\n                        path.push(\n                        // upper left of zoomed range\n                        ['M', left + height, verticalMin - halfOutline], \n                        // upper right of z.r.\n                        [\n                            'L',\n                            left + height,\n                            zoomedMax + halfOutline\n                        ]);\n                    }\n                }\n                else {\n                    left -= scrollButtonSize;\n                    zoomedMin += left + scrollButtonSize - outlineCorrection;\n                    zoomedMax += left + scrollButtonSize - outlineCorrection;\n                    path = [\n                        // left\n                        ['M', left, lineTop],\n                        // upper left of zoomed range\n                        ['L', zoomedMin, lineTop],\n                        // lower left of z.r.\n                        ['L', zoomedMin, lineBtm],\n                        // lower right of z.r.\n                        ['M', zoomedMax, lineBtm],\n                        // upper right of z.r.\n                        ['L', zoomedMax, lineTop],\n                        // right\n                        [\n                            'L',\n                            left + navigatorSize + scrollButtonSize * 2,\n                            navigatorTop + halfOutline\n                        ]\n                    ];\n                    if (maskInside) {\n                        path.push(\n                        // upper left of zoomed range\n                        ['M', zoomedMin - halfOutline, lineTop], \n                        // upper right of z.r.\n                        ['L', zoomedMax + halfOutline, lineTop]);\n                    }\n                }\n                navigator.outline[verb]({\n                    d: path\n                });\n            }\n            /**\n             * Render outline around the zoomed range\n             *\n             * @private\n             * @function Highcharts.Navigator#drawMasks\n             *\n             * @param {number} zoomedMin\n             *        in pixels position where zoomed range starts\n             *\n             * @param {number} zoomedMax\n             *        in pixels position where zoomed range ends\n             *\n             * @param {boolean|undefined} inverted\n             *        flag if chart is inverted\n             *\n             * @param {string} verb\n             *        use 'animate' or 'attr'\n             */\n            drawMasks(zoomedMin, zoomedMax, inverted, verb) {\n                const navigator = this, left = navigator.left, top = navigator.top, navigatorHeight = navigator.height;\n                let height, width, x, y;\n                // Determine rectangle position & size\n                // According to (non)inverted position:\n                if (inverted) {\n                    x = [left, left, left];\n                    y = [top, top + zoomedMin, top + zoomedMax];\n                    width = [navigatorHeight, navigatorHeight, navigatorHeight];\n                    height = [\n                        zoomedMin,\n                        zoomedMax - zoomedMin,\n                        navigator.size - zoomedMax\n                    ];\n                }\n                else {\n                    x = [left, left + zoomedMin, left + zoomedMax];\n                    y = [top, top, top];\n                    width = [\n                        zoomedMin,\n                        zoomedMax - zoomedMin,\n                        navigator.size - zoomedMax\n                    ];\n                    height = [navigatorHeight, navigatorHeight, navigatorHeight];\n                }\n                navigator.shades.forEach((shade, i) => {\n                    shade[verb]({\n                        x: x[i],\n                        y: y[i],\n                        width: width[i],\n                        height: height[i]\n                    });\n                });\n            }\n            /**\n             * Generate DOM elements for a navigator:\n             *\n             * - main navigator group\n             *\n             * - all shades\n             *\n             * - outline\n             *\n             * - handles\n             *\n             * @private\n             * @function Highcharts.Navigator#renderElements\n             */\n            renderElements() {\n                const navigator = this, navigatorOptions = navigator.navigatorOptions, maskInside = navigatorOptions.maskInside, chart = navigator.chart, inverted = chart.inverted, renderer = chart.renderer, mouseCursor = {\n                    cursor: inverted ? 'ns-resize' : 'ew-resize'\n                }, \n                // Create the main navigator group\n                navigatorGroup = navigator.navigatorGroup = renderer\n                    .g('navigator')\n                    .attr({\n                    zIndex: 8,\n                    visibility: 'hidden'\n                })\n                    .add();\n                // Create masks, each mask will get events and fill:\n                [\n                    !maskInside,\n                    maskInside,\n                    !maskInside\n                ].forEach((hasMask, index) => {\n                    const shade = renderer.rect()\n                        .addClass('highcharts-navigator-mask' +\n                        (index === 1 ? '-inside' : '-outside'))\n                        .add(navigatorGroup);\n                    if (!chart.styledMode) {\n                        shade.attr({\n                            fill: hasMask ?\n                                navigatorOptions.maskFill :\n                                'rgba(0,0,0,0)'\n                        });\n                        if (index === 1) {\n                            shade.css(mouseCursor);\n                        }\n                    }\n                    navigator.shades[index] = shade;\n                });\n                // Create the outline:\n                navigator.outline = renderer.path()\n                    .addClass('highcharts-navigator-outline')\n                    .add(navigatorGroup);\n                if (!chart.styledMode) {\n                    navigator.outline.attr({\n                        'stroke-width': navigatorOptions.outlineWidth,\n                        stroke: navigatorOptions.outlineColor\n                    });\n                }\n                // Create the handlers:\n                if (navigatorOptions.handles && navigatorOptions.handles.enabled) {\n                    const handlesOptions = navigatorOptions.handles, { height, width } = handlesOptions;\n                    [0, 1].forEach((index) => {\n                        navigator.handles[index] = renderer.symbol(handlesOptions.symbols[index], -width / 2 - 1, 0, width, height, handlesOptions);\n                        if (chart.inverted) {\n                            navigator.handles[index].attr({\n                                rotation: 90,\n                                rotationOriginX: Math.floor(-width / 2),\n                                rotationOriginY: (height + width) / 2\n                            });\n                        }\n                        // zIndex = 6 for right handle, 7 for left.\n                        // Can't be 10, because of the tooltip in inverted chart #2908\n                        navigator.handles[index].attr({ zIndex: 7 - index })\n                            .addClass('highcharts-navigator-handle ' +\n                            'highcharts-navigator-handle-' +\n                            ['left', 'right'][index]).add(navigatorGroup);\n                        if (!chart.styledMode) {\n                            navigator.handles[index]\n                                .attr({\n                                fill: handlesOptions.backgroundColor,\n                                stroke: handlesOptions.borderColor,\n                                'stroke-width': handlesOptions.lineWidth\n                            })\n                                .css(mouseCursor);\n                        }\n                    });\n                }\n            }\n            /**\n             * Update navigator\n             *\n             * @private\n             * @function Highcharts.Navigator#update\n             *\n             * @param {Highcharts.NavigatorOptions} options\n             *        Options to merge in when updating navigator\n             */\n            update(options) {\n                // Remove references to old navigator series in base series\n                (this.series || []).forEach((series) => {\n                    if (series.baseSeries) {\n                        delete series.baseSeries.navigatorSeries;\n                    }\n                });\n                // Destroy and rebuild navigator\n                this.destroy();\n                const chartOptions = this.chart.options;\n                merge(true, chartOptions.navigator, options);\n                this.init(this.chart);\n            }\n            /**\n             * Render the navigator\n             *\n             * @private\n             * @function Highcharts.Navigator#render\n             * @param {number} min\n             *        X axis value minimum\n             * @param {number} max\n             *        X axis value maximum\n             * @param {number} [pxMin]\n             *        Pixel value minimum\n             * @param {number} [pxMax]\n             *        Pixel value maximum\n             */\n            render(min, max, pxMin, pxMax) {\n                const navigator = this, chart = navigator.chart, xAxis = navigator.xAxis, pointRange = xAxis.pointRange || 0, scrollbarXAxis = xAxis.navigatorAxis.fake ? chart.xAxis[0] : xAxis, navigatorEnabled = navigator.navigatorEnabled, rendered = navigator.rendered, inverted = chart.inverted, minRange = chart.xAxis[0].minRange, maxRange = chart.xAxis[0].options.maxRange, scrollButtonSize = navigator.scrollButtonSize;\n                let navigatorWidth, scrollbarLeft, scrollbarTop, scrollbarHeight = navigator.scrollbarHeight, navigatorSize, verb;\n                // Don't redraw while moving the handles (#4703).\n                if (this.hasDragged && !defined(pxMin)) {\n                    return;\n                }\n                min = correctFloat(min - pointRange / 2);\n                max = correctFloat(max + pointRange / 2);\n                // Don't render the navigator until we have data (#486, #4202, #5172).\n                if (!isNumber(min) || !isNumber(max)) {\n                    // However, if navigator was already rendered, we may need to resize\n                    // it. For example hidden series, but visible navigator (#6022).\n                    if (rendered) {\n                        pxMin = 0;\n                        pxMax = pick(xAxis.width, scrollbarXAxis.width);\n                    }\n                    else {\n                        return;\n                    }\n                }\n                navigator.left = pick(xAxis.left, \n                // in case of scrollbar only, without navigator\n                chart.plotLeft + scrollButtonSize +\n                    (inverted ? chart.plotWidth : 0));\n                let zoomedMax = navigator.size = navigatorSize = pick(xAxis.len, (inverted ? chart.plotHeight : chart.plotWidth) -\n                    2 * scrollButtonSize);\n                if (inverted) {\n                    navigatorWidth = scrollbarHeight;\n                }\n                else {\n                    navigatorWidth = navigatorSize + 2 * scrollButtonSize;\n                }\n                // Get the pixel position of the handles\n                pxMin = pick(pxMin, xAxis.toPixels(min, true));\n                pxMax = pick(pxMax, xAxis.toPixels(max, true));\n                // Verify (#1851, #2238)\n                if (!isNumber(pxMin) || Math.abs(pxMin) === Infinity) {\n                    pxMin = 0;\n                    pxMax = navigatorWidth;\n                }\n                // Are we below the minRange? (#2618, #6191)\n                const newMin = xAxis.toValue(pxMin, true), newMax = xAxis.toValue(pxMax, true), currentRange = Math.abs(correctFloat(newMax - newMin));\n                if (currentRange < minRange) {\n                    if (this.grabbedLeft) {\n                        pxMin = xAxis.toPixels(newMax - minRange - pointRange, true);\n                    }\n                    else if (this.grabbedRight) {\n                        pxMax = xAxis.toPixels(newMin + minRange + pointRange, true);\n                    }\n                }\n                else if (defined(maxRange) &&\n                    correctFloat(currentRange - pointRange) > maxRange) {\n                    if (this.grabbedLeft) {\n                        pxMin = xAxis.toPixels(newMax - maxRange - pointRange, true);\n                    }\n                    else if (this.grabbedRight) {\n                        pxMax = xAxis.toPixels(newMin + maxRange + pointRange, true);\n                    }\n                }\n                // Handles are allowed to cross, but never exceed the plot area\n                navigator.zoomedMax = clamp(Math.max(pxMin, pxMax), 0, zoomedMax);\n                navigator.zoomedMin = clamp(navigator.fixedWidth ?\n                    navigator.zoomedMax - navigator.fixedWidth :\n                    Math.min(pxMin, pxMax), 0, zoomedMax);\n                navigator.range = navigator.zoomedMax - navigator.zoomedMin;\n                zoomedMax = Math.round(navigator.zoomedMax);\n                const zoomedMin = Math.round(navigator.zoomedMin);\n                if (navigatorEnabled) {\n                    navigator.navigatorGroup.attr({\n                        visibility: 'inherit'\n                    });\n                    // Place elements\n                    verb = rendered && !navigator.hasDragged ? 'animate' : 'attr';\n                    navigator.drawMasks(zoomedMin, zoomedMax, inverted, verb);\n                    navigator.drawOutline(zoomedMin, zoomedMax, inverted, verb);\n                    if (navigator.navigatorOptions.handles.enabled) {\n                        navigator.drawHandle(zoomedMin, 0, inverted, verb);\n                        navigator.drawHandle(zoomedMax, 1, inverted, verb);\n                    }\n                }\n                if (navigator.scrollbar) {\n                    if (inverted) {\n                        scrollbarTop = navigator.top - scrollButtonSize;\n                        scrollbarLeft = navigator.left - scrollbarHeight +\n                            (navigatorEnabled || !scrollbarXAxis.opposite ? 0 :\n                                // Multiple axes has offsets:\n                                (scrollbarXAxis.titleOffset || 0) +\n                                    // Self margin from the axis.title\n                                    scrollbarXAxis.axisTitleMargin);\n                        scrollbarHeight = navigatorSize + 2 * scrollButtonSize;\n                    }\n                    else {\n                        scrollbarTop = navigator.top + (navigatorEnabled ?\n                            navigator.height :\n                            -scrollbarHeight);\n                        scrollbarLeft = navigator.left - scrollButtonSize;\n                    }\n                    // Reposition scrollbar\n                    navigator.scrollbar.position(scrollbarLeft, scrollbarTop, navigatorWidth, scrollbarHeight);\n                    // Keep scale 0-1\n                    navigator.scrollbar.setRange(\n                    // Use real value, not rounded because range can be very small\n                    // (#1716)\n                    navigator.zoomedMin / (navigatorSize || 1), navigator.zoomedMax / (navigatorSize || 1));\n                }\n                navigator.rendered = true;\n                fireEvent(this, 'afterRender');\n            }\n            /**\n             * Set up the mouse and touch events for the navigator\n             *\n             * @private\n             * @function Highcharts.Navigator#addMouseEvents\n             */\n            addMouseEvents() {\n                const navigator = this, chart = navigator.chart, container = chart.container;\n                let eventsToUnbind = [], mouseMoveHandler, mouseUpHandler;\n                /**\n                 * Create mouse events' handlers.\n                 * Make them as separate functions to enable wrapping them:\n                 */\n                navigator.mouseMoveHandler = mouseMoveHandler = function (e) {\n                    navigator.onMouseMove(e);\n                };\n                navigator.mouseUpHandler = mouseUpHandler = function (e) {\n                    navigator.onMouseUp(e);\n                };\n                // Add shades and handles mousedown events\n                eventsToUnbind = navigator.getPartsEvents('mousedown');\n                eventsToUnbind.push(\n                // Add mouse move and mouseup events. These are bind to doc/div,\n                // because Navigator.grabbedSomething flags are stored in mousedown\n                // events\n                addEvent(chart.renderTo, 'mousemove', mouseMoveHandler), addEvent(container.ownerDocument, 'mouseup', mouseUpHandler), \n                // Touch events\n                addEvent(chart.renderTo, 'touchmove', mouseMoveHandler), addEvent(container.ownerDocument, 'touchend', mouseUpHandler));\n                eventsToUnbind.concat(navigator.getPartsEvents('touchstart'));\n                navigator.eventsToUnbind = eventsToUnbind;\n                // Data events\n                if (navigator.series && navigator.series[0]) {\n                    eventsToUnbind.push(addEvent(navigator.series[0].xAxis, 'foundExtremes', function () {\n                        chart.navigator.modifyNavigatorAxisExtremes();\n                    }));\n                }\n            }\n            /**\n             * Generate events for handles and masks\n             *\n             * @private\n             * @function Highcharts.Navigator#getPartsEvents\n             *\n             * @param {string} eventName\n             *        Event name handler, 'mousedown' or 'touchstart'\n             *\n             * @return {Array<Function>}\n             *         An array of functions to remove navigator functions from the\n             *         events again.\n             */\n            getPartsEvents(eventName) {\n                const navigator = this, events = [];\n                ['shades', 'handles'].forEach(function (name) {\n                    navigator[name].forEach(function (navigatorItem, index) {\n                        events.push(addEvent(navigatorItem.element, eventName, function (e) {\n                            navigator[name + 'Mousedown'](e, index);\n                        }));\n                    });\n                });\n                return events;\n            }\n            /**\n             * Mousedown on a shaded mask, either:\n             *\n             * - will be stored for future drag&drop\n             *\n             * - will directly shift to a new range\n             *\n             * @private\n             * @function Highcharts.Navigator#shadesMousedown\n             *\n             * @param {Highcharts.PointerEventObject} e\n             *        Mouse event\n             *\n             * @param {number} index\n             *        Index of a mask in Navigator.shades array\n             */\n            shadesMousedown(e, index) {\n                e = this.chart.pointer?.normalize(e) || e;\n                const navigator = this, chart = navigator.chart, xAxis = navigator.xAxis, zoomedMin = navigator.zoomedMin, navigatorSize = navigator.size, range = navigator.range;\n                let navigatorPosition = navigator.left, chartX = e.chartX, fixedMax, fixedMin, ext, left;\n                // For inverted chart, swap some options:\n                if (chart.inverted) {\n                    chartX = e.chartY;\n                    navigatorPosition = navigator.top;\n                }\n                if (index === 1) {\n                    // Store information for drag&drop\n                    navigator.grabbedCenter = chartX;\n                    navigator.fixedWidth = range;\n                    navigator.dragOffset = chartX - zoomedMin;\n                }\n                else {\n                    // Shift the range by clicking on shaded areas\n                    left = chartX - navigatorPosition - range / 2;\n                    if (index === 0) {\n                        left = Math.max(0, left);\n                    }\n                    else if (index === 2 && left + range >= navigatorSize) {\n                        left = navigatorSize - range;\n                        if (navigator.reversedExtremes) {\n                            // #7713\n                            left -= range;\n                            fixedMin = navigator.getUnionExtremes().dataMin;\n                        }\n                        else {\n                            // #2293, #3543\n                            fixedMax = navigator.getUnionExtremes().dataMax;\n                        }\n                    }\n                    if (left !== zoomedMin) { // it has actually moved\n                        navigator.fixedWidth = range; // #1370\n                        ext = xAxis.navigatorAxis.toFixedRange(left, left + range, fixedMin, fixedMax);\n                        if (defined(ext.min)) { // #7411\n                            fireEvent(this, 'setRange', {\n                                min: Math.min(ext.min, ext.max),\n                                max: Math.max(ext.min, ext.max),\n                                redraw: true,\n                                eventArguments: {\n                                    trigger: 'navigator'\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n            /**\n             * Mousedown on a handle mask.\n             * Will store necessary information for drag&drop.\n             *\n             * @private\n             * @function Highcharts.Navigator#handlesMousedown\n             * @param {Highcharts.PointerEventObject} e\n             *        Mouse event\n             * @param {number} index\n             *        Index of a handle in Navigator.handles array\n             */\n            handlesMousedown(e, index) {\n                e = this.chart.pointer?.normalize(e) || e;\n                const navigator = this, chart = navigator.chart, baseXAxis = chart.xAxis[0], \n                // For reversed axes, min and max are changed,\n                // so the other extreme should be stored\n                reverse = navigator.reversedExtremes;\n                if (index === 0) {\n                    // Grab the left handle\n                    navigator.grabbedLeft = true;\n                    navigator.otherHandlePos = navigator.zoomedMax;\n                    navigator.fixedExtreme = reverse ? baseXAxis.min : baseXAxis.max;\n                }\n                else {\n                    // Grab the right handle\n                    navigator.grabbedRight = true;\n                    navigator.otherHandlePos = navigator.zoomedMin;\n                    navigator.fixedExtreme = reverse ? baseXAxis.max : baseXAxis.min;\n                }\n                chart.setFixedRange(void 0);\n            }\n            /**\n             * Mouse move event based on x/y mouse position.\n             *\n             * @private\n             * @function Highcharts.Navigator#onMouseMove\n             *\n             * @param {Highcharts.PointerEventObject} e\n             *        Mouse event\n             */\n            onMouseMove(e) {\n                const navigator = this, chart = navigator.chart, navigatorSize = navigator.navigatorSize, range = navigator.range, dragOffset = navigator.dragOffset, inverted = chart.inverted;\n                let left = navigator.left, chartX;\n                // In iOS, a mousemove event with e.pageX === 0 is fired when holding\n                // the finger down in the center of the scrollbar. This should be\n                // ignored.\n                if (!e.touches || e.touches[0].pageX !== 0) { // #4696\n                    e = chart.pointer?.normalize(e) || e;\n                    chartX = e.chartX;\n                    // Swap some options for inverted chart\n                    if (inverted) {\n                        left = navigator.top;\n                        chartX = e.chartY;\n                    }\n                    // Drag left handle or top handle\n                    if (navigator.grabbedLeft) {\n                        navigator.hasDragged = true;\n                        navigator.render(0, 0, chartX - left, navigator.otherHandlePos);\n                        // Drag right handle or bottom handle\n                    }\n                    else if (navigator.grabbedRight) {\n                        navigator.hasDragged = true;\n                        navigator.render(0, 0, navigator.otherHandlePos, chartX - left);\n                        // Drag scrollbar or open area in navigator\n                    }\n                    else if (navigator.grabbedCenter) {\n                        navigator.hasDragged = true;\n                        if (chartX < dragOffset) { // outside left\n                            chartX = dragOffset;\n                            // outside right\n                        }\n                        else if (chartX >\n                            navigatorSize + dragOffset - range) {\n                            chartX = navigatorSize + dragOffset - range;\n                        }\n                        navigator.render(0, 0, chartX - dragOffset, chartX - dragOffset + range);\n                    }\n                    if (navigator.hasDragged &&\n                        navigator.scrollbar &&\n                        pick(navigator.scrollbar.options.liveRedraw, \n                        // By default, don't run live redraw on touch\n                        // devices or if the chart is in boost.\n                        !isTouchDevice &&\n                            !this.chart.boosted)) {\n                        e.DOMType = e.type;\n                        setTimeout(function () {\n                            navigator.onMouseUp(e);\n                        }, 0);\n                    }\n                }\n            }\n            /**\n             * Mouse up event based on x/y mouse position.\n             *\n             * @private\n             * @function Highcharts.Navigator#onMouseUp\n             * @param {Highcharts.PointerEventObject} e\n             *        Mouse event\n             */\n            onMouseUp(e) {\n                const navigator = this, chart = navigator.chart, xAxis = navigator.xAxis, scrollbar = navigator.scrollbar, DOMEvent = e.DOMEvent || e, inverted = chart.inverted, verb = navigator.rendered && !navigator.hasDragged ?\n                    'animate' : 'attr';\n                let zoomedMax, zoomedMin, unionExtremes, fixedMin, fixedMax, ext;\n                if (\n                // MouseUp is called for both, navigator and scrollbar (that order),\n                // which causes calling afterSetExtremes twice. Prevent first call\n                // by checking if scrollbar is going to set new extremes (#6334)\n                (navigator.hasDragged && (!scrollbar || !scrollbar.hasDragged)) ||\n                    e.trigger === 'scrollbar') {\n                    unionExtremes = navigator.getUnionExtremes();\n                    // When dragging one handle, make sure the other one doesn't change\n                    if (navigator.zoomedMin === navigator.otherHandlePos) {\n                        fixedMin = navigator.fixedExtreme;\n                    }\n                    else if (navigator.zoomedMax === navigator.otherHandlePos) {\n                        fixedMax = navigator.fixedExtreme;\n                    }\n                    // Snap to right edge (#4076)\n                    if (navigator.zoomedMax === navigator.size) {\n                        fixedMax = navigator.reversedExtremes ?\n                            unionExtremes.dataMin :\n                            unionExtremes.dataMax;\n                    }\n                    // Snap to left edge (#7576)\n                    if (navigator.zoomedMin === 0) {\n                        fixedMin = navigator.reversedExtremes ?\n                            unionExtremes.dataMax :\n                            unionExtremes.dataMin;\n                    }\n                    ext = xAxis.navigatorAxis.toFixedRange(navigator.zoomedMin, navigator.zoomedMax, fixedMin, fixedMax);\n                    if (defined(ext.min)) {\n                        fireEvent(this, 'setRange', {\n                            min: Math.min(ext.min, ext.max),\n                            max: Math.max(ext.min, ext.max),\n                            redraw: true,\n                            animation: navigator.hasDragged ? false : null,\n                            eventArguments: {\n                                trigger: 'navigator',\n                                triggerOp: 'navigator-drag',\n                                DOMEvent: DOMEvent // #1838\n                            }\n                        });\n                    }\n                }\n                if (e.DOMType !== 'mousemove' &&\n                    e.DOMType !== 'touchmove') {\n                    navigator.grabbedLeft = navigator.grabbedRight =\n                        navigator.grabbedCenter = navigator.fixedWidth =\n                            navigator.fixedExtreme = navigator.otherHandlePos =\n                                navigator.hasDragged = navigator.dragOffset = null;\n                }\n                // Update position of navigator shades, outline and handles (#12573)\n                if (navigator.navigatorEnabled &&\n                    isNumber(navigator.zoomedMin) &&\n                    isNumber(navigator.zoomedMax)) {\n                    zoomedMin = Math.round(navigator.zoomedMin);\n                    zoomedMax = Math.round(navigator.zoomedMax);\n                    if (navigator.shades) {\n                        navigator.drawMasks(zoomedMin, zoomedMax, inverted, verb);\n                    }\n                    if (navigator.outline) {\n                        navigator.drawOutline(zoomedMin, zoomedMax, inverted, verb);\n                    }\n                    if (navigator.navigatorOptions.handles.enabled &&\n                        Object.keys(navigator.handles).length ===\n                            navigator.handles.length) {\n                        navigator.drawHandle(zoomedMin, 0, inverted, verb);\n                        navigator.drawHandle(zoomedMax, 1, inverted, verb);\n                    }\n                }\n            }\n            /**\n             * Removes the event handlers attached previously with addEvents.\n             *\n             * @private\n             * @function Highcharts.Navigator#removeEvents\n             */\n            removeEvents() {\n                if (this.eventsToUnbind) {\n                    this.eventsToUnbind.forEach(function (unbind) {\n                        unbind();\n                    });\n                    this.eventsToUnbind = void 0;\n                }\n                this.removeBaseSeriesEvents();\n            }\n            /**\n             * Remove data events.\n             *\n             * @private\n             * @function Highcharts.Navigator#removeBaseSeriesEvents\n             */\n            removeBaseSeriesEvents() {\n                const baseSeries = this.baseSeries || [];\n                if (this.navigatorEnabled && baseSeries[0]) {\n                    if (this.navigatorOptions.adaptToUpdatedData !== false) {\n                        baseSeries.forEach(function (series) {\n                            removeEvent(series, 'updatedData', this.updatedDataHandler);\n                        }, this);\n                    }\n                    // We only listen for extremes-events on the first baseSeries\n                    if (baseSeries[0].xAxis) {\n                        removeEvent(baseSeries[0].xAxis, 'foundExtremes', this.modifyBaseAxisExtremes);\n                    }\n                }\n            }\n            /**\n             * Initialize the Navigator object\n             *\n             * @private\n             * @function Highcharts.Navigator#init\n             */\n            init(chart) {\n                const chartOptions = chart.options, navigatorOptions = chartOptions.navigator || {}, navigatorEnabled = navigatorOptions.enabled, scrollbarOptions = chartOptions.scrollbar || {}, scrollbarEnabled = scrollbarOptions.enabled, height = navigatorEnabled && navigatorOptions.height || 0, scrollbarHeight = scrollbarEnabled && scrollbarOptions.height || 0, scrollButtonSize = scrollbarOptions.buttonsEnabled && scrollbarHeight || 0;\n                this.handles = [];\n                this.shades = [];\n                this.chart = chart;\n                this.setBaseSeries();\n                this.height = height;\n                this.scrollbarHeight = scrollbarHeight;\n                this.scrollButtonSize = scrollButtonSize;\n                this.scrollbarEnabled = scrollbarEnabled;\n                this.navigatorEnabled = navigatorEnabled;\n                this.navigatorOptions = navigatorOptions;\n                this.scrollbarOptions = scrollbarOptions;\n                this.opposite = pick(navigatorOptions.opposite, Boolean(!navigatorEnabled && chart.inverted)); // #6262\n                const navigator = this, baseSeries = navigator.baseSeries, xAxisIndex = chart.xAxis.length, yAxisIndex = chart.yAxis.length, baseXaxis = baseSeries && baseSeries[0] && baseSeries[0].xAxis ||\n                    chart.xAxis[0] || { options: {} };\n                chart.isDirtyBox = true;\n                if (navigator.navigatorEnabled) {\n                    // an x axis is required for scrollbar also\n                    navigator.xAxis = new Axis(chart, merge({\n                        // inherit base xAxis' break, ordinal options and overscroll\n                        breaks: baseXaxis.options.breaks,\n                        ordinal: baseXaxis.options.ordinal,\n                        overscroll: baseXaxis.options.overscroll\n                    }, navigatorOptions.xAxis, {\n                        id: 'navigator-x-axis',\n                        yAxis: 'navigator-y-axis',\n                        type: 'datetime',\n                        index: xAxisIndex,\n                        isInternal: true,\n                        offset: 0,\n                        keepOrdinalPadding: true,\n                        startOnTick: false,\n                        endOnTick: false,\n                        minPadding: 0,\n                        maxPadding: 0,\n                        zoomEnabled: false\n                    }, chart.inverted ? {\n                        offsets: [scrollButtonSize, 0, -scrollButtonSize, 0],\n                        width: height\n                    } : {\n                        offsets: [0, -scrollButtonSize, 0, scrollButtonSize],\n                        height: height\n                    }), 'xAxis');\n                    navigator.yAxis = new Axis(chart, merge(navigatorOptions.yAxis, {\n                        id: 'navigator-y-axis',\n                        alignTicks: false,\n                        offset: 0,\n                        index: yAxisIndex,\n                        isInternal: true,\n                        reversed: pick((navigatorOptions.yAxis &&\n                            navigatorOptions.yAxis.reversed), (chart.yAxis[0] && chart.yAxis[0].reversed), false),\n                        zoomEnabled: false\n                    }, chart.inverted ? {\n                        width: height\n                    } : {\n                        height: height\n                    }), 'yAxis');\n                    // If we have a base series, initialize the navigator series\n                    if (baseSeries || navigatorOptions.series.data) {\n                        navigator.updateNavigatorSeries(false);\n                        // If not, set up an event to listen for added series\n                    }\n                    else if (chart.series.length === 0) {\n                        navigator.unbindRedraw = addEvent(chart, 'beforeRedraw', function () {\n                            // We've got one, now add it as base\n                            if (chart.series.length > 0 && !navigator.series) {\n                                navigator.setBaseSeries();\n                                navigator.unbindRedraw(); // reset\n                            }\n                        });\n                    }\n                    navigator.reversedExtremes = (chart.inverted && !navigator.xAxis.reversed) || (!chart.inverted && navigator.xAxis.reversed);\n                    // Render items, so we can bind events to them:\n                    navigator.renderElements();\n                    // Add mouse events\n                    navigator.addMouseEvents();\n                    // in case of scrollbar only, fake an x axis to get translation\n                }\n                else {\n                    navigator.xAxis = {\n                        chart,\n                        navigatorAxis: {\n                            fake: true\n                        },\n                        translate: function (value, reverse) {\n                            const axis = chart.xAxis[0], ext = axis.getExtremes(), scrollTrackWidth = axis.len - 2 * scrollButtonSize, min = numExt('min', axis.options.min, ext.dataMin), valueRange = numExt('max', axis.options.max, ext.dataMax) - min;\n                            return reverse ?\n                                // from pixel to value\n                                (value * valueRange / scrollTrackWidth) + min :\n                                // from value to pixel\n                                scrollTrackWidth * (value - min) / valueRange;\n                        },\n                        toPixels: function (value) {\n                            return this.translate(value);\n                        },\n                        toValue: function (value) {\n                            return this.translate(value, true);\n                        }\n                    };\n                    navigator.xAxis.navigatorAxis.axis = navigator.xAxis;\n                    navigator.xAxis.navigatorAxis.toFixedRange = (NavigatorAxisAdditions.prototype.toFixedRange.bind(navigator.xAxis.navigatorAxis));\n                }\n                // Initialize the scrollbar\n                if (chart.options.scrollbar.enabled) {\n                    const options = merge(chart.options.scrollbar, { vertical: chart.inverted });\n                    if (!isNumber(options.margin) && navigator.navigatorEnabled) {\n                        options.margin = chart.inverted ? -3 : 3;\n                    }\n                    chart.scrollbar = navigator.scrollbar = new Scrollbar(chart.renderer, options, chart);\n                    addEvent(navigator.scrollbar, 'changed', function (e) {\n                        const range = navigator.size, to = range * this.to, from = range * this.from;\n                        navigator.hasDragged = navigator.scrollbar.hasDragged;\n                        navigator.render(0, 0, from, to);\n                        if (this.shouldUpdateExtremes(e.DOMType)) {\n                            setTimeout(function () {\n                                navigator.onMouseUp(e);\n                            });\n                        }\n                    });\n                }\n                // Add data events\n                navigator.addBaseSeriesEvents();\n                // Add redraw events\n                navigator.addChartEvents();\n            }\n            /**\n             * Get the union data extremes of the chart - the outer data extremes of the\n             * base X axis and the navigator axis.\n             *\n             * @private\n             * @function Highcharts.Navigator#getUnionExtremes\n             */\n            getUnionExtremes(returnFalseOnNoBaseSeries) {\n                const baseAxis = this.chart.xAxis[0], navAxis = this.xAxis, navAxisOptions = navAxis.options, baseAxisOptions = baseAxis.options;\n                let ret;\n                if (!returnFalseOnNoBaseSeries || baseAxis.dataMin !== null) {\n                    ret = {\n                        dataMin: pick(// #4053\n                        navAxisOptions && navAxisOptions.min, numExt('min', baseAxisOptions.min, baseAxis.dataMin, navAxis.dataMin, navAxis.min)),\n                        dataMax: pick(navAxisOptions && navAxisOptions.max, numExt('max', baseAxisOptions.max, baseAxis.dataMax, navAxis.dataMax, navAxis.max))\n                    };\n                }\n                return ret;\n            }\n            /**\n             * Set the base series and update the navigator series from this. With a bit\n             * of modification we should be able to make this an API method to be called\n             * from the outside\n             *\n             * @private\n             * @function Highcharts.Navigator#setBaseSeries\n             * @param {Highcharts.SeriesOptionsType} [baseSeriesOptions]\n             *        Additional series options for a navigator\n             * @param {boolean} [redraw]\n             *        Whether to redraw after update.\n             */\n            setBaseSeries(baseSeriesOptions, redraw) {\n                const chart = this.chart, baseSeries = this.baseSeries = [];\n                baseSeriesOptions = (baseSeriesOptions ||\n                    chart.options && chart.options.navigator.baseSeries ||\n                    (chart.series.length ?\n                        // Find the first non-navigator series (#8430)\n                        find(chart.series, (s) => (!s.options.isInternal)).index :\n                        0));\n                // Iterate through series and add the ones that should be shown in\n                // navigator.\n                (chart.series || []).forEach((series, i) => {\n                    if (\n                    // Don't include existing nav series\n                    !series.options.isInternal &&\n                        (series.options.showInNavigator ||\n                            (i === baseSeriesOptions ||\n                                series.options.id === baseSeriesOptions) &&\n                                series.options.showInNavigator !== false)) {\n                        baseSeries.push(series);\n                    }\n                });\n                // When run after render, this.xAxis already exists\n                if (this.xAxis && !this.xAxis.navigatorAxis.fake) {\n                    this.updateNavigatorSeries(true, redraw);\n                }\n            }\n            /**\n             * Update series in the navigator from baseSeries, adding new if does not\n             * exist.\n             *\n             * @private\n             * @function Highcharts.Navigator.updateNavigatorSeries\n             */\n            updateNavigatorSeries(addEvents, redraw) {\n                const navigator = this, chart = navigator.chart, baseSeries = navigator.baseSeries, navSeriesMixin = {\n                    enableMouseTracking: false,\n                    index: null,\n                    linkedTo: null,\n                    group: 'nav',\n                    padXAxis: false,\n                    xAxis: 'navigator-x-axis',\n                    yAxis: 'navigator-y-axis',\n                    showInLegend: false,\n                    stacking: void 0,\n                    isInternal: true,\n                    states: {\n                        inactive: {\n                            opacity: 1\n                        }\n                    }\n                }, \n                // Remove navigator series that are no longer in the baseSeries\n                navigatorSeries = navigator.series =\n                    (navigator.series || []).filter((navSeries) => {\n                        const base = navSeries.baseSeries;\n                        if (baseSeries.indexOf(base) < 0) { // Not in array\n                            // If there is still a base series connected to this\n                            // series, remove event handler and reference.\n                            if (base) {\n                                removeEvent(base, 'updatedData', navigator.updatedDataHandler);\n                                delete base.navigatorSeries;\n                            }\n                            // Kill the nav series. It may already have been\n                            // destroyed (#8715).\n                            if (navSeries.chart) {\n                                navSeries.destroy();\n                            }\n                            return false;\n                        }\n                        return true;\n                    });\n                let baseOptions, mergedNavSeriesOptions, chartNavigatorSeriesOptions = navigator.navigatorOptions.series, baseNavigatorOptions;\n                // Go through each base series and merge the options to create new\n                // series\n                if (baseSeries && baseSeries.length) {\n                    baseSeries.forEach((base) => {\n                        const linkedNavSeries = base.navigatorSeries, userNavOptions = extend(\n                        // Grab color and visibility from base as default\n                        {\n                            color: base.color,\n                            visible: base.visible\n                        }, !isArray(chartNavigatorSeriesOptions) ?\n                            chartNavigatorSeriesOptions :\n                            defaultOptions.navigator.series);\n                        // Don't update if the series exists in nav and we have disabled\n                        // adaptToUpdatedData.\n                        if (linkedNavSeries &&\n                            navigator.navigatorOptions.adaptToUpdatedData === false) {\n                            return;\n                        }\n                        navSeriesMixin.name = 'Navigator ' + baseSeries.length;\n                        baseOptions = base.options || {};\n                        baseNavigatorOptions = baseOptions.navigatorOptions || {};\n                        // The dataLabels options are not merged correctly\n                        // if the settings are an array, #13847.\n                        userNavOptions.dataLabels = splat(userNavOptions.dataLabels);\n                        mergedNavSeriesOptions = merge(baseOptions, navSeriesMixin, userNavOptions, baseNavigatorOptions);\n                        // Once nav series type is resolved, pick correct pointRange\n                        mergedNavSeriesOptions.pointRange = pick(\n                        // Stricte set pointRange in options\n                        userNavOptions.pointRange, baseNavigatorOptions.pointRange, \n                        // Fallback to default values, e.g. `null` for column\n                        defaultOptions.plotOptions[mergedNavSeriesOptions.type || 'line'].pointRange);\n                        // Merge data separately. Do a slice to avoid mutating the\n                        // navigator options from base series (#4923).\n                        const navigatorSeriesData = baseNavigatorOptions.data || userNavOptions.data;\n                        navigator.hasNavigatorData =\n                            navigator.hasNavigatorData || !!navigatorSeriesData;\n                        mergedNavSeriesOptions.data =\n                            navigatorSeriesData ||\n                                baseOptions.data && baseOptions.data.slice(0);\n                        // Update or add the series\n                        if (linkedNavSeries && linkedNavSeries.options) {\n                            linkedNavSeries.update(mergedNavSeriesOptions, redraw);\n                        }\n                        else {\n                            base.navigatorSeries = chart.initSeries(mergedNavSeriesOptions);\n                            // Set data on initial run with dataSorting enabled (#20318)\n                            chart.setSortedData();\n                            base.navigatorSeries.baseSeries = base; // Store ref\n                            navigatorSeries.push(base.navigatorSeries);\n                        }\n                    });\n                }\n                // If user has defined data (and no base series) or explicitly defined\n                // navigator.series as an array, we create these series on top of any\n                // base series.\n                if (chartNavigatorSeriesOptions.data &&\n                    !(baseSeries && baseSeries.length) ||\n                    isArray(chartNavigatorSeriesOptions)) {\n                    navigator.hasNavigatorData = false;\n                    // Allow navigator.series to be an array\n                    chartNavigatorSeriesOptions =\n                        splat(chartNavigatorSeriesOptions);\n                    chartNavigatorSeriesOptions.forEach((userSeriesOptions, i) => {\n                        navSeriesMixin.name =\n                            'Navigator ' + (navigatorSeries.length + 1);\n                        mergedNavSeriesOptions = merge(defaultOptions.navigator.series, {\n                            // Since we don't have a base series to pull color from,\n                            // try to fake it by using color from series with same\n                            // index. Otherwise pull from the colors array. We need\n                            // an explicit color as otherwise updates will increment\n                            // color counter and we'll get a new color for each\n                            // update of the nav series.\n                            color: chart.series[i] &&\n                                !chart.series[i].options.isInternal &&\n                                chart.series[i].color ||\n                                chart.options.colors[i] ||\n                                chart.options.colors[0]\n                        }, navSeriesMixin, userSeriesOptions);\n                        mergedNavSeriesOptions.data = userSeriesOptions.data;\n                        if (mergedNavSeriesOptions.data) {\n                            navigator.hasNavigatorData = true;\n                            navigatorSeries.push(chart.initSeries(mergedNavSeriesOptions));\n                        }\n                    });\n                }\n                if (addEvents) {\n                    this.addBaseSeriesEvents();\n                }\n            }\n            /**\n             * Add data events.\n             * For example when main series is updated we need to recalculate extremes\n             *\n             * @private\n             * @function Highcharts.Navigator#addBaseSeriesEvent\n             */\n            addBaseSeriesEvents() {\n                const navigator = this, baseSeries = navigator.baseSeries || [];\n                // Bind modified extremes event to first base's xAxis only.\n                // In event of > 1 base-xAxes, the navigator will ignore those.\n                // Adding this multiple times to the same axis is no problem, as\n                // duplicates should be discarded by the browser.\n                if (baseSeries[0] && baseSeries[0].xAxis) {\n                    baseSeries[0].eventsToUnbind.push(addEvent(baseSeries[0].xAxis, 'foundExtremes', this.modifyBaseAxisExtremes));\n                }\n                baseSeries.forEach((base) => {\n                    // Link base series show/hide to navigator series visibility\n                    base.eventsToUnbind.push(addEvent(base, 'show', function () {\n                        if (this.navigatorSeries) {\n                            this.navigatorSeries.setVisible(true, false);\n                        }\n                    }));\n                    base.eventsToUnbind.push(addEvent(base, 'hide', function () {\n                        if (this.navigatorSeries) {\n                            this.navigatorSeries.setVisible(false, false);\n                        }\n                    }));\n                    // Respond to updated data in the base series, unless explicitly\n                    // not adapting to data changes.\n                    if (this.navigatorOptions.adaptToUpdatedData !== false) {\n                        if (base.xAxis) {\n                            base.eventsToUnbind.push(addEvent(base, 'updatedData', this.updatedDataHandler));\n                        }\n                    }\n                    // Handle series removal\n                    base.eventsToUnbind.push(addEvent(base, 'remove', function () {\n                        if (this.navigatorSeries) {\n                            erase(navigator.series, this.navigatorSeries);\n                            if (defined(this.navigatorSeries.options)) {\n                                this.navigatorSeries.remove(false);\n                            }\n                            delete this.navigatorSeries;\n                        }\n                    }));\n                });\n            }\n            /**\n             * Get minimum from all base series connected to the navigator\n             * @private\n             * @param {number} currentSeriesMin\n             *        Minium from the current series\n             * @return {number}\n             *         Minimum from all series\n             */\n            getBaseSeriesMin(currentSeriesMin) {\n                return this.baseSeries.reduce(function (min, series) {\n                    // (#10193)\n                    return Math.min(min, series.xData && series.xData.length ?\n                        series.xData[0] : min);\n                }, currentSeriesMin);\n            }\n            /**\n             * Set the navigator x axis extremes to reflect the total. The navigator\n             * extremes should always be the extremes of the union of all series in the\n             * chart as well as the navigator series.\n             *\n             * @private\n             * @function Highcharts.Navigator#modifyNavigatorAxisExtremes\n             */\n            modifyNavigatorAxisExtremes() {\n                const xAxis = this.xAxis;\n                if (typeof xAxis.getExtremes !== 'undefined') {\n                    const unionExtremes = this.getUnionExtremes(true);\n                    if (unionExtremes &&\n                        (unionExtremes.dataMin !== xAxis.min ||\n                            unionExtremes.dataMax !== xAxis.max)) {\n                        xAxis.min = unionExtremes.dataMin;\n                        xAxis.max = unionExtremes.dataMax;\n                    }\n                }\n            }\n            /**\n             * Hook to modify the base axis extremes with information from the Navigator\n             *\n             * @private\n             * @function Highcharts.Navigator#modifyBaseAxisExtremes\n             */\n            modifyBaseAxisExtremes() {\n                const baseXAxis = this, navigator = baseXAxis.chart.navigator, baseExtremes = baseXAxis.getExtremes(), baseMin = baseExtremes.min, baseMax = baseExtremes.max, baseDataMin = baseExtremes.dataMin, baseDataMax = baseExtremes.dataMax, range = baseMax - baseMin, stickToMin = navigator.stickToMin, stickToMax = navigator.stickToMax, overscroll = pick(baseXAxis.ordinal?.convertOverscroll(baseXAxis.options.overscroll), 0), navigatorSeries = navigator.series && navigator.series[0], hasSetExtremes = !!baseXAxis.setExtremes, \n                // When the extremes have been set by range selector button, don't\n                // stick to min or max. The range selector buttons will handle the\n                // extremes. (#5489)\n                unmutable = baseXAxis.eventArgs &&\n                    baseXAxis.eventArgs.trigger === 'rangeSelectorButton';\n                let newMax, newMin;\n                if (!unmutable) {\n                    // If the zoomed range is already at the min, move it to the right\n                    // as new data comes in\n                    if (stickToMin) {\n                        newMin = baseDataMin;\n                        newMax = newMin + range;\n                    }\n                    // If the zoomed range is already at the max, move it to the right\n                    // as new data comes in\n                    if (stickToMax) {\n                        newMax = baseDataMax + overscroll;\n                        // If stickToMin is true, the new min value is set above\n                        if (!stickToMin) {\n                            newMin = Math.max(baseDataMin, // don't go below data extremes (#13184)\n                            newMax - range, navigator.getBaseSeriesMin(navigatorSeries && navigatorSeries.xData ?\n                                navigatorSeries.xData[0] :\n                                -Number.MAX_VALUE));\n                        }\n                    }\n                    // Update the extremes\n                    if (hasSetExtremes && (stickToMin || stickToMax)) {\n                        if (isNumber(newMin)) {\n                            baseXAxis.min = baseXAxis.userMin = newMin;\n                            baseXAxis.max = baseXAxis.userMax = newMax;\n                        }\n                    }\n                }\n                // Reset\n                navigator.stickToMin =\n                    navigator.stickToMax = null;\n            }\n            /**\n             * Handler for updated data on the base series. When data is modified, the\n             * navigator series must reflect it. This is called from the Chart.redraw\n             * function before axis and series extremes are computed.\n             *\n             * @private\n             * @function Highcharts.Navigator#updateDataHandler\n             */\n            updatedDataHandler() {\n                const navigator = this.chart.navigator, baseSeries = this, navigatorSeries = this.navigatorSeries, shouldStickToMax = navigator.reversedExtremes ?\n                    Math.round(navigator.zoomedMin) === 0 :\n                    Math.round(navigator.zoomedMax) >= Math.round(navigator.size);\n                // If the scrollbar is scrolled all the way to the right, keep right as\n                // new data comes in, unless user set navigator.stickToMax to false.\n                navigator.stickToMax = pick(this.chart.options.navigator &&\n                    this.chart.options.navigator.stickToMax, shouldStickToMax);\n                navigator.stickToMin = navigator.shouldStickToMin(baseSeries, navigator);\n                // Set the navigator series data to the new data of the base series\n                if (navigatorSeries && !navigator.hasNavigatorData) {\n                    navigatorSeries.options.pointStart = baseSeries.xData[0];\n                    navigatorSeries.setData(baseSeries.options.data, false, null, false); // #5414\n                }\n            }\n            /**\n             * Detect if the zoomed area should stick to the minimum, #14742.\n             *\n             * @private\n             * @function Highcharts.Navigator#shouldStickToMin\n             */\n            shouldStickToMin(baseSeries, navigator) {\n                const xDataMin = navigator.getBaseSeriesMin(baseSeries.xData[0]), xAxis = baseSeries.xAxis, max = xAxis.max, min = xAxis.min, range = xAxis.options.range;\n                let stickToMin = true;\n                if (isNumber(max) && isNumber(min)) {\n                    // If range declared, stick to the minimum only if the range\n                    // is smaller than the data set range.\n                    if (range && max - xDataMin > 0) {\n                        stickToMin = max - xDataMin < range;\n                    }\n                    else {\n                        // If the current axis minimum falls outside the new\n                        // updated dataset, we must adjust.\n                        stickToMin = min <= xDataMin;\n                    }\n                }\n                else {\n                    stickToMin = false; // #15864\n                }\n                return stickToMin;\n            }\n            /**\n             * Add chart events, like redrawing navigator, when chart requires that.\n             *\n             * @private\n             * @function Highcharts.Navigator#addChartEvents\n             */\n            addChartEvents() {\n                if (!this.eventsToUnbind) {\n                    this.eventsToUnbind = [];\n                }\n                this.eventsToUnbind.push(\n                // Move the scrollbar after redraw, like after data updata even if\n                // axes don't redraw\n                addEvent(this.chart, 'redraw', function () {\n                    const navigator = this.navigator, xAxis = navigator && (navigator.baseSeries &&\n                        navigator.baseSeries[0] &&\n                        navigator.baseSeries[0].xAxis ||\n                        this.xAxis[0]); // #5709, #13114\n                    if (xAxis) {\n                        navigator.render(xAxis.min, xAxis.max);\n                    }\n                }), \n                // Make room for the navigator, can be placed around the chart:\n                addEvent(this.chart, 'getMargins', function () {\n                    let chart = this, navigator = chart.navigator, marginName = navigator.opposite ?\n                        'plotTop' : 'marginBottom';\n                    if (chart.inverted) {\n                        marginName = navigator.opposite ?\n                            'marginRight' : 'plotLeft';\n                    }\n                    chart[marginName] =\n                        (chart[marginName] || 0) + (navigator.navigatorEnabled || !chart.inverted ?\n                            navigator.height + navigator.scrollbarHeight :\n                            0) + navigator.navigatorOptions.margin;\n                }), addEvent(Navigator, 'setRange', function (e) {\n                    this.chart.xAxis[0].setExtremes(e.min, e.max, e.redraw, e.animation, e.eventArguments);\n                }));\n            }\n            /**\n             * Destroys allocated elements.\n             *\n             * @private\n             * @function Highcharts.Navigator#destroy\n             */\n            destroy() {\n                // Disconnect events added in addEvents\n                this.removeEvents();\n                if (this.xAxis) {\n                    erase(this.chart.xAxis, this.xAxis);\n                    erase(this.chart.axes, this.xAxis);\n                }\n                if (this.yAxis) {\n                    erase(this.chart.yAxis, this.yAxis);\n                    erase(this.chart.axes, this.yAxis);\n                }\n                // Destroy series\n                (this.series || []).forEach((s) => {\n                    if (s.destroy) {\n                        s.destroy();\n                    }\n                });\n                // Destroy properties\n                [\n                    'series', 'xAxis', 'yAxis', 'shades', 'outline', 'scrollbarTrack',\n                    'scrollbarRifles', 'scrollbarGroup', 'scrollbar', 'navigatorGroup',\n                    'rendered'\n                ].forEach((prop) => {\n                    if (this[prop] && this[prop].destroy) {\n                        this[prop].destroy();\n                    }\n                    this[prop] = null;\n                });\n                // Destroy elements in collection\n                [this.handles].forEach((coll) => {\n                    destroyObjectProperties(coll);\n                });\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return Navigator;\n    });\n    _registerModule(_modules, 'Stock/RangeSelector/RangeSelectorDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Declarations\n         *\n         * */\n        /**\n         * Language object. The language object is global and it can't be set\n         * on each chart initialization. Instead, use `Highcharts.setOptions` to\n         * set it before any chart is initialized.\n         *\n         * ```js\n         * Highcharts.setOptions({\n         *     lang: {\n         *         months: [\n         *             'Janvier', 'FÃ©vrier', 'Mars', 'Avril',\n         *             'Mai', 'Juin', 'Juillet', 'AoÃ»t',\n         *             'Septembre', 'Octobre', 'Novembre', 'DÃ©cembre'\n         *         ],\n         *         weekdays: [\n         *             'Dimanche', 'Lundi', 'Mardi', 'Mercredi',\n         *             'Jeudi', 'Vendredi', 'Samedi'\n         *         ]\n         *     }\n         * });\n         * ```\n         *\n         * @optionparent lang\n         */\n        const lang = {\n            /**\n             * The text for the label for the range selector buttons.\n             *\n             * @product highstock gantt\n             */\n            rangeSelectorZoom: 'Zoom',\n            /**\n             * The text for the label for the \"from\" input box in the range\n             * selector. Since v9.0, this string is empty as the label is not\n             * rendered by default.\n             *\n             * @product highstock gantt\n             */\n            rangeSelectorFrom: '',\n            /**\n             * The text for the label for the \"to\" input box in the range selector.\n             *\n             * @product highstock gantt\n             */\n            rangeSelectorTo: 'â†’'\n        };\n        /**\n         * The range selector is a tool for selecting ranges to display within\n         * the chart. It provides buttons to select preconfigured ranges in\n         * the chart, like 1 day, 1 week, 1 month etc. It also provides input\n         * boxes where min and max dates can be manually input.\n         *\n         * @product      highstock gantt\n         * @optionparent rangeSelector\n         */\n        const rangeSelector = {\n            /**\n             * Whether to enable all buttons from the start. By default buttons are\n             * only enabled if the corresponding time range exists on the X axis,\n             * but enabling all buttons allows for dynamically loading different\n             * time ranges.\n             *\n             * @sample {highstock} stock/rangeselector/allbuttonsenabled-true/\n             *         All buttons enabled\n             *\n             * @since     2.0.3\n             */\n            allButtonsEnabled: false,\n            /**\n             * An array of configuration objects for the buttons.\n             *\n             * Defaults to:\n             * ```js\n             * buttons: [{\n             *     type: 'month',\n             *     count: 1,\n             *     text: '1m',\n             *     title: 'View 1 month'\n             * }, {\n             *     type: 'month',\n             *     count: 3,\n             *     text: '3m',\n             *     title: 'View 3 months'\n             * }, {\n             *     type: 'month',\n             *     count: 6,\n             *     text: '6m',\n             *     title: 'View 6 months'\n             * }, {\n             *     type: 'ytd',\n             *     text: 'YTD',\n             *     title: 'View year to date'\n             * }, {\n             *     type: 'year',\n             *     count: 1,\n             *     text: '1y',\n             *     title: 'View 1 year'\n             * }, {\n             *     type: 'all',\n             *     text: 'All',\n             *     title: 'View all'\n             * }]\n             * ```\n             *\n             * @sample {highstock} stock/demo/rangeselector-datagrouping/\n             *         Data grouping by buttons\n             *\n             * @type      {Array<*>}\n             */\n            buttons: void 0,\n            /**\n             * How many units of the defined type the button should span. If `type`\n             * is \"month\" and `count` is 3, the button spans three months.\n             *\n             * @type      {number}\n             * @default   1\n             * @apioption rangeSelector.buttons.count\n             */\n            /**\n             * Fires when clicking on the rangeSelector button. One parameter,\n             * event, is passed to the function, containing common event\n             * information.\n             *\n             * ```js\n             * click: function(e) {\n             *   console.log(this);\n             * }\n             * ```\n             *\n             * Return false to stop default button's click action.\n             *\n             * @sample {highstock} stock/rangeselector/button-click/\n             *         Click event on the button\n             *\n             * @type      {Highcharts.RangeSelectorClickCallbackFunction}\n             * @apioption rangeSelector.buttons.events.click\n             */\n            /**\n             * Additional range (in milliseconds) added to the end of the calculated\n             * time span.\n             *\n             * @sample {highstock} stock/rangeselector/min-max-offsets/\n             *         Button offsets\n             *\n             * @type      {number}\n             * @default   0\n             * @since     6.0.0\n             * @apioption rangeSelector.buttons.offsetMax\n             */\n            /**\n             * Additional range (in milliseconds) added to the start of the\n             * calculated time span.\n             *\n             * @sample {highstock} stock/rangeselector/min-max-offsets/\n             *         Button offsets\n             *\n             * @type      {number}\n             * @default   0\n             * @since     6.0.0\n             * @apioption rangeSelector.buttons.offsetMin\n             */\n            /**\n             * When buttons apply dataGrouping on a series, by default zooming\n             * in/out will deselect buttons and unset dataGrouping. Enable this\n             * option to keep buttons selected when extremes change.\n             *\n             * @sample {highstock} stock/rangeselector/preserve-datagrouping/\n             *         Different preserveDataGrouping settings\n             *\n             * @type      {boolean}\n             * @default   false\n             * @since     6.1.2\n             * @apioption rangeSelector.buttons.preserveDataGrouping\n             */\n            /**\n             * A custom data grouping object for each button.\n             *\n             * @see [series.dataGrouping](#plotOptions.series.dataGrouping)\n             *\n             * @sample {highstock} stock/demo/rangeselector-datagrouping/\n             *         Data grouping by range selector buttons\n             *\n             * @type      {*}\n             * @extends   plotOptions.series.dataGrouping\n             * @apioption rangeSelector.buttons.dataGrouping\n             */\n            /**\n             * The text for the button itself.\n             *\n             * @type      {string}\n             * @apioption rangeSelector.buttons.text\n             */\n            /**\n             * Explanation for the button, shown as a tooltip on hover, and used by\n             * assistive technology.\n             *\n             * @type      {string}\n             * @apioption rangeSelector.buttons.title\n             */\n            /**\n             * Defined the time span for the button. Can be one of `millisecond`,\n             * `second`, `minute`, `hour`, `day`, `week`, `month`, `year`, `ytd`,\n             * and `all`.\n             *\n             * @type       {Highcharts.RangeSelectorButtonTypeValue}\n             * @apioption  rangeSelector.buttons.type\n             */\n            /**\n             * The space in pixels between the buttons in the range selector.\n             */\n            buttonSpacing: 5,\n            /**\n             * Whether to collapse the range selector buttons into a dropdown when\n             * there is not enough room to show everything in a single row, instead\n             * of dividing the range selector into multiple rows.\n             * Can be one of the following:\n             *  - `always`: Always collapse\n             *  - `responsive`: Only collapse when there is not enough room\n             *  - `never`: Never collapse\n             *\n             * @sample {highstock} stock/rangeselector/dropdown/\n             *         Dropdown option\n             *\n             * @validvalue [\"always\", \"responsive\", \"never\"]\n             * @since 9.0.0\n             */\n            dropdown: 'responsive',\n            /**\n             * Enable or disable the range selector. Default to `true` for stock\n             * charts, using the `stockChart` factory.\n             *\n             * @sample {highstock} stock/rangeselector/enabled/\n             *         Disable the range selector\n             *\n             * @type {boolean|undefined}\n             * @default {highstock} true\n             */\n            enabled: void 0,\n            /**\n             * The vertical alignment of the rangeselector box. Allowed properties\n             * are `top`, `middle`, `bottom`.\n             *\n             * @sample {highstock} stock/rangeselector/vertical-align-middle/\n             *         Middle\n             * @sample {highstock} stock/rangeselector/vertical-align-bottom/\n             *         Bottom\n             *\n             * @type  {Highcharts.VerticalAlignValue}\n             * @since 6.0.0\n             */\n            verticalAlign: 'top',\n            /**\n             * A collection of attributes for the buttons. The object takes SVG\n             * attributes like `fill`, `stroke`, `stroke-width`, as well as `style`,\n             * a collection of CSS properties for the text.\n             *\n             * The object can also be extended with states, so you can set\n             * presentational options for `hover`, `select` or `disabled` button\n             * states.\n             *\n             * CSS styles for the text label.\n             *\n             * In styled mode, the buttons are styled by the\n             * `.highcharts-range-selector-buttons .highcharts-button` rule with its\n             * different states.\n             *\n             * @sample {highstock} stock/rangeselector/styling/\n             *         Styling the buttons and inputs\n             *\n             * @type {Highcharts.SVGAttributes}\n             */\n            buttonTheme: {\n                /** @ignore */\n                width: 28,\n                /** @ignore */\n                height: 18,\n                /** @ignore */\n                padding: 2,\n                /** @ignore */\n                zIndex: 7 // #484, #852\n            },\n            /**\n             * When the rangeselector is floating, the plot area does not reserve\n             * space for it. This opens for positioning anywhere on the chart.\n             *\n             * @sample {highstock} stock/rangeselector/floating/\n             *         Placing the range selector between the plot area and the\n             *         navigator\n             *\n             * @since 6.0.0\n             */\n            floating: false,\n            /**\n             * The x offset of the range selector relative to its horizontal\n             * alignment within `chart.spacingLeft` and `chart.spacingRight`.\n             *\n             * @since 6.0.0\n             */\n            x: 0,\n            /**\n             * The y offset of the range selector relative to its horizontal\n             * alignment within `chart.spacingLeft` and `chart.spacingRight`.\n             *\n             * @since 6.0.0\n             */\n            y: 0,\n            /**\n             * Deprecated. The height of the range selector. Currently it is\n             * calculated dynamically.\n             *\n             * @deprecated\n             * @type  {number|undefined}\n             * @since 2.1.9\n             */\n            height: void 0,\n            /**\n             * The border color of the date input boxes.\n             *\n             * @sample {highstock} stock/rangeselector/styling/\n             *         Styling the buttons and inputs\n             *\n             * @type      {Highcharts.ColorString}\n             * @since     1.3.7\n             */\n            inputBoxBorderColor: 'none',\n            /**\n             * The pixel height of the date input boxes.\n             *\n             * @sample {highstock} stock/rangeselector/styling/\n             *         Styling the buttons and inputs\n             *\n             * @since     1.3.7\n             */\n            inputBoxHeight: 17,\n            /**\n             * The pixel width of the date input boxes. When `undefined`, the width\n             * is fitted to the rendered content.\n             *\n             * @sample {highstock} stock/rangeselector/styling/\n             *         Styling the buttons and inputs\n             *\n             * @type   {number|undefined}\n             * @since  1.3.7\n             */\n            inputBoxWidth: void 0,\n            /**\n             * The date format in the input boxes when not selected for editing.\n             * Defaults to `%e %b %Y`.\n             *\n             * This is used to determine which type of input to show,\n             * `datetime-local`, `date` or `time` and falling back to `text` when\n             * the browser does not support the input type or the format contains\n             * milliseconds.\n             *\n             * @sample {highstock} stock/rangeselector/input-type/\n             *         Input types\n             * @sample {highstock} stock/rangeselector/input-format/\n             *         Milliseconds in the range selector\n             *\n             */\n            inputDateFormat: '%e %b %Y',\n            /**\n             * A custom callback function to parse values entered in the input boxes\n             * and return a valid JavaScript time as milliseconds since 1970.\n             * The first argument passed is a value to parse,\n             * second is a boolean indicating use of the UTC time.\n             *\n             * This will only get called for inputs of type `text`. Since v8.2.3,\n             * the input type is dynamically determined based on the granularity\n             * of the `inputDateFormat` and the browser support.\n             *\n             * @sample {highstock} stock/rangeselector/input-format/\n             *         Milliseconds in the range selector\n             *\n             * @type      {Highcharts.RangeSelectorParseCallbackFunction}\n             * @since     1.3.3\n             */\n            inputDateParser: void 0,\n            /**\n             * The date format in the input boxes when they are selected for\n             * editing. This must be a format that is recognized by JavaScript\n             * Date.parse.\n             *\n             * This will only be used for inputs of type `text`. Since v8.2.3,\n             * the input type is dynamically determined based on the granularity\n             * of the `inputDateFormat` and the browser support.\n             *\n             * @sample {highstock} stock/rangeselector/input-format/\n             *         Milliseconds in the range selector\n             *\n             */\n            inputEditDateFormat: '%Y-%m-%d',\n            /**\n             * Enable or disable the date input boxes.\n             */\n            inputEnabled: true,\n            /**\n             * Positioning for the input boxes. Allowed properties are `align`,\n             *  `x` and `y`.\n             *\n             * @since 1.2.4\n             */\n            inputPosition: {\n                /**\n                 * The alignment of the input box. Allowed properties are `left`,\n                 * `center`, `right`.\n                 *\n                 * @sample {highstock} stock/rangeselector/input-button-position/\n                 *         Alignment\n                 *\n                 * @type  {Highcharts.AlignValue}\n                 * @since 6.0.0\n                 */\n                align: 'right',\n                /**\n                 * X offset of the input row.\n                 */\n                x: 0,\n                /**\n                 * Y offset of the input row.\n                 */\n                y: 0\n            },\n            /**\n             * The space in pixels between the labels and the date input boxes in\n             * the range selector.\n             *\n             * @since 9.0.0\n             */\n            inputSpacing: 5,\n            /**\n             * The index of the button to appear pre-selected. If the selected range\n             * exceeds the total data range and the 'all' option is available,\n             * the 'all' option, showing the full range, is automatically selected.\n             *\n             * @type      {number}\n             */\n            selected: void 0,\n            /**\n             * Positioning for the button row.\n             *\n             * @since 1.2.4\n             */\n            buttonPosition: {\n                /**\n                 * The alignment of the input box. Allowed properties are `left`,\n                 * `center`, `right`.\n                 *\n                 * @sample {highstock} stock/rangeselector/input-button-position/\n                 *         Alignment\n                 *\n                 * @type  {Highcharts.AlignValue}\n                 * @since 6.0.0\n                 */\n                align: 'left',\n                /**\n                 * X offset of the button row.\n                 */\n                x: 0,\n                /**\n                 * Y offset of the button row.\n                 */\n                y: 0\n            },\n            /**\n             * CSS for the HTML inputs in the range selector.\n             *\n             * In styled mode, the inputs are styled by the\n             * `.highcharts-range-input text` rule in SVG mode, and\n             * `input.highcharts-range-selector` when active.\n             *\n             * @sample {highstock} stock/rangeselector/styling/\n             *         Styling the buttons and inputs\n             *\n             * @type      {Highcharts.CSSObject}\n             * @apioption rangeSelector.inputStyle\n             */\n            inputStyle: {\n                /** @ignore */\n                color: \"#334eff\" /* Palette.highlightColor80 */,\n                /** @ignore */\n                cursor: 'pointer',\n                /** @ignore */\n                fontSize: '0.8em'\n            },\n            /**\n             * CSS styles for the labels - the Zoom, From and To texts.\n             *\n             * In styled mode, the labels are styled by the\n             * `.highcharts-range-label` class.\n             *\n             * @sample {highstock} stock/rangeselector/styling/\n             *         Styling the buttons and inputs\n             *\n             * @type {Highcharts.CSSObject}\n             */\n            labelStyle: {\n                /** @ignore */\n                color: \"#666666\" /* Palette.neutralColor60 */,\n                /** @ignore */\n                fontSize: '0.8em'\n            }\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const RangeSelectorDefaults = {\n            lang,\n            rangeSelector\n        };\n\n        return RangeSelectorDefaults;\n    });\n    _registerModule(_modules, 'Stock/RangeSelector/RangeSelectorComposition.js', [_modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Stock/RangeSelector/RangeSelectorDefaults.js'], _modules['Core/Utilities.js']], function (D, H, RangeSelectorDefaults, U) {\n        /* *\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { defaultOptions } = D;\n        const { composed } = H;\n        const { addEvent, defined, extend, find, isNumber, merge, pick, pushUnique } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const chartDestroyEvents = [];\n        /* *\n         *\n         *  Variables\n         *\n         * */\n        let RangeSelectorConstructor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get the axis min value based on the range option and the current max. For\n         * stock charts this is extended via the {@link RangeSelector} so that if the\n         * selected range is a multiple of months or years, it is compensated for\n         * various month lengths.\n         *\n         * @private\n         * @function Highcharts.Axis#minFromRange\n         * @return {number|undefined}\n         *         The new minimum value.\n         */\n        function axisMinFromRange() {\n            const rangeOptions = this.range, type = rangeOptions.type, max = this.max, time = this.chart.time, \n            // Get the true range from a start date\n            getTrueRange = function (base, count) {\n                const timeName = type === 'year' ?\n                    'FullYear' : 'Month';\n                const date = new time.Date(base);\n                const basePeriod = time.get(timeName, date);\n                time.set(timeName, date, basePeriod + count);\n                if (basePeriod === time.get(timeName, date)) {\n                    time.set('Date', date, 0); // #6537\n                }\n                return date.getTime() - base;\n            };\n            let min, range;\n            if (isNumber(rangeOptions)) {\n                min = max - rangeOptions;\n                range = rangeOptions;\n            }\n            else if (rangeOptions) {\n                min = max + getTrueRange(max, -(rangeOptions.count || 1));\n                // Let the fixedRange reflect initial settings (#5930)\n                if (this.chart) {\n                    this.chart.setFixedRange(max - min);\n                }\n            }\n            const dataMin = pick(this.dataMin, Number.MIN_VALUE);\n            if (!isNumber(min)) {\n                min = dataMin;\n            }\n            if (min <= dataMin) {\n                min = dataMin;\n                if (typeof range === 'undefined') { // #4501\n                    range = getTrueRange(min, rangeOptions.count);\n                }\n                this.newMax = Math.min(min + range, pick(this.dataMax, Number.MAX_VALUE));\n            }\n            if (!isNumber(max)) {\n                min = void 0;\n            }\n            else if (!isNumber(rangeOptions) &&\n                rangeOptions &&\n                rangeOptions._offsetMin) {\n                min += rangeOptions._offsetMin;\n            }\n            return min;\n        }\n        /**\n         * @private\n         */\n        function compose(AxisClass, ChartClass, RangeSelectorClass) {\n            RangeSelectorConstructor = RangeSelectorClass;\n            if (pushUnique(composed, 'RangeSelector')) {\n                const chartProto = ChartClass.prototype;\n                AxisClass.prototype.minFromRange = axisMinFromRange;\n                addEvent(ChartClass, 'afterGetContainer', onChartAfterGetContainer);\n                addEvent(ChartClass, 'beforeRender', onChartBeforeRender);\n                addEvent(ChartClass, 'destroy', onChartDestroy);\n                addEvent(ChartClass, 'getMargins', onChartGetMargins);\n                addEvent(ChartClass, 'render', onChartRender);\n                addEvent(ChartClass, 'update', onChartUpdate);\n                chartProto.callbacks.push(onChartCallback);\n                extend(defaultOptions, { rangeSelector: RangeSelectorDefaults.rangeSelector });\n                extend(defaultOptions.lang, RangeSelectorDefaults.lang);\n            }\n        }\n        /**\n         * Initialize rangeselector for stock charts\n         * @private\n         */\n        function onChartAfterGetContainer() {\n            if (this.options.rangeSelector &&\n                this.options.rangeSelector.enabled) {\n                this.rangeSelector = new RangeSelectorConstructor(this);\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartBeforeRender() {\n            const chart = this, axes = chart.axes, rangeSelector = chart.rangeSelector;\n            if (rangeSelector) {\n                if (isNumber(rangeSelector.deferredYTDClick)) {\n                    rangeSelector.clickButton(rangeSelector.deferredYTDClick);\n                    delete rangeSelector.deferredYTDClick;\n                }\n                axes.forEach((axis) => {\n                    axis.updateNames();\n                    axis.setScale();\n                });\n                chart.getAxisMargins();\n                rangeSelector.render();\n                const verticalAlign = rangeSelector.options.verticalAlign;\n                if (!rangeSelector.options.floating) {\n                    if (verticalAlign === 'bottom') {\n                        this.extraBottomMargin = true;\n                    }\n                    else if (verticalAlign !== 'middle') {\n                        this.extraTopMargin = true;\n                    }\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartCallback(chart) {\n            let extremes, legend, alignTo, verticalAlign;\n            const rangeSelector = chart.rangeSelector, redraw = () => {\n                if (rangeSelector) {\n                    extremes = chart.xAxis[0].getExtremes();\n                    legend = chart.legend;\n                    verticalAlign = (rangeSelector &&\n                        rangeSelector.options.verticalAlign);\n                    if (isNumber(extremes.min)) {\n                        rangeSelector.render(extremes.min, extremes.max);\n                    }\n                    // Re-align the legend so that it's below the rangeselector\n                    if (legend.display &&\n                        verticalAlign === 'top' &&\n                        verticalAlign === legend.options.verticalAlign) {\n                        // Create a new alignment box for the legend.\n                        alignTo = merge(chart.spacingBox);\n                        if (legend.options.layout === 'vertical') {\n                            alignTo.y = chart.plotTop;\n                        }\n                        else {\n                            alignTo.y += rangeSelector.getHeight();\n                        }\n                        legend.group.placed = false; // Don't animate the alignment.\n                        legend.align(alignTo);\n                    }\n                }\n            };\n            if (rangeSelector) {\n                const events = find(chartDestroyEvents, (e) => e[0] === chart);\n                if (!events) {\n                    chartDestroyEvents.push([chart, [\n                            // redraw the scroller on setExtremes\n                            addEvent(chart.xAxis[0], 'afterSetExtremes', function (e) {\n                                if (rangeSelector) {\n                                    rangeSelector.render(e.min, e.max);\n                                }\n                            }),\n                            // redraw the scroller chart resize\n                            addEvent(chart, 'redraw', redraw)\n                        ]]);\n                }\n                // do it now\n                redraw();\n            }\n        }\n        /**\n         * Remove resize/afterSetExtremes at chart destroy.\n         * @private\n         */\n        function onChartDestroy() {\n            for (let i = 0, iEnd = chartDestroyEvents.length; i < iEnd; ++i) {\n                const events = chartDestroyEvents[i];\n                if (events[0] === this) {\n                    events[1].forEach((unbind) => unbind());\n                    chartDestroyEvents.splice(i, 1);\n                    return;\n                }\n            }\n        }\n        function onChartGetMargins() {\n            const rangeSelector = this.rangeSelector;\n            if (rangeSelector) {\n                const rangeSelectorHeight = rangeSelector.getHeight();\n                if (this.extraTopMargin) {\n                    this.plotTop += rangeSelectorHeight;\n                }\n                if (this.extraBottomMargin) {\n                    this.marginBottom += rangeSelectorHeight;\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartRender() {\n            const chart = this, rangeSelector = chart.rangeSelector;\n            if (rangeSelector && !rangeSelector.options.floating) {\n                rangeSelector.render();\n                const verticalAlign = rangeSelector.options.verticalAlign;\n                if (verticalAlign === 'bottom') {\n                    this.extraBottomMargin = true;\n                }\n                else if (verticalAlign !== 'middle') {\n                    this.extraTopMargin = true;\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartUpdate(e) {\n            const chart = this, options = e.options, optionsRangeSelector = options.rangeSelector, extraBottomMarginWas = this.extraBottomMargin, extraTopMarginWas = this.extraTopMargin;\n            let rangeSelector = chart.rangeSelector;\n            if (optionsRangeSelector &&\n                optionsRangeSelector.enabled &&\n                !defined(rangeSelector) &&\n                this.options.rangeSelector) {\n                this.options.rangeSelector.enabled = true;\n                this.rangeSelector = rangeSelector = new RangeSelectorConstructor(this);\n            }\n            this.extraBottomMargin = false;\n            this.extraTopMargin = false;\n            if (rangeSelector) {\n                onChartCallback(this);\n                const verticalAlign = (optionsRangeSelector &&\n                    optionsRangeSelector.verticalAlign) || (rangeSelector.options && rangeSelector.options.verticalAlign);\n                if (!rangeSelector.options.floating) {\n                    if (verticalAlign === 'bottom') {\n                        this.extraBottomMargin = true;\n                    }\n                    else if (verticalAlign !== 'middle') {\n                        this.extraTopMargin = true;\n                    }\n                }\n                if (this.extraBottomMargin !== extraBottomMarginWas ||\n                    this.extraTopMargin !== extraTopMarginWas) {\n                    this.isDirtyBox = true;\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const RangeSelectorComposition = {\n            compose\n        };\n\n        return RangeSelectorComposition;\n    });\n    _registerModule(_modules, 'Stock/RangeSelector/RangeSelector.js', [_modules['Core/Axis/Axis.js'], _modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Stock/RangeSelector/RangeSelectorComposition.js'], _modules['Core/Renderer/SVG/SVGElement.js'], _modules['Core/Utilities.js']], function (Axis, D, H, RangeSelectorComposition, SVGElement, U) {\n        /* *\n         *\n         *  (c) 2010-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { defaultOptions } = D;\n        const { addEvent, createElement, css, defined, destroyObjectProperties, discardElement, extend, fireEvent, isNumber, merge, objectEach, pad, pick, pInt, splat } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get the preferred input type based on a date format string.\n         *\n         * @private\n         * @function preferredInputType\n         */\n        function preferredInputType(format) {\n            const ms = format.indexOf('%L') !== -1;\n            if (ms) {\n                return 'text';\n            }\n            const date = ['a', 'A', 'd', 'e', 'w', 'b', 'B', 'm', 'o', 'y', 'Y']\n                .some((char) => format.indexOf('%' + char) !== -1);\n            const time = ['H', 'k', 'I', 'l', 'M', 'S']\n                .some((char) => format.indexOf('%' + char) !== -1);\n            if (date && time) {\n                return 'datetime-local';\n            }\n            if (date) {\n                return 'date';\n            }\n            if (time) {\n                return 'time';\n            }\n            return 'text';\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The range selector.\n         *\n         * @private\n         * @class\n         * @name Highcharts.RangeSelector\n         * @param {Highcharts.Chart} chart\n         */\n        class RangeSelector {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            static compose(AxisClass, ChartClass) {\n                RangeSelectorComposition.compose(AxisClass, ChartClass, RangeSelector);\n            }\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart) {\n                this.buttonOptions = RangeSelector.prototype.defaultButtons;\n                this.initialButtonGroupWidth = 0;\n                this.chart = chart;\n                this.init(chart);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * The method to run when one of the buttons in the range selectors is\n             * clicked\n             *\n             * @private\n             * @function Highcharts.RangeSelector#clickButton\n             * @param {number} i\n             *        The index of the button\n             * @param {boolean} [redraw]\n             */\n            clickButton(i, redraw) {\n                const rangeSelector = this, chart = rangeSelector.chart, rangeOptions = rangeSelector.buttonOptions[i], baseAxis = chart.xAxis[0], unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || baseAxis || {}, type = rangeOptions.type, dataGrouping = rangeOptions.dataGrouping;\n                let dataMin = unionExtremes.dataMin, dataMax = unionExtremes.dataMax, newMin, newMax = baseAxis && Math.round(Math.min(baseAxis.max, pick(dataMax, baseAxis.max))), // #1568\n                baseXAxisOptions, range = rangeOptions._range, rangeMin, minSetting, rangeSetting, ctx, ytdExtremes, addOffsetMin = true;\n                // chart has no data, base series is removed\n                if (dataMin === null || dataMax === null) {\n                    return;\n                }\n                rangeSelector.setSelected(i);\n                // Apply dataGrouping associated to button\n                if (dataGrouping) {\n                    this.forcedDataGrouping = true;\n                    Axis.prototype.setDataGrouping.call(baseAxis || { chart: this.chart }, dataGrouping, false);\n                    this.frozenStates = rangeOptions.preserveDataGrouping;\n                }\n                // Apply range\n                if (type === 'month' || type === 'year') {\n                    if (!baseAxis) {\n                        // This is set to the user options and picked up later when the\n                        // axis is instantiated so that we know the min and max.\n                        range = rangeOptions;\n                    }\n                    else {\n                        ctx = {\n                            range: rangeOptions,\n                            max: newMax,\n                            chart: chart,\n                            dataMin: dataMin,\n                            dataMax: dataMax\n                        };\n                        newMin = baseAxis.minFromRange.call(ctx);\n                        if (isNumber(ctx.newMax)) {\n                            newMax = ctx.newMax;\n                        }\n                        // #15799: offsetMin is added in minFromRange so that it works\n                        // with pre-selected buttons as well\n                        addOffsetMin = false;\n                    }\n                    // Fixed times like minutes, hours, days\n                }\n                else if (range) {\n                    newMin = Math.max(newMax - range, dataMin);\n                    newMax = Math.min(newMin + range, dataMax);\n                    addOffsetMin = false;\n                }\n                else if (type === 'ytd') {\n                    // On user clicks on the buttons, or a delayed action running from\n                    // the beforeRender event (below), the baseAxis is defined.\n                    if (baseAxis) {\n                        // When \"ytd\" is the pre-selected button for the initial view,\n                        // its calculation is delayed and rerun in the beforeRender\n                        // event (below). When the series are initialized, but before\n                        // the chart is rendered, we have access to the xData array\n                        // (#942).\n                        if (typeof dataMax === 'undefined' ||\n                            typeof dataMin === 'undefined') {\n                            dataMin = Number.MAX_VALUE;\n                            dataMax = Number.MIN_VALUE;\n                            chart.series.forEach((series) => {\n                                // reassign it to the last item\n                                const xData = series.xData;\n                                if (xData) {\n                                    dataMin = Math.min(xData[0], dataMin);\n                                    dataMax = Math.max(xData[xData.length - 1], dataMax);\n                                }\n                            });\n                            redraw = false;\n                        }\n                        ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, chart.time.useUTC);\n                        newMin = rangeMin = ytdExtremes.min;\n                        newMax = ytdExtremes.max;\n                        // \"ytd\" is pre-selected. We don't yet have access to processed\n                        // point and extremes data (things like pointStart and pointInterval\n                        // are missing), so we delay the process (#942)\n                    }\n                    else {\n                        rangeSelector.deferredYTDClick = i;\n                        return;\n                    }\n                }\n                else if (type === 'all' && baseAxis) {\n                    // If the navigator exist and the axis range is declared reset that\n                    // range and from now on only use the range set by a user, #14742.\n                    if (chart.navigator && chart.navigator.baseSeries[0]) {\n                        chart.navigator.baseSeries[0].xAxis.options.range = void 0;\n                    }\n                    newMin = dataMin;\n                    newMax = dataMax;\n                }\n                if (addOffsetMin && rangeOptions._offsetMin && defined(newMin)) {\n                    newMin += rangeOptions._offsetMin;\n                }\n                if (rangeOptions._offsetMax && defined(newMax)) {\n                    newMax += rangeOptions._offsetMax;\n                }\n                if (this.dropdown) {\n                    this.dropdown.selectedIndex = i + 1;\n                }\n                // Update the chart\n                if (!baseAxis) {\n                    // Axis not yet instantiated. Temporarily set min and range\n                    // options and remove them on chart load (#4317).\n                    baseXAxisOptions = splat(chart.options.xAxis)[0];\n                    rangeSetting = baseXAxisOptions.range;\n                    baseXAxisOptions.range = range;\n                    minSetting = baseXAxisOptions.min;\n                    baseXAxisOptions.min = rangeMin;\n                    addEvent(chart, 'load', function resetMinAndRange() {\n                        chart.setFixedRange(rangeOptions._range);\n                        baseXAxisOptions.range = rangeSetting;\n                        baseXAxisOptions.min = minSetting;\n                    });\n                }\n                else {\n                    // Existing axis object. Set extremes after render time.\n                    baseAxis.setExtremes(newMin, newMax, pick(redraw, true), void 0, // auto animation\n                    {\n                        trigger: 'rangeSelectorButton',\n                        rangeSelectorButton: rangeOptions\n                    });\n                    chart.setFixedRange(rangeOptions._range);\n                }\n                fireEvent(this, 'afterBtnClick');\n            }\n            /**\n             * Set the selected option. This method only sets the internal flag, it\n             * doesn't update the buttons or the actual zoomed range.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#setSelected\n             * @param {number} [selected]\n             */\n            setSelected(selected) {\n                this.selected = this.options.selected = selected;\n            }\n            /**\n             * Initialize the range selector\n             *\n             * @private\n             * @function Highcharts.RangeSelector#init\n             * @param {Highcharts.Chart} chart\n             */\n            init(chart) {\n                const rangeSelector = this, options = chart.options.rangeSelector, buttonOptions = (options.buttons || rangeSelector.defaultButtons.slice()), selectedOption = options.selected, blurInputs = function () {\n                    const minInput = rangeSelector.minInput, maxInput = rangeSelector.maxInput;\n                    // #3274 in some case blur is not defined\n                    if (minInput && !!minInput.blur) {\n                        fireEvent(minInput, 'blur');\n                    }\n                    if (maxInput && !!maxInput.blur) {\n                        fireEvent(maxInput, 'blur');\n                    }\n                };\n                rangeSelector.chart = chart;\n                rangeSelector.options = options;\n                rangeSelector.buttons = [];\n                rangeSelector.buttonOptions = buttonOptions;\n                this.eventsToUnbind = [];\n                this.eventsToUnbind.push(addEvent(chart.container, 'mousedown', blurInputs));\n                this.eventsToUnbind.push(addEvent(chart, 'resize', blurInputs));\n                // Extend the buttonOptions with actual range\n                buttonOptions.forEach(rangeSelector.computeButtonRange);\n                // Zoomed range based on a pre-selected button index\n                if (typeof selectedOption !== 'undefined' &&\n                    buttonOptions[selectedOption]) {\n                    this.clickButton(selectedOption, false);\n                }\n                this.eventsToUnbind.push(addEvent(chart, 'load', function () {\n                    // If a data grouping is applied to the current button, release it\n                    // when extremes change\n                    if (chart.xAxis && chart.xAxis[0]) {\n                        addEvent(chart.xAxis[0], 'setExtremes', function (e) {\n                            if (isNumber(this.max) &&\n                                isNumber(this.min) &&\n                                this.max - this.min !== chart.fixedRange &&\n                                e.trigger !== 'rangeSelectorButton' &&\n                                e.trigger !== 'updatedData' &&\n                                rangeSelector.forcedDataGrouping &&\n                                !rangeSelector.frozenStates) {\n                                this.setDataGrouping(false, false);\n                            }\n                        });\n                    }\n                }));\n            }\n            /**\n             * Dynamically update the range selector buttons after a new range has been\n             * set\n             *\n             * @private\n             * @function Highcharts.RangeSelector#updateButtonStates\n             */\n            updateButtonStates() {\n                const rangeSelector = this, chart = this.chart, dropdown = this.dropdown, baseAxis = chart.xAxis[0], actualRange = Math.round(baseAxis.max - baseAxis.min), hasNoData = !baseAxis.hasVisibleSeries, day = 24 * 36e5, // A single day in milliseconds\n                unionExtremes = (chart.scroller &&\n                    chart.scroller.getUnionExtremes()) || baseAxis, dataMin = unionExtremes.dataMin, dataMax = unionExtremes.dataMax, ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, chart.time.useUTC), ytdMin = ytdExtremes.min, ytdMax = ytdExtremes.max, selected = rangeSelector.selected, allButtonsEnabled = rangeSelector.options.allButtonsEnabled, buttons = rangeSelector.buttons;\n                let selectedExists = isNumber(selected), isSelectedTooGreat = false;\n                rangeSelector.buttonOptions.forEach((rangeOptions, i) => {\n                    const range = rangeOptions._range, type = rangeOptions.type, count = rangeOptions.count || 1, button = buttons[i], offsetRange = rangeOptions._offsetMax -\n                        rangeOptions._offsetMin, isSelected = i === selected, \n                    // Disable buttons where the range exceeds what is allowed in\n                    // the current view\n                    isTooGreatRange = range >\n                        dataMax - dataMin, \n                    // Disable buttons where the range is smaller than the minimum\n                    // range\n                    isTooSmallRange = range < baseAxis.minRange;\n                    let state = 0, \n                    // Do not select the YTD button if not explicitly told so\n                    isYTDButNotSelected = false, \n                    // Disable the All button if we're already showing all\n                    isAllButAlreadyShowingAll = false, isSameRange = range === actualRange;\n                    if (isSelected && isTooGreatRange) {\n                        isSelectedTooGreat = true;\n                    }\n                    if (baseAxis.isOrdinal &&\n                        baseAxis.ordinal?.positions &&\n                        range &&\n                        actualRange < range) {\n                        // Handle ordinal ranges\n                        const positions = baseAxis.ordinal.positions;\n                        if (positions[positions.length - 1] - positions[0] > range) {\n                            isSameRange = true;\n                        }\n                    }\n                    else if (\n                    // Months and years have variable range so we check the extremes\n                    (type === 'month' || type === 'year') &&\n                        (actualRange + 36e5 >=\n                            { month: 28, year: 365 }[type] * day * count - offsetRange) &&\n                        (actualRange - 36e5 <=\n                            { month: 31, year: 366 }[type] * day * count + offsetRange)) {\n                        isSameRange = true;\n                    }\n                    else if (type === 'ytd') {\n                        isSameRange = (ytdMax - ytdMin + offsetRange) === actualRange;\n                        isYTDButNotSelected = !isSelected;\n                    }\n                    else if (type === 'all') {\n                        isSameRange = (baseAxis.max - baseAxis.min >=\n                            dataMax - dataMin);\n                        isAllButAlreadyShowingAll = (!isSelected &&\n                            selectedExists &&\n                            isSameRange);\n                    }\n                    // The new zoom area happens to match the range for a button - mark\n                    // it selected. This happens when scrolling across an ordinal gap.\n                    // It can be seen in the intraday demos when selecting 1h and scroll\n                    // across the night gap.\n                    const disable = (!allButtonsEnabled &&\n                        !(isSelectedTooGreat && type === 'all') &&\n                        (isTooGreatRange ||\n                            isTooSmallRange ||\n                            isAllButAlreadyShowingAll ||\n                            hasNoData));\n                    const select = ((isSelectedTooGreat && type === 'all') ||\n                        (isSelected && isSameRange) ||\n                        (isSameRange && !selectedExists && !isYTDButNotSelected) ||\n                        (isSelected && rangeSelector.frozenStates));\n                    if (disable) {\n                        state = 3;\n                    }\n                    else if (select) {\n                        selectedExists = true; // Only one button can be selected\n                        state = 2;\n                    }\n                    // If state has changed, update the button\n                    if (button.state !== state) {\n                        button.setState(state);\n                        if (dropdown) {\n                            dropdown.options[i + 1].disabled = disable;\n                            if (state === 2) {\n                                dropdown.selectedIndex = i + 1;\n                            }\n                        }\n                        // Reset (#9209)\n                        if (state === 0 && selected === i) {\n                            rangeSelector.setSelected();\n                        }\n                        else if ((state === 2 && !defined(selected)) ||\n                            isSelectedTooGreat) {\n                            rangeSelector.setSelected(i);\n                        }\n                    }\n                });\n            }\n            /**\n             * Compute and cache the range for an individual button\n             *\n             * @private\n             * @function Highcharts.RangeSelector#computeButtonRange\n             * @param {Highcharts.RangeSelectorButtonsOptions} rangeOptions\n             */\n            computeButtonRange(rangeOptions) {\n                const type = rangeOptions.type, count = rangeOptions.count || 1, \n                // these time intervals have a fixed number of milliseconds, as\n                // opposed to month, ytd and year\n                fixedTimes = {\n                    millisecond: 1,\n                    second: 1000,\n                    minute: 60 * 1000,\n                    hour: 3600 * 1000,\n                    day: 24 * 3600 * 1000,\n                    week: 7 * 24 * 3600 * 1000\n                };\n                // Store the range on the button object\n                if (fixedTimes[type]) {\n                    rangeOptions._range = fixedTimes[type] * count;\n                }\n                else if (type === 'month' || type === 'year') {\n                    rangeOptions._range = {\n                        month: 30,\n                        year: 365\n                    }[type] * 24 * 36e5 * count;\n                }\n                rangeOptions._offsetMin = pick(rangeOptions.offsetMin, 0);\n                rangeOptions._offsetMax = pick(rangeOptions.offsetMax, 0);\n                rangeOptions._range +=\n                    rangeOptions._offsetMax - rangeOptions._offsetMin;\n            }\n            /**\n             * Get the unix timestamp of a HTML input for the dates\n             *\n             * @private\n             * @function Highcharts.RangeSelector#getInputValue\n             */\n            getInputValue(name) {\n                const input = name === 'min' ? this.minInput : this.maxInput;\n                const options = this.chart.options\n                    .rangeSelector;\n                const time = this.chart.time;\n                if (input) {\n                    return ((input.type === 'text' && options.inputDateParser) ||\n                        this.defaultInputDateParser)(input.value, time.useUTC, time);\n                }\n                return 0;\n            }\n            /**\n             * Set the internal and displayed value of a HTML input for the dates\n             *\n             * @private\n             * @function Highcharts.RangeSelector#setInputValue\n             */\n            setInputValue(name, inputTime) {\n                const options = this.options, time = this.chart.time, input = name === 'min' ? this.minInput : this.maxInput, dateBox = name === 'min' ? this.minDateBox : this.maxDateBox;\n                if (input) {\n                    const hcTimeAttr = input.getAttribute('data-hc-time');\n                    let updatedTime = defined(hcTimeAttr) ? Number(hcTimeAttr) : void 0;\n                    if (defined(inputTime)) {\n                        const previousTime = updatedTime;\n                        if (defined(previousTime)) {\n                            input.setAttribute('data-hc-time-previous', previousTime);\n                        }\n                        input.setAttribute('data-hc-time', inputTime);\n                        updatedTime = inputTime;\n                    }\n                    input.value = time.dateFormat((this.inputTypeFormats[input.type] ||\n                        options.inputEditDateFormat), updatedTime);\n                    if (dateBox) {\n                        dateBox.attr({\n                            text: time.dateFormat(options.inputDateFormat, updatedTime)\n                        });\n                    }\n                }\n            }\n            /**\n             * Set the min and max value of a HTML input for the dates\n             *\n             * @private\n             * @function Highcharts.RangeSelector#setInputExtremes\n             */\n            setInputExtremes(name, min, max) {\n                const input = name === 'min' ? this.minInput : this.maxInput;\n                if (input) {\n                    const format = this.inputTypeFormats[input.type];\n                    const time = this.chart.time;\n                    if (format) {\n                        const newMin = time.dateFormat(format, min);\n                        if (input.min !== newMin) {\n                            input.min = newMin;\n                        }\n                        const newMax = time.dateFormat(format, max);\n                        if (input.max !== newMax) {\n                            input.max = newMax;\n                        }\n                    }\n                }\n            }\n            /**\n             * @private\n             * @function Highcharts.RangeSelector#showInput\n             * @param {string} name\n             */\n            showInput(name) {\n                const dateBox = name === 'min' ? this.minDateBox : this.maxDateBox, input = name === 'min' ? this.minInput : this.maxInput;\n                if (input && dateBox && this.inputGroup) {\n                    const isTextInput = input.type === 'text', { translateX = 0, translateY = 0 } = this.inputGroup, { x = 0, width = 0, height = 0 } = dateBox, { inputBoxWidth } = this.options;\n                    css(input, {\n                        width: isTextInput ?\n                            ((width + (inputBoxWidth ? -2 : 20)) + 'px') :\n                            'auto',\n                        height: (height - 2) + 'px',\n                        border: '2px solid silver'\n                    });\n                    if (isTextInput && inputBoxWidth) {\n                        css(input, {\n                            left: (translateX + x) + 'px',\n                            top: translateY + 'px'\n                        });\n                        // Inputs of types date, time or datetime-local should be centered\n                        // on top of the dateBox\n                    }\n                    else {\n                        css(input, {\n                            left: Math.min(Math.round(x +\n                                translateX -\n                                (input.offsetWidth - width) / 2), this.chart.chartWidth - input.offsetWidth) + 'px',\n                            top: (translateY - (input.offsetHeight - height) / 2) + 'px'\n                        });\n                    }\n                }\n            }\n            /**\n             * @private\n             * @function Highcharts.RangeSelector#hideInput\n             * @param {string} name\n             */\n            hideInput(name) {\n                const input = name === 'min' ? this.minInput : this.maxInput;\n                if (input) {\n                    css(input, {\n                        top: '-9999em',\n                        border: 0,\n                        width: '1px',\n                        height: '1px'\n                    });\n                }\n            }\n            /**\n             * @private\n             * @function Highcharts.RangeSelector#defaultInputDateParser\n             */\n            defaultInputDateParser(inputDate, useUTC, time) {\n                const hasTimezone = (str) => str.length > 6 &&\n                    (str.lastIndexOf('-') === str.length - 6 ||\n                        str.lastIndexOf('+') === str.length - 6);\n                let input = inputDate.split('/').join('-').split(' ').join('T');\n                if (input.indexOf('T') === -1) {\n                    input += 'T00:00';\n                }\n                if (useUTC) {\n                    input += 'Z';\n                }\n                else if (H.isSafari && !hasTimezone(input)) {\n                    const offset = new Date(input).getTimezoneOffset() / 60;\n                    input += offset <= 0 ? `+${pad(-offset)}:00` : `-${pad(offset)}:00`;\n                }\n                let date = Date.parse(input);\n                // If the value isn't parsed directly to a value by the\n                // browser's Date.parse method, try\n                // parsing it a different way\n                if (!isNumber(date)) {\n                    const parts = inputDate.split('-');\n                    date = Date.UTC(pInt(parts[0]), pInt(parts[1]) - 1, pInt(parts[2]));\n                }\n                if (time && useUTC && isNumber(date)) {\n                    date += time.getTimezoneOffset(date);\n                }\n                return date;\n            }\n            /**\n             * Draw either the 'from' or the 'to' HTML input box of the range selector\n             *\n             * @private\n             * @function Highcharts.RangeSelector#drawInput\n             */\n            drawInput(name) {\n                const { chart, div, inputGroup } = this;\n                const rangeSelector = this, chartStyle = chart.renderer.style || {}, renderer = chart.renderer, options = chart.options.rangeSelector, lang = defaultOptions.lang, isMin = name === 'min';\n                /**\n                 * @private\n                 */\n                function updateExtremes() {\n                    const { maxInput, minInput } = rangeSelector, chartAxis = chart.xAxis[0], unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || chartAxis, dataMin = unionExtremes.dataMin, dataMax = unionExtremes.dataMax;\n                    let value = rangeSelector.getInputValue(name);\n                    if (value !== Number(input.getAttribute('data-hc-time-previous')) &&\n                        isNumber(value)) {\n                        input.setAttribute('data-hc-time-previous', value);\n                        // Validate the extremes. If it goes beyond the data min or\n                        // max, use the actual data extreme (#2438).\n                        if (isMin && maxInput && isNumber(dataMin)) {\n                            if (value > Number(maxInput.getAttribute('data-hc-time'))) {\n                                value = void 0;\n                            }\n                            else if (value < dataMin) {\n                                value = dataMin;\n                            }\n                        }\n                        else if (minInput && isNumber(dataMax)) {\n                            if (value < Number(minInput.getAttribute('data-hc-time'))) {\n                                value = void 0;\n                            }\n                            else if (value > dataMax) {\n                                value = dataMax;\n                            }\n                        }\n                        // Set the extremes\n                        if (typeof value !== 'undefined') { // @todo typeof undefined\n                            chartAxis.setExtremes(isMin ? value : chartAxis.min, isMin ? chartAxis.max : value, void 0, void 0, { trigger: 'rangeSelectorInput' });\n                        }\n                    }\n                }\n                // Create the text label\n                const text = lang[isMin ? 'rangeSelectorFrom' : 'rangeSelectorTo'] || '';\n                const label = renderer\n                    .label(text, 0)\n                    .addClass('highcharts-range-label')\n                    .attr({\n                    padding: text ? 2 : 0,\n                    height: text ? options.inputBoxHeight : 0\n                })\n                    .add(inputGroup);\n                // Create an SVG label that shows updated date ranges and records click\n                // events that bring in the HTML input.\n                const dateBox = renderer\n                    .label('', 0)\n                    .addClass('highcharts-range-input')\n                    .attr({\n                    padding: 2,\n                    width: options.inputBoxWidth,\n                    height: options.inputBoxHeight,\n                    'text-align': 'center'\n                })\n                    .on('click', function () {\n                    // If it is already focused, the onfocus event doesn't fire\n                    // (#3713)\n                    rangeSelector.showInput(name);\n                    rangeSelector[name + 'Input'].focus();\n                });\n                if (!chart.styledMode) {\n                    dateBox.attr({\n                        stroke: options.inputBoxBorderColor,\n                        'stroke-width': 1\n                    });\n                }\n                dateBox.add(inputGroup);\n                // Create the HTML input element. This is rendered as 1x1 pixel then set\n                // to the right size when focused.\n                const input = createElement('input', {\n                    name: name,\n                    className: 'highcharts-range-selector'\n                }, void 0, div);\n                // #14788: Setting input.type to an unsupported type throws in IE, so\n                // we need to use setAttribute instead\n                input.setAttribute('type', preferredInputType(options.inputDateFormat || '%e %b %Y'));\n                if (!chart.styledMode) {\n                    // Styles\n                    label.css(merge(chartStyle, options.labelStyle));\n                    dateBox.css(merge({\n                        color: \"#333333\" /* Palette.neutralColor80 */\n                    }, chartStyle, options.inputStyle));\n                    css(input, extend({\n                        position: 'absolute',\n                        border: 0,\n                        boxShadow: '0 0 15px rgba(0,0,0,0.3)',\n                        width: '1px',\n                        height: '1px',\n                        padding: 0,\n                        textAlign: 'center',\n                        fontSize: chartStyle.fontSize,\n                        fontFamily: chartStyle.fontFamily,\n                        top: '-9999em' // #4798\n                    }, options.inputStyle));\n                }\n                // Blow up the input box\n                input.onfocus = () => {\n                    rangeSelector.showInput(name);\n                };\n                // Hide away the input box\n                input.onblur = () => {\n                    // update extremes only when inputs are active\n                    if (input === H.doc.activeElement) { // Only when focused\n                        // Update also when no `change` event is triggered, like when\n                        // clicking inside the SVG (#4710)\n                        updateExtremes();\n                    }\n                    // #10404 - move hide and blur outside focus\n                    rangeSelector.hideInput(name);\n                    rangeSelector.setInputValue(name);\n                    input.blur(); // #4606\n                };\n                let keyDown = false;\n                // handle changes in the input boxes\n                input.onchange = () => {\n                    // Update extremes and blur input when clicking date input calendar\n                    if (!keyDown) {\n                        updateExtremes();\n                        rangeSelector.hideInput(name);\n                        input.blur();\n                    }\n                };\n                input.onkeypress = (event) => {\n                    // IE does not fire onchange on enter\n                    if (event.keyCode === 13) {\n                        updateExtremes();\n                    }\n                };\n                input.onkeydown = (event) => {\n                    keyDown = true;\n                    // Arrow keys\n                    if (event.keyCode === 38 || event.keyCode === 40) {\n                        updateExtremes();\n                    }\n                };\n                input.onkeyup = () => {\n                    keyDown = false;\n                };\n                return { dateBox, input, label };\n            }\n            /**\n             * Get the position of the range selector buttons and inputs. This can be\n             * overridden from outside for custom positioning.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#getPosition\n             */\n            getPosition() {\n                const chart = this.chart, options = chart.options.rangeSelector, top = options.verticalAlign === 'top' ?\n                    chart.plotTop - chart.axisOffset[0] :\n                    0; // set offset only for verticalAlign top\n                return {\n                    buttonTop: top + options.buttonPosition.y,\n                    inputTop: top + options.inputPosition.y - 10\n                };\n            }\n            /**\n             * Get the extremes of YTD. Will choose dataMax if its value is lower than\n             * the current timestamp. Will choose dataMin if its value is higher than\n             * the timestamp for the start of current year.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#getYTDExtremes\n             * @return {*}\n             * Returns min and max for the YTD\n             */\n            getYTDExtremes(dataMax, dataMin, useUTC) {\n                const time = this.chart.time, now = new time.Date(dataMax), year = time.get('FullYear', now), startOfYear = useUTC ?\n                    time.Date.UTC(year, 0, 1) : // eslint-disable-line new-cap\n                    +new time.Date(year, 0, 1), min = Math.max(dataMin, startOfYear), ts = now.getTime();\n                return {\n                    max: Math.min(dataMax || ts, ts),\n                    min\n                };\n            }\n            /**\n             * Render the range selector including the buttons and the inputs. The first\n             * time render is called, the elements are created and positioned. On\n             * subsequent calls, they are moved and updated.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#render\n             * @param {number} [min]\n             *        X axis minimum\n             * @param {number} [max]\n             *        X axis maximum\n             */\n            render(min, max) {\n                const chart = this.chart, renderer = chart.renderer, container = chart.container, chartOptions = chart.options, options = chartOptions.rangeSelector, \n                // Place inputs above the container\n                inputsZIndex = pick(chartOptions.chart.style &&\n                    chartOptions.chart.style.zIndex, 0) + 1, inputEnabled = options.inputEnabled, rendered = this.rendered;\n                if (options.enabled === false) {\n                    return;\n                }\n                // create the elements\n                if (!rendered) {\n                    this.group = renderer.g('range-selector-group')\n                        .attr({\n                        zIndex: 7\n                    })\n                        .add();\n                    this.div = createElement('div', void 0, {\n                        position: 'relative',\n                        height: 0,\n                        zIndex: inputsZIndex\n                    });\n                    if (this.buttonOptions.length) {\n                        this.renderButtons();\n                    }\n                    // First create a wrapper outside the container in order to make\n                    // the inputs work and make export correct\n                    if (container.parentNode) {\n                        container.parentNode.insertBefore(this.div, container);\n                    }\n                    if (inputEnabled) {\n                        // Create the group to keep the inputs\n                        this.inputGroup = renderer.g('input-group').add(this.group);\n                        const minElems = this.drawInput('min');\n                        this.minDateBox = minElems.dateBox;\n                        this.minLabel = minElems.label;\n                        this.minInput = minElems.input;\n                        const maxElems = this.drawInput('max');\n                        this.maxDateBox = maxElems.dateBox;\n                        this.maxLabel = maxElems.label;\n                        this.maxInput = maxElems.input;\n                    }\n                }\n                if (inputEnabled) {\n                    // Set or reset the input values\n                    this.setInputValue('min', min);\n                    this.setInputValue('max', max);\n                    const unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || chart.xAxis[0] || {};\n                    if (defined(unionExtremes.dataMin) &&\n                        defined(unionExtremes.dataMax)) {\n                        const minRange = chart.xAxis[0].minRange || 0;\n                        this.setInputExtremes('min', unionExtremes.dataMin, Math.min(unionExtremes.dataMax, this.getInputValue('max')) - minRange);\n                        this.setInputExtremes('max', Math.max(unionExtremes.dataMin, this.getInputValue('min')) + minRange, unionExtremes.dataMax);\n                    }\n                    // Reflow\n                    if (this.inputGroup) {\n                        let x = 0;\n                        [\n                            this.minLabel,\n                            this.minDateBox,\n                            this.maxLabel,\n                            this.maxDateBox\n                        ].forEach((label) => {\n                            if (label) {\n                                const { width } = label.getBBox();\n                                if (width) {\n                                    label.attr({ x });\n                                    x += width + options.inputSpacing;\n                                }\n                            }\n                        });\n                    }\n                }\n                this.alignElements();\n                this.rendered = true;\n            }\n            /**\n             * Render the range buttons. This only runs the first time, later the\n             * positioning is laid out in alignElements.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#renderButtons\n             */\n            renderButtons() {\n                const { buttons, chart, options } = this;\n                const lang = defaultOptions.lang;\n                const renderer = chart.renderer;\n                const buttonTheme = merge(options.buttonTheme);\n                const states = buttonTheme && buttonTheme.states;\n                // Prevent the button from resetting the width when the button state\n                // changes since we need more control over the width when collapsing\n                // the buttons\n                const width = buttonTheme.width || 28;\n                delete buttonTheme.width;\n                delete buttonTheme.states;\n                this.buttonGroup = renderer.g('range-selector-buttons').add(this.group);\n                const dropdown = this.dropdown = createElement('select', void 0, {\n                    position: 'absolute',\n                    width: '1px',\n                    height: '1px',\n                    padding: 0,\n                    border: 0,\n                    top: '-9999em',\n                    cursor: 'pointer',\n                    opacity: 0.0001\n                }, this.div);\n                // Prevent page zoom on iPhone\n                addEvent(dropdown, 'touchstart', () => {\n                    dropdown.style.fontSize = '16px';\n                });\n                // Forward events from select to button\n                [\n                    [H.isMS ? 'mouseover' : 'mouseenter'],\n                    [H.isMS ? 'mouseout' : 'mouseleave'],\n                    ['change', 'click']\n                ].forEach(([from, to]) => {\n                    addEvent(dropdown, from, () => {\n                        const button = buttons[this.currentButtonIndex()];\n                        if (button) {\n                            fireEvent(button.element, to || from);\n                        }\n                    });\n                });\n                this.zoomText = renderer\n                    .label((lang && lang.rangeSelectorZoom) || '', 0)\n                    .attr({\n                    padding: options.buttonTheme.padding,\n                    height: options.buttonTheme.height,\n                    paddingLeft: 0,\n                    paddingRight: 0\n                })\n                    .add(this.buttonGroup);\n                if (!this.chart.styledMode) {\n                    this.zoomText.css(options.labelStyle);\n                    buttonTheme['stroke-width'] = pick(buttonTheme['stroke-width'], 0);\n                }\n                createElement('option', {\n                    textContent: this.zoomText.textStr,\n                    disabled: true\n                }, void 0, dropdown);\n                this.buttonOptions.forEach((rangeOptions, i) => {\n                    createElement('option', {\n                        textContent: rangeOptions.title || rangeOptions.text\n                    }, void 0, dropdown);\n                    buttons[i] = renderer\n                        .button(rangeOptions.text, 0, 0, (e) => {\n                        // extract events from button object and call\n                        const buttonEvents = (rangeOptions.events && rangeOptions.events.click);\n                        let callDefaultEvent;\n                        if (buttonEvents) {\n                            callDefaultEvent =\n                                buttonEvents.call(rangeOptions, e);\n                        }\n                        if (callDefaultEvent !== false) {\n                            this.clickButton(i);\n                        }\n                        this.isActive = true;\n                    }, buttonTheme, states && states.hover, states && states.select, states && states.disabled)\n                        .attr({\n                        'text-align': 'center',\n                        width\n                    })\n                        .add(this.buttonGroup);\n                    if (rangeOptions.title) {\n                        buttons[i].attr('title', rangeOptions.title);\n                    }\n                });\n            }\n            /**\n             * Align the elements horizontally and vertically.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#alignElements\n             */\n            alignElements() {\n                const { buttonGroup, buttons, chart, group, inputGroup, options, zoomText } = this;\n                const chartOptions = chart.options;\n                const navButtonOptions = (chartOptions.exporting &&\n                    chartOptions.exporting.enabled !== false &&\n                    chartOptions.navigation &&\n                    chartOptions.navigation.buttonOptions);\n                const { buttonPosition, inputPosition, verticalAlign } = options;\n                // Get the X offset required to avoid overlapping with the exporting\n                // button. This is used both by the buttonGroup and the inputGroup.\n                const getXOffsetForExportButton = (group, position) => {\n                    if (navButtonOptions &&\n                        this.titleCollision(chart) &&\n                        verticalAlign === 'top' &&\n                        position.align === 'right' && ((position.y -\n                        group.getBBox().height - 12) <\n                        ((navButtonOptions.y || 0) +\n                            (navButtonOptions.height || 0) +\n                            chart.spacing[0]))) {\n                        return -40;\n                    }\n                    return 0;\n                };\n                let plotLeft = chart.plotLeft;\n                if (group && buttonPosition && inputPosition) {\n                    let translateX = buttonPosition.x - chart.spacing[3];\n                    if (buttonGroup) {\n                        this.positionButtons();\n                        if (!this.initialButtonGroupWidth) {\n                            let width = 0;\n                            if (zoomText) {\n                                width += zoomText.getBBox().width + 5;\n                            }\n                            buttons.forEach((button, i) => {\n                                width += button.width || 0;\n                                if (i !== buttons.length - 1) {\n                                    width += options.buttonSpacing;\n                                }\n                            });\n                            this.initialButtonGroupWidth = width;\n                        }\n                        plotLeft -= chart.spacing[3];\n                        this.updateButtonStates();\n                        // Detect collision between button group and exporting\n                        const xOffsetForExportButton = getXOffsetForExportButton(buttonGroup, buttonPosition);\n                        this.alignButtonGroup(xOffsetForExportButton);\n                        // Skip animation\n                        group.placed = buttonGroup.placed = chart.hasLoaded;\n                    }\n                    let xOffsetForExportButton = 0;\n                    if (inputGroup) {\n                        // Detect collision between the input group and exporting button\n                        xOffsetForExportButton = getXOffsetForExportButton(inputGroup, inputPosition);\n                        if (inputPosition.align === 'left') {\n                            translateX = plotLeft;\n                        }\n                        else if (inputPosition.align === 'right') {\n                            translateX = -Math.max(chart.axisOffset[1], -xOffsetForExportButton);\n                        }\n                        // Update the alignment to the updated spacing box\n                        inputGroup.align({\n                            y: inputPosition.y,\n                            width: inputGroup.getBBox().width,\n                            align: inputPosition.align,\n                            // fix wrong getBBox() value on right align\n                            x: inputPosition.x + translateX - 2\n                        }, true, chart.spacingBox);\n                        // Skip animation\n                        inputGroup.placed = chart.hasLoaded;\n                    }\n                    this.handleCollision(xOffsetForExportButton);\n                    // Vertical align\n                    group.align({\n                        verticalAlign\n                    }, true, chart.spacingBox);\n                    const alignTranslateY = group.alignAttr.translateY;\n                    // Set position\n                    let groupHeight = group.getBBox().height + 20; // # 20 padding\n                    let translateY = 0;\n                    // Calculate bottom position\n                    if (verticalAlign === 'bottom') {\n                        const legendOptions = chart.legend && chart.legend.options;\n                        const legendHeight = (legendOptions &&\n                            legendOptions.verticalAlign === 'bottom' &&\n                            legendOptions.enabled &&\n                            !legendOptions.floating ?\n                            (chart.legend.legendHeight +\n                                pick(legendOptions.margin, 10)) :\n                            0);\n                        groupHeight = groupHeight + legendHeight - 20;\n                        translateY = (alignTranslateY -\n                            groupHeight -\n                            (options.floating ? 0 : options.y) -\n                            (chart.titleOffset ? chart.titleOffset[2] : 0) -\n                            10 // 10 spacing\n                        );\n                    }\n                    if (verticalAlign === 'top') {\n                        if (options.floating) {\n                            translateY = 0;\n                        }\n                        if (chart.titleOffset && chart.titleOffset[0]) {\n                            translateY = chart.titleOffset[0];\n                        }\n                        translateY += ((chart.margin[0] - chart.spacing[0]) || 0);\n                    }\n                    else if (verticalAlign === 'middle') {\n                        if (inputPosition.y === buttonPosition.y) {\n                            translateY = alignTranslateY;\n                        }\n                        else if (inputPosition.y || buttonPosition.y) {\n                            if (inputPosition.y < 0 ||\n                                buttonPosition.y < 0) {\n                                translateY -= Math.min(inputPosition.y, buttonPosition.y);\n                            }\n                            else {\n                                translateY = alignTranslateY - groupHeight;\n                            }\n                        }\n                    }\n                    group.translate(options.x, options.y + Math.floor(translateY));\n                    // Translate HTML inputs\n                    const { minInput, maxInput, dropdown } = this;\n                    if (options.inputEnabled && minInput && maxInput) {\n                        minInput.style.marginTop = group.translateY + 'px';\n                        maxInput.style.marginTop = group.translateY + 'px';\n                    }\n                    if (dropdown) {\n                        dropdown.style.marginTop = group.translateY + 'px';\n                    }\n                }\n            }\n            /**\n             * Align the button group horizontally and vertically.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#alignButtonGroup\n             * @param {number} xOffsetForExportButton\n             * @param {number} [width]\n             */\n            alignButtonGroup(xOffsetForExportButton, width) {\n                const { chart, options, buttonGroup } = this;\n                const { buttonPosition } = options;\n                const plotLeft = chart.plotLeft - chart.spacing[3];\n                let translateX = buttonPosition.x - chart.spacing[3];\n                if (buttonPosition.align === 'right') {\n                    translateX += xOffsetForExportButton - plotLeft; // #13014\n                }\n                else if (buttonPosition.align === 'center') {\n                    translateX -= plotLeft / 2;\n                }\n                if (buttonGroup) {\n                    // Align button group\n                    buttonGroup.align({\n                        y: buttonPosition.y,\n                        width: pick(width, this.initialButtonGroupWidth),\n                        align: buttonPosition.align,\n                        x: translateX\n                    }, true, chart.spacingBox);\n                }\n            }\n            /**\n             * @private\n             * @function Highcharts.RangeSelector#positionButtons\n             */\n            positionButtons() {\n                const { buttons, chart, options, zoomText } = this;\n                const verb = chart.hasLoaded ? 'animate' : 'attr';\n                const { buttonPosition } = options;\n                const plotLeft = chart.plotLeft;\n                let buttonLeft = plotLeft;\n                if (zoomText && zoomText.visibility !== 'hidden') {\n                    // #8769, allow dynamically updating margins\n                    zoomText[verb]({\n                        x: pick(plotLeft + buttonPosition.x, plotLeft)\n                    });\n                    // Button start position\n                    buttonLeft += buttonPosition.x +\n                        zoomText.getBBox().width + 5;\n                }\n                for (let i = 0, iEnd = this.buttonOptions.length; i < iEnd; ++i) {\n                    if (buttons[i].visibility !== 'hidden') {\n                        buttons[i][verb]({ x: buttonLeft });\n                        // Increase the button position for the next button\n                        buttonLeft += (buttons[i].width || 0) + options.buttonSpacing;\n                    }\n                    else {\n                        buttons[i][verb]({ x: plotLeft });\n                    }\n                }\n            }\n            /**\n             * Handle collision between the button group and the input group\n             *\n             * @private\n             * @function Highcharts.RangeSelector#handleCollision\n             *\n             * @param  {number} xOffsetForExportButton\n             *                  The X offset of the group required to make room for the\n             *                  exporting button\n             */\n            handleCollision(xOffsetForExportButton) {\n                const { chart, buttonGroup, inputGroup } = this;\n                const { buttonPosition, dropdown, inputPosition } = this.options;\n                const maxButtonWidth = () => {\n                    let buttonWidth = 0;\n                    this.buttons.forEach((button) => {\n                        const bBox = button.getBBox();\n                        if (bBox.width > buttonWidth) {\n                            buttonWidth = bBox.width;\n                        }\n                    });\n                    return buttonWidth;\n                };\n                const groupsOverlap = (buttonGroupWidth) => {\n                    if (inputGroup && buttonGroup) {\n                        const inputGroupX = (inputGroup.alignAttr.translateX +\n                            inputGroup.alignOptions.x -\n                            xOffsetForExportButton +\n                            // getBBox for detecing left margin\n                            inputGroup.getBBox().x +\n                            // 2px padding to not overlap input and label\n                            2);\n                        const inputGroupWidth = inputGroup.alignOptions.width;\n                        const buttonGroupX = buttonGroup.alignAttr.translateX +\n                            buttonGroup.getBBox().x;\n                        return (buttonGroupX + buttonGroupWidth > inputGroupX) &&\n                            (inputGroupX + inputGroupWidth > buttonGroupX) &&\n                            (buttonPosition.y <\n                                (inputPosition.y +\n                                    inputGroup.getBBox().height));\n                    }\n                    return false;\n                };\n                const moveInputsDown = () => {\n                    if (inputGroup && buttonGroup) {\n                        inputGroup.attr({\n                            translateX: inputGroup.alignAttr.translateX + (chart.axisOffset[1] >= -xOffsetForExportButton ?\n                                0 :\n                                -xOffsetForExportButton),\n                            translateY: inputGroup.alignAttr.translateY +\n                                buttonGroup.getBBox().height + 10\n                        });\n                    }\n                };\n                if (buttonGroup) {\n                    if (dropdown === 'always') {\n                        this.collapseButtons(xOffsetForExportButton);\n                        if (groupsOverlap(maxButtonWidth())) {\n                            // Move the inputs down if there is still a collision\n                            // after collapsing the buttons\n                            moveInputsDown();\n                        }\n                        return;\n                    }\n                    if (dropdown === 'never') {\n                        this.expandButtons();\n                    }\n                }\n                // Detect collision\n                if (inputGroup && buttonGroup) {\n                    if ((inputPosition.align === buttonPosition.align) ||\n                        // 20 is minimal spacing between elements\n                        groupsOverlap(this.initialButtonGroupWidth + 20)) {\n                        if (dropdown === 'responsive') {\n                            this.collapseButtons(xOffsetForExportButton);\n                            if (groupsOverlap(maxButtonWidth())) {\n                                moveInputsDown();\n                            }\n                        }\n                        else {\n                            moveInputsDown();\n                        }\n                    }\n                    else if (dropdown === 'responsive') {\n                        this.expandButtons();\n                    }\n                }\n                else if (buttonGroup && dropdown === 'responsive') {\n                    if (this.initialButtonGroupWidth > chart.plotWidth) {\n                        this.collapseButtons(xOffsetForExportButton);\n                    }\n                    else {\n                        this.expandButtons();\n                    }\n                }\n            }\n            /**\n             * Collapse the buttons and put the select element on top.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#collapseButtons\n             * @param {number} xOffsetForExportButton\n             */\n            collapseButtons(xOffsetForExportButton) {\n                const { buttons, buttonOptions, chart, dropdown, options, zoomText } = this;\n                // If the buttons are already collapsed do nothing.\n                if (this.isCollapsed === true) {\n                    return;\n                }\n                this.isCollapsed = true;\n                const userButtonTheme = (chart.userOptions.rangeSelector &&\n                    chart.userOptions.rangeSelector.buttonTheme) || {};\n                const getAttribs = (text) => ({\n                    text: text ? `${text} â–¾` : 'â–¾',\n                    width: 'auto',\n                    paddingLeft: pick(options.buttonTheme.paddingLeft, userButtonTheme.padding, 8),\n                    paddingRight: pick(options.buttonTheme.paddingRight, userButtonTheme.padding, 8)\n                });\n                if (zoomText) {\n                    zoomText.hide();\n                }\n                let hasActiveButton = false;\n                buttonOptions.forEach((rangeOptions, i) => {\n                    const button = buttons[i];\n                    if (button.state !== 2) {\n                        button.hide();\n                    }\n                    else {\n                        button.show();\n                        button.attr(getAttribs(rangeOptions.text));\n                        hasActiveButton = true;\n                    }\n                });\n                if (!hasActiveButton) {\n                    if (dropdown) {\n                        dropdown.selectedIndex = 0;\n                    }\n                    buttons[0].show();\n                    buttons[0].attr(getAttribs(this.zoomText && this.zoomText.textStr));\n                }\n                const { align } = options.buttonPosition;\n                this.positionButtons();\n                if (align === 'right' || align === 'center') {\n                    this.alignButtonGroup(xOffsetForExportButton, buttons[this.currentButtonIndex()].getBBox().width);\n                }\n                this.showDropdown();\n            }\n            /**\n             * Show all the buttons and hide the select element.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#expandButtons\n             */\n            expandButtons() {\n                const { buttons, buttonOptions, options, zoomText } = this;\n                this.hideDropdown();\n                // If buttons are already not collapsed, do nothing.\n                if (this.isCollapsed === false) {\n                    return;\n                }\n                this.isCollapsed = false;\n                if (zoomText) {\n                    zoomText.show();\n                }\n                buttonOptions.forEach((rangeOptions, i) => {\n                    const button = buttons[i];\n                    button.show();\n                    button.attr({\n                        text: rangeOptions.text,\n                        width: options.buttonTheme.width || 28,\n                        paddingLeft: pick(options.buttonTheme.paddingLeft, 'unset'),\n                        paddingRight: pick(options.buttonTheme.paddingRight, 'unset')\n                    });\n                    if (button.state < 2) {\n                        button.setState(0);\n                    }\n                });\n                this.positionButtons();\n            }\n            /**\n             * Get the index of the visible button when the buttons are collapsed.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#currentButtonIndex\n             */\n            currentButtonIndex() {\n                const { dropdown } = this;\n                if (dropdown && dropdown.selectedIndex > 0) {\n                    return dropdown.selectedIndex - 1;\n                }\n                return 0;\n            }\n            /**\n             * Position the select element on top of the button.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#showDropdown\n             */\n            showDropdown() {\n                const { buttonGroup, buttons, chart, dropdown } = this;\n                if (buttonGroup && dropdown) {\n                    const { translateX = 0, translateY = 0 } = buttonGroup, bBox = buttons[this.currentButtonIndex()].getBBox();\n                    css(dropdown, {\n                        left: (chart.plotLeft + translateX) + 'px',\n                        top: (translateY + 0.5) + 'px',\n                        width: bBox.width + 'px',\n                        height: bBox.height + 'px'\n                    });\n                    this.hasVisibleDropdown = true;\n                }\n            }\n            /**\n             * @private\n             * @function Highcharts.RangeSelector#hideDropdown\n             */\n            hideDropdown() {\n                const { dropdown } = this;\n                if (dropdown) {\n                    css(dropdown, {\n                        top: '-9999em',\n                        width: '1px',\n                        height: '1px'\n                    });\n                    this.hasVisibleDropdown = false;\n                }\n            }\n            /**\n             * Extracts height of range selector\n             *\n             * @private\n             * @function Highcharts.RangeSelector#getHeight\n             * @return {number}\n             * Returns rangeSelector height\n             */\n            getHeight() {\n                const rangeSelector = this, options = rangeSelector.options, rangeSelectorGroup = rangeSelector.group, inputPosition = options.inputPosition, buttonPosition = options.buttonPosition, yPosition = options.y, buttonPositionY = buttonPosition.y, inputPositionY = inputPosition.y;\n                let rangeSelectorHeight = 0;\n                if (options.height) {\n                    return options.height;\n                }\n                // Align the elements before we read the height in case we're switching\n                // between wrapped and non-wrapped layout\n                this.alignElements();\n                rangeSelectorHeight = rangeSelectorGroup ?\n                    // 13px to keep back compatibility\n                    (rangeSelectorGroup.getBBox(true).height) + 13 +\n                        yPosition :\n                    0;\n                const minPosition = Math.min(inputPositionY, buttonPositionY);\n                if ((inputPositionY < 0 && buttonPositionY < 0) ||\n                    (inputPositionY > 0 && buttonPositionY > 0)) {\n                    rangeSelectorHeight += Math.abs(minPosition);\n                }\n                return rangeSelectorHeight;\n            }\n            /**\n             * Detect collision with title or subtitle\n             *\n             * @private\n             * @function Highcharts.RangeSelector#titleCollision\n             * @return {boolean}\n             * Returns collision status\n             */\n            titleCollision(chart) {\n                return !(chart.options.title.text ||\n                    chart.options.subtitle.text);\n            }\n            /**\n             * Update the range selector with new options\n             *\n             * @private\n             * @function Highcharts.RangeSelector#update\n             * @param {Highcharts.RangeSelectorOptions} options\n             */\n            update(options) {\n                const chart = this.chart;\n                merge(true, chart.options.rangeSelector, options);\n                this.destroy();\n                this.init(chart);\n                this.render();\n            }\n            /**\n             * Destroys allocated elements.\n             *\n             * @private\n             * @function Highcharts.RangeSelector#destroy\n             */\n            destroy() {\n                const rSelector = this, minInput = rSelector.minInput, maxInput = rSelector.maxInput;\n                if (rSelector.eventsToUnbind) {\n                    rSelector.eventsToUnbind.forEach((unbind) => unbind());\n                    rSelector.eventsToUnbind = void 0;\n                }\n                // Destroy elements in collections\n                destroyObjectProperties(rSelector.buttons);\n                // Clear input element events\n                if (minInput) {\n                    minInput.onfocus = minInput.onblur = minInput.onchange = null;\n                }\n                if (maxInput) {\n                    maxInput.onfocus = maxInput.onblur = maxInput.onchange = null;\n                }\n                // Destroy HTML and SVG elements\n                objectEach(rSelector, function (val, key) {\n                    if (val && key !== 'chart') {\n                        if (val instanceof SVGElement) {\n                            // SVGElement\n                            val.destroy();\n                        }\n                        else if (val instanceof window.HTMLElement) {\n                            // HTML element\n                            discardElement(val);\n                        }\n                    }\n                    if (val !== RangeSelector.prototype[key]) {\n                        rSelector[key] = null;\n                    }\n                }, this);\n            }\n        }\n        extend(RangeSelector.prototype, {\n            /**\n             * The default buttons for pre-selecting time frames.\n             * @private\n             */\n            defaultButtons: [{\n                    type: 'month',\n                    count: 1,\n                    text: '1m',\n                    title: 'View 1 month'\n                }, {\n                    type: 'month',\n                    count: 3,\n                    text: '3m',\n                    title: 'View 3 months'\n                }, {\n                    type: 'month',\n                    count: 6,\n                    text: '6m',\n                    title: 'View 6 months'\n                }, {\n                    type: 'ytd',\n                    text: 'YTD',\n                    title: 'View year to date'\n                }, {\n                    type: 'year',\n                    count: 1,\n                    text: '1y',\n                    title: 'View 1 year'\n                }, {\n                    type: 'all',\n                    text: 'All',\n                    title: 'View all'\n                }],\n            /**\n             * The date formats to use when setting min, max and value on date inputs.\n             * @private\n             */\n            inputTypeFormats: {\n                'datetime-local': '%Y-%m-%dT%H:%M:%S',\n                'date': '%Y-%m-%d',\n                'time': '%H:%M:%S'\n            }\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Define the time span for the button\n         *\n         * @typedef {\"all\"|\"day\"|\"hour\"|\"millisecond\"|\"minute\"|\"month\"|\"second\"|\"week\"|\"year\"|\"ytd\"} Highcharts.RangeSelectorButtonTypeValue\n         */\n        /**\n         * Callback function to react on button clicks.\n         *\n         * @callback Highcharts.RangeSelectorClickCallbackFunction\n         *\n         * @param {global.Event} e\n         *        Event arguments.\n         *\n         * @param {boolean|undefined}\n         *        Return false to cancel the default button event.\n         */\n        /**\n         * Callback function to parse values entered in the input boxes and return a\n         * valid JavaScript time as milliseconds since 1970.\n         *\n         * @callback Highcharts.RangeSelectorParseCallbackFunction\n         *\n         * @param {string} value\n         *        Input value to parse.\n         *\n         * @return {number}\n         *         Parsed JavaScript time value.\n         */\n        (''); // keeps doclets above in JS file\n\n        return RangeSelector;\n    });\n    _registerModule(_modules, 'Series/PathUtilities.js', [], function () {\n        /* *\n         *\n         *  (c) 2010-2024 Pawel Lysy\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const getLinkPath = {\n            'default': getDefaultPath,\n            straight: getStraightPath,\n            curved: getCurvedPath\n        };\n        function getDefaultPath(pathParams) {\n            const { x1, y1, x2, y2, width = 0, inverted = false, radius, parentVisible } = pathParams;\n            const path = [\n                ['M', x1, y1],\n                ['L', x1, y1],\n                ['C', x1, y1, x1, y2, x1, y2],\n                ['L', x1, y2],\n                ['C', x1, y1, x1, y2, x1, y2],\n                ['L', x1, y2]\n            ];\n            return parentVisible ?\n                applyRadius([\n                    ['M', x1, y1],\n                    ['L', x1 + width * (inverted ? -0.5 : 0.5), y1],\n                    ['L', x1 + width * (inverted ? -0.5 : 0.5), y2],\n                    ['L', x2, y2]\n                ], radius) :\n                path;\n        }\n        function getStraightPath(pathParams) {\n            const { x1, y1, x2, y2, width = 0, inverted = false, parentVisible } = pathParams;\n            return parentVisible ? [\n                ['M', x1, y1],\n                ['L', x1 + width * (inverted ? -1 : 1), y2],\n                ['L', x2, y2]\n            ] : [\n                ['M', x1, y1],\n                ['L', x1, y2],\n                ['L', x1, y2]\n            ];\n        }\n        function getCurvedPath(pathParams) {\n            const { x1, y1, x2, y2, offset = 0, width = 0, inverted = false, parentVisible } = pathParams;\n            return parentVisible ?\n                [\n                    ['M', x1, y1],\n                    [\n                        'C',\n                        x1 + offset,\n                        y1,\n                        x1 - offset + width * (inverted ? -1 : 1),\n                        y2,\n                        x1 + width * (inverted ? -1 : 1),\n                        y2\n                    ],\n                    ['L', x2, y2]\n                ] :\n                [\n                    ['M', x1, y1],\n                    ['C', x1, y1, x1, y2, x1, y2],\n                    ['L', x2, y2]\n                ];\n        }\n        /**\n         * General function to apply corner radius to a path\n         * @private\n         */\n        function applyRadius(path, r) {\n            const d = [];\n            for (let i = 0; i < path.length; i++) {\n                const x = path[i][1];\n                const y = path[i][2];\n                if (typeof x === 'number' && typeof y === 'number') {\n                    // moveTo\n                    if (i === 0) {\n                        d.push(['M', x, y]);\n                    }\n                    else if (i === path.length - 1) {\n                        d.push(['L', x, y]);\n                        // curveTo\n                    }\n                    else if (r) {\n                        const prevSeg = path[i - 1];\n                        const nextSeg = path[i + 1];\n                        if (prevSeg && nextSeg) {\n                            const x1 = prevSeg[1], y1 = prevSeg[2], x2 = nextSeg[1], y2 = nextSeg[2];\n                            // Only apply to breaks\n                            if (typeof x1 === 'number' &&\n                                typeof x2 === 'number' &&\n                                typeof y1 === 'number' &&\n                                typeof y2 === 'number' &&\n                                x1 !== x2 &&\n                                y1 !== y2) {\n                                const directionX = x1 < x2 ? 1 : -1, directionY = y1 < y2 ? 1 : -1;\n                                d.push([\n                                    'L',\n                                    x - directionX * Math.min(Math.abs(x - x1), r),\n                                    y - directionY * Math.min(Math.abs(y - y1), r)\n                                ], [\n                                    'C',\n                                    x,\n                                    y,\n                                    x,\n                                    y,\n                                    x + directionX * Math.min(Math.abs(x - x2), r),\n                                    y + directionY * Math.min(Math.abs(y - y2), r)\n                                ]);\n                            }\n                        }\n                        // lineTo\n                    }\n                    else {\n                        d.push(['L', x, y]);\n                    }\n                }\n            }\n            return d;\n        }\n        const PathUtilities = {\n            applyRadius,\n            getLinkPath\n        };\n\n        return PathUtilities;\n    });\n    _registerModule(_modules, 'Gantt/PathfinderAlgorithms.js', [_modules['Series/PathUtilities.js'], _modules['Core/Utilities.js']], function (PathUtilities, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Author: Ã˜ystein Moseng\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { pick } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const { min, max, abs } = Math;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get index of last obstacle before xMin. Employs a type of binary search, and\n         * thus requires that obstacles are sorted by xMin value.\n         *\n         * @private\n         * @function findLastObstacleBefore\n         *\n         * @param {Array<object>} obstacles\n         *        Array of obstacles to search in.\n         *\n         * @param {number} xMin\n         *        The xMin threshold.\n         *\n         * @param {number} [startIx]\n         *        Starting index to search from. Must be within array range.\n         *\n         * @return {number}\n         *         The index of the last obstacle element before xMin.\n         */\n        function findLastObstacleBefore(obstacles, xMin, startIx) {\n            const min = xMin - 0.0000001; // Make sure we include all obstacles at xMin\n            let left = startIx || 0, // Left limit\n            right = obstacles.length - 1, // Right limit\n            cursor, cmp;\n            while (left <= right) {\n                cursor = (right + left) >> 1;\n                cmp = min - obstacles[cursor].xMin;\n                if (cmp > 0) {\n                    left = cursor + 1;\n                }\n                else if (cmp < 0) {\n                    right = cursor - 1;\n                }\n                else {\n                    return cursor;\n                }\n            }\n            return left > 0 ? left - 1 : 0;\n        }\n        /**\n         * Test if a point lays within an obstacle.\n         *\n         * @private\n         * @function pointWithinObstacle\n         *\n         * @param {Object} obstacle\n         *        Obstacle to test.\n         *\n         * @param {Highcharts.Point} point\n         *        Point with x/y props.\n         *\n         * @return {boolean}\n         *         Whether point is within the obstacle or not.\n         */\n        function pointWithinObstacle(obstacle, point) {\n            return (point.x <= obstacle.xMax &&\n                point.x >= obstacle.xMin &&\n                point.y <= obstacle.yMax &&\n                point.y >= obstacle.yMin);\n        }\n        /**\n         * Find the index of an obstacle that wraps around a point.\n         * Returns -1 if not found.\n         *\n         * @private\n         * @function findObstacleFromPoint\n         *\n         * @param {Array<object>} obstacles\n         *        Obstacles to test.\n         *\n         * @param {Highcharts.Point} point\n         *        Point with x/y props.\n         *\n         * @return {number}\n         *         Ix of the obstacle in the array, or -1 if not found.\n         */\n        function findObstacleFromPoint(obstacles, point) {\n            let i = findLastObstacleBefore(obstacles, point.x + 1) + 1;\n            while (i--) {\n                if (obstacles[i].xMax >= point.x &&\n                    // Optimization using lazy evaluation\n                    pointWithinObstacle(obstacles[i], point)) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n        /**\n         * Get SVG path array from array of line segments.\n         *\n         * @private\n         * @function pathFromSegments\n         *\n         * @param {Array<object>} segments\n         *        The segments to build the path from.\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         SVG path array as accepted by the SVG Renderer.\n         */\n        function pathFromSegments(segments) {\n            const path = [];\n            if (segments.length) {\n                path.push(['M', segments[0].start.x, segments[0].start.y]);\n                for (let i = 0; i < segments.length; ++i) {\n                    path.push(['L', segments[i].end.x, segments[i].end.y]);\n                }\n            }\n            return path;\n        }\n        /**\n         * Limits obstacle max/mins in all directions to bounds. Modifies input\n         * obstacle.\n         *\n         * @private\n         * @function limitObstacleToBounds\n         *\n         * @param {Object} obstacle\n         *        Obstacle to limit.\n         *\n         * @param {Object} bounds\n         *        Bounds to use as limit.\n         *\n         * @return {void}\n         */\n        function limitObstacleToBounds(obstacle, bounds) {\n            obstacle.yMin = max(obstacle.yMin, bounds.yMin);\n            obstacle.yMax = min(obstacle.yMax, bounds.yMax);\n            obstacle.xMin = max(obstacle.xMin, bounds.xMin);\n            obstacle.xMax = min(obstacle.xMax, bounds.xMax);\n        }\n        /**\n         * Get an SVG path from a starting coordinate to an ending coordinate.\n         * Draws a straight line.\n         *\n         * @function Highcharts.Pathfinder.algorithms.straight\n         *\n         * @param {Highcharts.PositionObject} start\n         *        Starting coordinate, object with x/y props.\n         *\n         * @param {Highcharts.PositionObject} end\n         *        Ending coordinate, object with x/y props.\n         *\n         * @return {Object}\n         *         An object with the SVG path in Array form as accepted by the SVG\n         *         renderer, as well as an array of new obstacles making up this\n         *         path.\n         */\n        function straight(start, end) {\n            return {\n                path: [\n                    ['M', start.x, start.y],\n                    ['L', end.x, end.y]\n                ],\n                obstacles: [{ start: start, end: end }]\n            };\n        }\n        /**\n         * Find a path from a starting coordinate to an ending coordinate, using\n         * right angles only, and taking only starting/ending obstacle into\n         * consideration.\n         *\n         * @function Highcharts.Pathfinder.algorithms.simpleConnect\n         *\n         * @param {Highcharts.PositionObject} start\n         *        Starting coordinate, object with x/y props.\n         *\n         * @param {Highcharts.PositionObject} end\n         *        Ending coordinate, object with x/y props.\n         *\n         * @param {Object} options\n         *        Options for the algorithm:\n         *        - chartObstacles: Array of chart obstacles to avoid\n         *        - startDirectionX: Optional. True if starting in the X direction.\n         *          If not provided, the algorithm starts in the direction that is\n         *          the furthest between start/end.\n         *\n         * @return {Object}\n         *         An object with the SVG path in Array form as accepted by the SVG\n         *         renderer, as well as an array of new obstacles making up this\n         *         path.\n         */\n        const simpleConnect = function (start, end, options) {\n            const segments = [], chartObstacles = options.chartObstacles, startObstacleIx = findObstacleFromPoint(chartObstacles, start), endObstacleIx = findObstacleFromPoint(chartObstacles, end);\n            let endSegment, dir = pick(options.startDirectionX, abs(end.x - start.x) > abs(end.y - start.y)) ? 'x' : 'y', startObstacle, endObstacle, waypoint, useMax, endPoint;\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Return a clone of a point with a property set from a target object,\n             * optionally with an offset\n             * @private\n             */\n            function copyFromPoint(from, fromKey, to, toKey, offset) {\n                const point = {\n                    x: from.x,\n                    y: from.y\n                };\n                point[fromKey] = to[toKey || fromKey] + (offset || 0);\n                return point;\n            }\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Return waypoint outside obstacle.\n             * @private\n             */\n            function getMeOut(obstacle, point, direction) {\n                const useMax = abs(point[direction] - obstacle[direction + 'Min']) >\n                    abs(point[direction] - obstacle[direction + 'Max']);\n                return copyFromPoint(point, direction, obstacle, direction + (useMax ? 'Max' : 'Min'), useMax ? 1 : -1);\n            }\n            // Pull out end point\n            if (endObstacleIx > -1) {\n                endObstacle = chartObstacles[endObstacleIx];\n                waypoint = getMeOut(endObstacle, end, dir);\n                endSegment = {\n                    start: waypoint,\n                    end: end\n                };\n                endPoint = waypoint;\n            }\n            else {\n                endPoint = end;\n            }\n            // If an obstacle envelops the start point, add a segment to get out,\n            // and around it.\n            if (startObstacleIx > -1) {\n                startObstacle = chartObstacles[startObstacleIx];\n                waypoint = getMeOut(startObstacle, start, dir);\n                segments.push({\n                    start: start,\n                    end: waypoint\n                });\n                // If we are going back again, switch direction to get around start\n                // obstacle.\n                if (\n                // Going towards max from start:\n                waypoint[dir] >= start[dir] ===\n                    // Going towards min to end:\n                    waypoint[dir] >= endPoint[dir]) {\n                    dir = dir === 'y' ? 'x' : 'y';\n                    useMax = start[dir] < end[dir];\n                    segments.push({\n                        start: waypoint,\n                        end: copyFromPoint(waypoint, dir, startObstacle, dir + (useMax ? 'Max' : 'Min'), useMax ? 1 : -1)\n                    });\n                    // Switch direction again\n                    dir = dir === 'y' ? 'x' : 'y';\n                }\n            }\n            // We are around the start obstacle. Go towards the end in one\n            // direction.\n            const prevWaypoint = segments.length ?\n                segments[segments.length - 1].end :\n                start;\n            waypoint = copyFromPoint(prevWaypoint, dir, endPoint);\n            segments.push({\n                start: prevWaypoint,\n                end: waypoint\n            });\n            // Final run to end point in the other direction\n            dir = dir === 'y' ? 'x' : 'y';\n            const waypoint2 = copyFromPoint(waypoint, dir, endPoint);\n            segments.push({\n                start: waypoint,\n                end: waypoint2\n            });\n            // Finally add the endSegment\n            segments.push(endSegment);\n            const path = PathUtilities.applyRadius(pathFromSegments(segments), options.radius);\n            return {\n                path,\n                obstacles: segments\n            };\n        };\n        simpleConnect.requiresObstacles = true;\n        /**\n         * Find a path from a starting coordinate to an ending coordinate, taking\n         * obstacles into consideration. Might not always find the optimal path,\n         * but is fast, and usually good enough.\n         *\n         * @function Highcharts.Pathfinder.algorithms.fastAvoid\n         *\n         * @param {Highcharts.PositionObject} start\n         *        Starting coordinate, object with x/y props.\n         *\n         * @param {Highcharts.PositionObject} end\n         *        Ending coordinate, object with x/y props.\n         *\n         * @param {Object} options\n         *        Options for the algorithm.\n         *        - chartObstacles:  Array of chart obstacles to avoid\n         *        - lineObstacles:   Array of line obstacles to jump over\n         *        - obstacleMetrics: Object with metrics of chartObstacles cached\n         *        - hardBounds:      Hard boundaries to not cross\n         *        - obstacleOptions: Options for the obstacles, including margin\n         *        - startDirectionX: Optional. True if starting in the X direction.\n         *                           If not provided, the algorithm starts in the\n         *                           direction that is the furthest between\n         *                           start/end.\n         *\n         * @return {Object}\n         *         An object with the SVG path in Array form as accepted by the SVG\n         *         renderer, as well as an array of new obstacles making up this\n         *         path.\n         */\n        function fastAvoid(start, end, options) {\n            /*\n                Algorithm rules/description\n                - Find initial direction\n                - Determine soft/hard max for each direction.\n                - Move along initial direction until obstacle.\n                - Change direction.\n                - If hitting obstacle, first try to change length of previous line\n                    before changing direction again.\n\n                Soft min/max x = start/destination x +/- widest obstacle + margin\n                Soft min/max y = start/destination y +/- tallest obstacle + margin\n\n                @todo:\n                    - Make retrospective, try changing prev segment to reduce\n                        corners\n                    - Fix logic for breaking out of end-points - not always picking\n                        the best direction currently\n                    - When going around the end obstacle we should not always go the\n                        shortest route, rather pick the one closer to the end point\n            */\n            const dirIsX = pick(options.startDirectionX, abs(end.x - start.x) > abs(end.y - start.y)), dir = dirIsX ? 'x' : 'y', endSegments = [], \n            // Boundaries to stay within. If beyond soft boundary, prefer to\n            // change direction ASAP. If at hard max, always change immediately.\n            metrics = options.obstacleMetrics, softMinX = min(start.x, end.x) - metrics.maxWidth - 10, softMaxX = max(start.x, end.x) + metrics.maxWidth + 10, softMinY = min(start.y, end.y) - metrics.maxHeight - 10, softMaxY = max(start.y, end.y) + metrics.maxHeight + 10;\n            let segments, useMax, extractedEndPoint, forceObstacleBreak = false, // Used in clearPathTo to keep track of\n            // when to force break through an obstacle.\n            // Obstacles\n            chartObstacles = options.chartObstacles, endObstacleIx = findLastObstacleBefore(chartObstacles, softMaxX);\n            const startObstacleIx = findLastObstacleBefore(chartObstacles, softMinX);\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * How far can you go between two points before hitting an obstacle?\n             * Does not work for diagonal lines (because it doesn't have to).\n             * @private\n             */\n            function pivotPoint(fromPoint, toPoint, directionIsX) {\n                const searchDirection = fromPoint.x < toPoint.x ? 1 : -1;\n                let firstPoint, lastPoint, highestPoint, lowestPoint;\n                if (fromPoint.x < toPoint.x) {\n                    firstPoint = fromPoint;\n                    lastPoint = toPoint;\n                }\n                else {\n                    firstPoint = toPoint;\n                    lastPoint = fromPoint;\n                }\n                if (fromPoint.y < toPoint.y) {\n                    lowestPoint = fromPoint;\n                    highestPoint = toPoint;\n                }\n                else {\n                    lowestPoint = toPoint;\n                    highestPoint = fromPoint;\n                }\n                // Go through obstacle range in reverse if toPoint is before\n                // fromPoint in the X-dimension.\n                let i = searchDirection < 0 ?\n                    // Searching backwards, start at last obstacle before last point\n                    min(findLastObstacleBefore(chartObstacles, lastPoint.x), chartObstacles.length - 1) :\n                    // Forwards. Since we're not sorted by xMax, we have to look\n                    // at all obstacles.\n                    0;\n                // Go through obstacles in this X range\n                while (chartObstacles[i] && (searchDirection > 0 && chartObstacles[i].xMin <= lastPoint.x ||\n                    searchDirection < 0 && chartObstacles[i].xMax >= firstPoint.x)) {\n                    // If this obstacle is between from and to points in a straight\n                    // line, pivot at the intersection.\n                    if (chartObstacles[i].xMin <= lastPoint.x &&\n                        chartObstacles[i].xMax >= firstPoint.x &&\n                        chartObstacles[i].yMin <= highestPoint.y &&\n                        chartObstacles[i].yMax >= lowestPoint.y) {\n                        if (directionIsX) {\n                            return {\n                                y: fromPoint.y,\n                                x: fromPoint.x < toPoint.x ?\n                                    chartObstacles[i].xMin - 1 :\n                                    chartObstacles[i].xMax + 1,\n                                obstacle: chartObstacles[i]\n                            };\n                        }\n                        // Else ...\n                        return {\n                            x: fromPoint.x,\n                            y: fromPoint.y < toPoint.y ?\n                                chartObstacles[i].yMin - 1 :\n                                chartObstacles[i].yMax + 1,\n                            obstacle: chartObstacles[i]\n                        };\n                    }\n                    i += searchDirection;\n                }\n                return toPoint;\n            }\n            /**\n             * Decide in which direction to dodge or get out of an obstacle.\n             * Considers desired direction, which way is shortest, soft and hard\n             * bounds.\n             *\n             * (? Returns a string, either xMin, xMax, yMin or yMax.)\n             *\n             * @private\n             * @function\n             *\n             * @param {Object} obstacle\n             *        Obstacle to dodge/escape.\n             *\n             * @param {Object} fromPoint\n             *        Point with x/y props that's dodging/escaping.\n             *\n             * @param {Object} toPoint\n             *        Goal point.\n             *\n             * @param {boolean} dirIsX\n             *        Dodge in X dimension.\n             *\n             * @param {Object} bounds\n             *        Hard and soft boundaries.\n             *\n             * @return {boolean}\n             *         Use max or not.\n             */\n            function getDodgeDirection(obstacle, fromPoint, toPoint, dirIsX, bounds) {\n                const softBounds = bounds.soft, hardBounds = bounds.hard, dir = dirIsX ? 'x' : 'y', toPointMax = { x: fromPoint.x, y: fromPoint.y }, toPointMin = { x: fromPoint.x, y: fromPoint.y }, maxOutOfSoftBounds = obstacle[dir + 'Max'] >=\n                    softBounds[dir + 'Max'], minOutOfSoftBounds = obstacle[dir + 'Min'] <=\n                    softBounds[dir + 'Min'], maxOutOfHardBounds = obstacle[dir + 'Max'] >=\n                    hardBounds[dir + 'Max'], minOutOfHardBounds = obstacle[dir + 'Min'] <=\n                    hardBounds[dir + 'Min'], \n                // Find out if we should prefer one direction over the other if\n                // we can choose freely\n                minDistance = abs(obstacle[dir + 'Min'] - fromPoint[dir]), maxDistance = abs(obstacle[dir + 'Max'] - fromPoint[dir]);\n                let // If it's a small difference, pick the one leading towards dest\n                // point. Otherwise pick the shortest distance\n                useMax = abs(minDistance - maxDistance) < 10 ?\n                    fromPoint[dir] < toPoint[dir] :\n                    maxDistance < minDistance;\n                // Check if we hit any obstacles trying to go around in either\n                // direction.\n                toPointMin[dir] = obstacle[dir + 'Min'];\n                toPointMax[dir] = obstacle[dir + 'Max'];\n                const minPivot = pivotPoint(fromPoint, toPointMin, dirIsX)[dir] !==\n                    toPointMin[dir], maxPivot = pivotPoint(fromPoint, toPointMax, dirIsX)[dir] !==\n                    toPointMax[dir];\n                useMax = minPivot ?\n                    (maxPivot ? useMax : true) :\n                    (maxPivot ? false : useMax);\n                // `useMax` now contains our preferred choice, bounds not taken into\n                // account. If both or neither direction is out of bounds we want to\n                // use this.\n                // Deal with soft bounds\n                useMax = minOutOfSoftBounds ?\n                    (maxOutOfSoftBounds ? useMax : true) : // Out on min\n                    (maxOutOfSoftBounds ? false : useMax); // Not out on min\n                // Deal with hard bounds\n                useMax = minOutOfHardBounds ?\n                    (maxOutOfHardBounds ? useMax : true) : // Out on min\n                    (maxOutOfHardBounds ? false : useMax); // Not out on min\n                return useMax;\n            }\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Find a clear path between point.\n             * @private\n             */\n            function clearPathTo(fromPoint, toPoint, dirIsX) {\n                // Don't waste time if we've hit goal\n                if (fromPoint.x === toPoint.x && fromPoint.y === toPoint.y) {\n                    return [];\n                }\n                const dir = dirIsX ? 'x' : 'y', obstacleMargin = options.obstacleOptions.margin, bounds = {\n                    soft: {\n                        xMin: softMinX,\n                        xMax: softMaxX,\n                        yMin: softMinY,\n                        yMax: softMaxY\n                    },\n                    hard: options.hardBounds\n                };\n                let pivot, segments, waypoint, waypointUseMax, envelopingObstacle, secondEnvelopingObstacle, envelopWaypoint;\n                // If fromPoint is inside an obstacle we have a problem. Break out\n                // by just going to the outside of this obstacle. We prefer to go to\n                // the nearest edge in the chosen direction.\n                envelopingObstacle =\n                    findObstacleFromPoint(chartObstacles, fromPoint);\n                if (envelopingObstacle > -1) {\n                    envelopingObstacle = chartObstacles[envelopingObstacle];\n                    waypointUseMax = getDodgeDirection(envelopingObstacle, fromPoint, toPoint, dirIsX, bounds);\n                    // Cut obstacle to hard bounds to make sure we stay within\n                    limitObstacleToBounds(envelopingObstacle, options.hardBounds);\n                    envelopWaypoint = dirIsX ? {\n                        y: fromPoint.y,\n                        x: envelopingObstacle[waypointUseMax ? 'xMax' : 'xMin'] +\n                            (waypointUseMax ? 1 : -1)\n                    } : {\n                        x: fromPoint.x,\n                        y: envelopingObstacle[waypointUseMax ? 'yMax' : 'yMin'] +\n                            (waypointUseMax ? 1 : -1)\n                    };\n                    // If we crashed into another obstacle doing this, we put the\n                    // waypoint between them instead\n                    secondEnvelopingObstacle = findObstacleFromPoint(chartObstacles, envelopWaypoint);\n                    if (secondEnvelopingObstacle > -1) {\n                        secondEnvelopingObstacle = chartObstacles[secondEnvelopingObstacle];\n                        // Cut obstacle to hard bounds\n                        limitObstacleToBounds(secondEnvelopingObstacle, options.hardBounds);\n                        // Modify waypoint to lay between obstacles\n                        envelopWaypoint[dir] = waypointUseMax ? max(envelopingObstacle[dir + 'Max'] - obstacleMargin + 1, (secondEnvelopingObstacle[dir + 'Min'] +\n                            envelopingObstacle[dir + 'Max']) / 2) :\n                            min((envelopingObstacle[dir + 'Min'] + obstacleMargin - 1), ((secondEnvelopingObstacle[dir + 'Max'] +\n                                envelopingObstacle[dir + 'Min']) / 2));\n                        // We are not going anywhere. If this happens for the first\n                        // time, do nothing. Otherwise, try to go to the extreme of\n                        // the obstacle pair in the current direction.\n                        if (fromPoint.x === envelopWaypoint.x &&\n                            fromPoint.y === envelopWaypoint.y) {\n                            if (forceObstacleBreak) {\n                                envelopWaypoint[dir] = waypointUseMax ?\n                                    max(envelopingObstacle[dir + 'Max'], secondEnvelopingObstacle[dir + 'Max']) + 1 :\n                                    min(envelopingObstacle[dir + 'Min'], secondEnvelopingObstacle[dir + 'Min']) - 1;\n                            }\n                            // Toggle on if off, and the opposite\n                            forceObstacleBreak = !forceObstacleBreak;\n                        }\n                        else {\n                            // This point is not identical to previous.\n                            // Clear break trigger.\n                            forceObstacleBreak = false;\n                        }\n                    }\n                    segments = [{\n                            start: fromPoint,\n                            end: envelopWaypoint\n                        }];\n                }\n                else { // If not enveloping, use standard pivot calculation\n                    pivot = pivotPoint(fromPoint, {\n                        x: dirIsX ? toPoint.x : fromPoint.x,\n                        y: dirIsX ? fromPoint.y : toPoint.y\n                    }, dirIsX);\n                    segments = [{\n                            start: fromPoint,\n                            end: {\n                                x: pivot.x,\n                                y: pivot.y\n                            }\n                        }];\n                    // Pivot before goal, use a waypoint to dodge obstacle\n                    if (pivot[dirIsX ? 'x' : 'y'] !== toPoint[dirIsX ? 'x' : 'y']) {\n                        // Find direction of waypoint\n                        waypointUseMax = getDodgeDirection(pivot.obstacle, pivot, toPoint, !dirIsX, bounds);\n                        // Cut waypoint to hard bounds\n                        limitObstacleToBounds(pivot.obstacle, options.hardBounds);\n                        waypoint = {\n                            x: dirIsX ?\n                                pivot.x :\n                                pivot.obstacle[waypointUseMax ? 'xMax' : 'xMin'] +\n                                    (waypointUseMax ? 1 : -1),\n                            y: dirIsX ?\n                                pivot.obstacle[waypointUseMax ? 'yMax' : 'yMin'] +\n                                    (waypointUseMax ? 1 : -1) :\n                                pivot.y\n                        };\n                        // We're changing direction here, store that to make sure we\n                        // also change direction when adding the last segment array\n                        // after handling waypoint.\n                        dirIsX = !dirIsX;\n                        segments = segments.concat(clearPathTo({\n                            x: pivot.x,\n                            y: pivot.y\n                        }, waypoint, dirIsX));\n                    }\n                }\n                // Get segments for the other direction too\n                // Recursion is our friend\n                segments = segments.concat(clearPathTo(segments[segments.length - 1].end, toPoint, !dirIsX));\n                return segments;\n            }\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Extract point to outside of obstacle in whichever direction is\n             * closest. Returns new point outside obstacle.\n             * @private\n             */\n            function extractFromObstacle(obstacle, point, goalPoint) {\n                const dirIsX = min(obstacle.xMax - point.x, point.x - obstacle.xMin) <\n                    min(obstacle.yMax - point.y, point.y - obstacle.yMin), bounds = {\n                    soft: options.hardBounds,\n                    hard: options.hardBounds\n                }, useMax = getDodgeDirection(obstacle, point, goalPoint, dirIsX, bounds);\n                return dirIsX ? {\n                    y: point.y,\n                    x: obstacle[useMax ? 'xMax' : 'xMin'] + (useMax ? 1 : -1)\n                } : {\n                    x: point.x,\n                    y: obstacle[useMax ? 'yMax' : 'yMin'] + (useMax ? 1 : -1)\n                };\n            }\n            // Cut the obstacle array to soft bounds for optimization in large\n            // datasets.\n            chartObstacles =\n                chartObstacles.slice(startObstacleIx, endObstacleIx + 1);\n            // If an obstacle envelops the end point, move it out of there and add\n            // a little segment to where it was.\n            if ((endObstacleIx = findObstacleFromPoint(chartObstacles, end)) > -1) {\n                extractedEndPoint = extractFromObstacle(chartObstacles[endObstacleIx], end, start);\n                endSegments.push({\n                    end: end,\n                    start: extractedEndPoint\n                });\n                end = extractedEndPoint;\n            }\n            // If it's still inside one or more obstacles, get out of there by\n            // force-moving towards the start point.\n            while ((endObstacleIx = findObstacleFromPoint(chartObstacles, end)) > -1) {\n                useMax = end[dir] - start[dir] < 0;\n                extractedEndPoint = {\n                    x: end.x,\n                    y: end.y\n                };\n                extractedEndPoint[dir] = chartObstacles[endObstacleIx][useMax ? dir + 'Max' : dir + 'Min'] + (useMax ? 1 : -1);\n                endSegments.push({\n                    end: end,\n                    start: extractedEndPoint\n                });\n                end = extractedEndPoint;\n            }\n            // Find the path\n            segments = clearPathTo(start, end, dirIsX);\n            // Add the end-point segments\n            segments = segments.concat(endSegments.reverse());\n            return {\n                path: pathFromSegments(segments),\n                obstacles: segments\n            };\n        }\n        fastAvoid.requiresObstacles = true;\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        // Define the available pathfinding algorithms.\n        // Algorithms take up to 3 arguments: starting point, ending point, and an\n        // options object.\n        const algorithms = {\n            fastAvoid,\n            straight,\n            simpleConnect\n        };\n\n        return algorithms;\n    });\n    _registerModule(_modules, 'Gantt/ConnectorsDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Ã˜ystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Defaults\n         *\n         * */\n        /*\n         @todo:\n             - Document how to write your own algorithms\n             - Consider adding a Point.pathTo method that wraps creating a connection\n               and rendering it\n        */\n        const connectorsDefaults = {\n            /**\n             * The Pathfinder module allows you to define connections between any two\n             * points, represented as lines - optionally with markers for the start\n             * and/or end points. Multiple algorithms are available for calculating how\n             * the connecting lines are drawn.\n             *\n             * Connector functionality requires Highcharts Gantt to be loaded. In Gantt\n             * charts, the connectors are used to draw dependencies between tasks.\n             *\n             * @see [dependency](series.gantt.data.dependency)\n             *\n             * @sample gantt/pathfinder/demo\n             *         Pathfinder connections\n             *\n             * @declare      Highcharts.ConnectorsOptions\n             * @product      gantt\n             * @optionparent connectors\n             */\n            connectors: {\n                /**\n                 * Enable connectors for this chart. Requires Highcharts Gantt.\n                 *\n                 * @type      {boolean}\n                 * @default   true\n                 * @since     6.2.0\n                 * @apioption connectors.enabled\n                 */\n                /**\n                 * Set the default dash style for this chart's connecting lines.\n                 *\n                 * @type      {string}\n                 * @default   solid\n                 * @since     6.2.0\n                 * @apioption connectors.dashStyle\n                 */\n                /**\n                 * Set the default color for this chart's Pathfinder connecting lines.\n                 * Defaults to the color of the point being connected.\n                 *\n                 * @type      {Highcharts.ColorString}\n                 * @since     6.2.0\n                 * @apioption connectors.lineColor\n                 */\n                /**\n                 * Set the default pathfinder margin to use, in pixels. Some Pathfinder\n                 * algorithms attempt to avoid obstacles, such as other points in the\n                 * chart. These algorithms use this margin to determine how close lines\n                 * can be to an obstacle. The default is to compute this automatically\n                 * from the size of the obstacles in the chart.\n                 *\n                 * To draw connecting lines close to existing points, set this to a low\n                 * number. For more space around existing points, set this number\n                 * higher.\n                 *\n                 * @sample gantt/pathfinder/algorithm-margin\n                 *         Small algorithmMargin\n                 *\n                 * @type      {number}\n                 * @since     6.2.0\n                 * @apioption connectors.algorithmMargin\n                 */\n                /**\n                 * Set the default pathfinder algorithm to use for this chart. It is\n                 * possible to define your own algorithms by adding them to the\n                 * Highcharts.Pathfinder.prototype.algorithms object before the chart\n                 * has been created.\n                 *\n                 * The default algorithms are as follows:\n                 *\n                 * `straight`:      Draws a straight line between the connecting\n                 *                  points. Does not avoid other points when drawing.\n                 *\n                 * `simpleConnect`: Finds a path between the points using right angles\n                 *                  only. Takes only starting/ending points into\n                 *                  account, and will not avoid other points.\n                 *\n                 * `fastAvoid`:     Finds a path between the points using right angles\n                 *                  only. Will attempt to avoid other points, but its\n                 *                  focus is performance over accuracy. Works well with\n                 *                  less dense datasets.\n                 *\n                 * Default value: `straight` is used as default for most series types,\n                 * while `simpleConnect` is used as default for Gantt series, to show\n                 * dependencies between points.\n                 *\n                 * @sample gantt/pathfinder/demo\n                 *         Different types used\n                 *\n                 * @type    {Highcharts.PathfinderTypeValue}\n                 * @default undefined\n                 * @since   6.2.0\n                 */\n                type: 'straight',\n                /**\n                 * The corner radius for the connector line.\n                 *\n                 * @since 11.2.0\n                 */\n                radius: 0,\n                /**\n                 * Set the default pixel width for this chart's Pathfinder connecting\n                 * lines.\n                 *\n                 * @since 6.2.0\n                 */\n                lineWidth: 1,\n                /**\n                 * Marker options for this chart's Pathfinder connectors. Note that\n                 * this option is overridden by the `startMarker` and `endMarker`\n                 * options.\n                 *\n                 * @declare Highcharts.ConnectorsMarkerOptions\n                 * @since   6.2.0\n                 */\n                marker: {\n                    /**\n                     * Set the radius of the connector markers. The default is\n                     * automatically computed based on the algorithmMargin setting.\n                     *\n                     * Setting marker.width and marker.height will override this\n                     * setting.\n                     *\n                     * @type      {number}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.radius\n                     */\n                    /**\n                     * Set the width of the connector markers. If not supplied, this\n                     * is inferred from the marker radius.\n                     *\n                     * @type      {number}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.width\n                     */\n                    /**\n                     * Set the height of the connector markers. If not supplied, this\n                     * is inferred from the marker radius.\n                     *\n                     * @type      {number}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.height\n                     */\n                    /**\n                     * Set the color of the connector markers. By default this is the\n                     * same as the connector color.\n                     *\n                     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.color\n                     */\n                    /**\n                     * Set the line/border color of the connector markers. By default\n                     * this is the same as the marker color.\n                     *\n                     * @type      {Highcharts.ColorString}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.lineColor\n                     */\n                    /**\n                     * Enable markers for the connectors.\n                     */\n                    enabled: false,\n                    /**\n                     * Horizontal alignment of the markers relative to the points.\n                     *\n                     * @type {Highcharts.AlignValue}\n                     */\n                    align: 'center',\n                    /**\n                     * Vertical alignment of the markers relative to the points.\n                     *\n                     * @type {Highcharts.VerticalAlignValue}\n                     */\n                    verticalAlign: 'middle',\n                    /**\n                     * Whether or not to draw the markers inside the points.\n                     */\n                    inside: false,\n                    /**\n                     * Set the line/border width of the pathfinder markers.\n                     */\n                    lineWidth: 1\n                },\n                /**\n                 * Marker options specific to the start markers for this chart's\n                 * Pathfinder connectors. Overrides the generic marker options.\n                 *\n                 * @declare Highcharts.ConnectorsStartMarkerOptions\n                 * @extends connectors.marker\n                 * @since   6.2.0\n                 */\n                startMarker: {\n                    /**\n                     * Set the symbol of the connector start markers.\n                     */\n                    symbol: 'diamond'\n                },\n                /**\n                 * Marker options specific to the end markers for this chart's\n                 * Pathfinder connectors. Overrides the generic marker options.\n                 *\n                 * @declare Highcharts.ConnectorsEndMarkerOptions\n                 * @extends connectors.marker\n                 * @since   6.2.0\n                 */\n                endMarker: {\n                    /**\n                     * Set the symbol of the connector end markers.\n                     */\n                    symbol: 'arrow-filled'\n                }\n            }\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Override Pathfinder connector options for a series. Requires Highcharts Gantt\n         * to be loaded.\n         *\n         * @declare   Highcharts.SeriesConnectorsOptionsObject\n         * @extends   connectors\n         * @since     6.2.0\n         * @excluding enabled, algorithmMargin\n         * @product   gantt\n         * @apioption plotOptions.series.connectors\n         */\n        /**\n         * Connect to a point. This option can be either a string, referring to the ID\n         * of another point, or an object, or an array of either. If the option is an\n         * array, each element defines a connection.\n         *\n         * @sample gantt/pathfinder/demo\n         *         Different connection types\n         *\n         * @declare   Highcharts.XrangePointConnectorsOptionsObject\n         * @type      {string|Array<string|*>|*}\n         * @extends   plotOptions.series.connectors\n         * @since     6.2.0\n         * @excluding enabled\n         * @product   gantt\n         * @requires  highcharts-gantt\n         * @apioption series.xrange.data.connect\n         */\n        /**\n         * The ID of the point to connect to.\n         *\n         * @type      {string}\n         * @since     6.2.0\n         * @product   gantt\n         * @apioption series.xrange.data.connect.to\n         */\n        ''; // Keeps doclets above in JS file\n\n        return connectorsDefaults;\n    });\n    _registerModule(_modules, 'Gantt/PathfinderComposition.js', [_modules['Gantt/ConnectorsDefaults.js'], _modules['Core/Defaults.js'], _modules['Core/Utilities.js']], function (ConnectorsDefaults, D, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Ã˜ystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { setOptions } = D;\n        const { defined, error, merge } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get point bounding box using plotX/plotY and shapeArgs. If using\n         * graphic.getBBox() directly, the bbox will be affected by animation.\n         *\n         * @private\n         * @function\n         *\n         * @param {Highcharts.Point} point\n         *        The point to get BB of.\n         *\n         * @return {Highcharts.Dictionary<number>|null}\n         *         Result xMax, xMin, yMax, yMin.\n         */\n        function getPointBB(point) {\n            const shapeArgs = point.shapeArgs;\n            // Prefer using shapeArgs (columns)\n            if (shapeArgs) {\n                return {\n                    xMin: shapeArgs.x || 0,\n                    xMax: (shapeArgs.x || 0) + (shapeArgs.width || 0),\n                    yMin: shapeArgs.y || 0,\n                    yMax: (shapeArgs.y || 0) + (shapeArgs.height || 0)\n                };\n            }\n            // Otherwise use plotX/plotY and bb\n            const bb = point.graphic && point.graphic.getBBox();\n            return bb ? {\n                xMin: point.plotX - bb.width / 2,\n                xMax: point.plotX + bb.width / 2,\n                yMin: point.plotY - bb.height / 2,\n                yMax: point.plotY + bb.height / 2\n            } : null;\n        }\n        /**\n         * Warn if using legacy options. Copy the options over. Note that this will\n         * still break if using the legacy options in chart.update, addSeries etc.\n         * @private\n         */\n        function warnLegacy(chart) {\n            if (chart.options.pathfinder ||\n                chart.series.reduce(function (acc, series) {\n                    if (series.options) {\n                        merge(true, (series.options.connectors = series.options.connectors ||\n                            {}), series.options.pathfinder);\n                    }\n                    return acc || series.options && series.options.pathfinder;\n                }, false)) {\n                merge(true, (chart.options.connectors = chart.options.connectors || {}), chart.options.pathfinder);\n                error('WARNING: Pathfinder options have been renamed. ' +\n                    'Use \"chart.connectors\" or \"series.connectors\" instead.');\n            }\n        }\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        var ConnectionComposition;\n        (function (ConnectionComposition) {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /** @private */\n            function compose(ChartClass, PathfinderClass, PointClass) {\n                const pointProto = PointClass.prototype;\n                if (!pointProto.getPathfinderAnchorPoint) {\n                    // Initialize Pathfinder for charts\n                    ChartClass.prototype.callbacks.push(function (chart) {\n                        const options = chart.options;\n                        if (options.connectors.enabled !== false) {\n                            warnLegacy(chart);\n                            this.pathfinder = new PathfinderClass(this);\n                            this.pathfinder.update(true); // First draw, defer render\n                        }\n                    });\n                    pointProto.getMarkerVector = pointGetMarkerVector;\n                    pointProto.getPathfinderAnchorPoint = pointGetPathfinderAnchorPoint;\n                    pointProto.getRadiansToVector = pointGetRadiansToVector;\n                    // Set default Pathfinder options\n                    setOptions(ConnectorsDefaults);\n                }\n            }\n            ConnectionComposition.compose = compose;\n            /**\n             * Get coordinates of anchor point for pathfinder connection.\n             *\n             * @private\n             * @function Highcharts.Point#getPathfinderAnchorPoint\n             *\n             * @param {Highcharts.ConnectorsMarkerOptions} markerOptions\n             *        Connection options for position on point.\n             *\n             * @return {Highcharts.PositionObject}\n             *         An object with x/y properties for the position. Coordinates are\n             *         in plot values, not relative to point.\n             */\n            function pointGetPathfinderAnchorPoint(markerOptions) {\n                const bb = getPointBB(this);\n                let x, y;\n                switch (markerOptions.align) { // eslint-disable-line default-case\n                    case 'right':\n                        x = 'xMax';\n                        break;\n                    case 'left':\n                        x = 'xMin';\n                }\n                switch (markerOptions.verticalAlign) { // eslint-disable-line default-case\n                    case 'top':\n                        y = 'yMin';\n                        break;\n                    case 'bottom':\n                        y = 'yMax';\n                }\n                return {\n                    x: x ? bb[x] : (bb.xMin + bb.xMax) / 2,\n                    y: y ? bb[y] : (bb.yMin + bb.yMax) / 2\n                };\n            }\n            /**\n             * Utility to get the angle from one point to another.\n             *\n             * @private\n             * @function Highcharts.Point#getRadiansToVector\n             *\n             * @param {Highcharts.PositionObject} v1\n             *        The first vector, as an object with x/y properties.\n             *\n             * @param {Highcharts.PositionObject} v2\n             *        The second vector, as an object with x/y properties.\n             *\n             * @return {number}\n             *         The angle in degrees\n             */\n            function pointGetRadiansToVector(v1, v2) {\n                let box;\n                if (!defined(v2)) {\n                    box = getPointBB(this);\n                    if (box) {\n                        v2 = {\n                            x: (box.xMin + box.xMax) / 2,\n                            y: (box.yMin + box.yMax) / 2\n                        };\n                    }\n                }\n                return Math.atan2(v2.y - v1.y, v1.x - v2.x);\n            }\n            /**\n             * Utility to get the position of the marker, based on the path angle and\n             * the marker's radius.\n             *\n             * @private\n             * @function Highcharts.Point#getMarkerVector\n             *\n             * @param {number} radians\n             *        The angle in radians from the point center to another vector.\n             *\n             * @param {number} markerRadius\n             *        The radius of the marker, to calculate the additional distance to\n             *        the center of the marker.\n             *\n             * @param {Object} anchor\n             *        The anchor point of the path and marker as an object with x/y\n             *        properties.\n             *\n             * @return {Object}\n             *         The marker vector as an object with x/y properties.\n             */\n            function pointGetMarkerVector(radians, markerRadius, anchor) {\n                const twoPI = Math.PI * 2.0, bb = getPointBB(this), rectWidth = bb.xMax - bb.xMin, rectHeight = bb.yMax - bb.yMin, rAtan = Math.atan2(rectHeight, rectWidth), rectHalfWidth = rectWidth / 2.0, rectHalfHeight = rectHeight / 2.0, rectHorizontalCenter = bb.xMin + rectHalfWidth, rectVerticalCenter = bb.yMin + rectHalfHeight, edgePoint = {\n                    x: rectHorizontalCenter,\n                    y: rectVerticalCenter\n                };\n                let theta = radians, tanTheta = 1, leftOrRightRegion = false, xFactor = 1, yFactor = 1;\n                while (theta < -Math.PI) {\n                    theta += twoPI;\n                }\n                while (theta > Math.PI) {\n                    theta -= twoPI;\n                }\n                tanTheta = Math.tan(theta);\n                if ((theta > -rAtan) && (theta <= rAtan)) {\n                    // Right side\n                    yFactor = -1;\n                    leftOrRightRegion = true;\n                }\n                else if (theta > rAtan && theta <= (Math.PI - rAtan)) {\n                    // Top side\n                    yFactor = -1;\n                }\n                else if (theta > (Math.PI - rAtan) || theta <= -(Math.PI - rAtan)) {\n                    // Left side\n                    xFactor = -1;\n                    leftOrRightRegion = true;\n                }\n                else {\n                    // Bottom side\n                    xFactor = -1;\n                }\n                // Correct the edgePoint according to the placement of the marker\n                if (leftOrRightRegion) {\n                    edgePoint.x += xFactor * (rectHalfWidth);\n                    edgePoint.y += yFactor * (rectHalfWidth) * tanTheta;\n                }\n                else {\n                    edgePoint.x += xFactor * (rectHeight / (2.0 * tanTheta));\n                    edgePoint.y += yFactor * (rectHalfHeight);\n                }\n                if (anchor.x !== rectHorizontalCenter) {\n                    edgePoint.x = anchor.x;\n                }\n                if (anchor.y !== rectVerticalCenter) {\n                    edgePoint.y = anchor.y;\n                }\n                return {\n                    x: edgePoint.x + (markerRadius * Math.cos(theta)),\n                    y: edgePoint.y - (markerRadius * Math.sin(theta))\n                };\n            }\n        })(ConnectionComposition || (ConnectionComposition = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ConnectionComposition;\n    });\n    _registerModule(_modules, 'Gantt/Pathfinder.js', [_modules['Gantt/Connection.js'], _modules['Gantt/PathfinderAlgorithms.js'], _modules['Gantt/PathfinderComposition.js'], _modules['Core/Series/Point.js'], _modules['Core/Utilities.js']], function (Connection, PathfinderAlgorithms, PathfinderComposition, Point, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Ã˜ystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { addEvent, defined, pick, splat } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const max = Math.max, min = Math.min;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get point bounding box using plotX/plotY and shapeArgs. If using\n         * graphic.getBBox() directly, the bbox will be affected by animation.\n         *\n         * @private\n         * @function\n         *\n         * @param {Highcharts.Point} point\n         *        The point to get BB of.\n         *\n         * @return {Highcharts.Dictionary<number>|null}\n         *         Result xMax, xMin, yMax, yMin.\n         */\n        function getPointBB(point) {\n            const shapeArgs = point.shapeArgs;\n            // Prefer using shapeArgs (columns)\n            if (shapeArgs) {\n                return {\n                    xMin: shapeArgs.x || 0,\n                    xMax: (shapeArgs.x || 0) + (shapeArgs.width || 0),\n                    yMin: shapeArgs.y || 0,\n                    yMax: (shapeArgs.y || 0) + (shapeArgs.height || 0)\n                };\n            }\n            // Otherwise use plotX/plotY and bb\n            const bb = point.graphic && point.graphic.getBBox();\n            return bb ? {\n                xMin: point.plotX - bb.width / 2,\n                xMax: point.plotX + bb.width / 2,\n                yMin: point.plotY - bb.height / 2,\n                yMax: point.plotY + bb.height / 2\n            } : null;\n        }\n        /**\n         * Compute smallest distance between two rectangles.\n         * @private\n         */\n        function calculateObstacleDistance(a, b, bbMargin) {\n            // Count the distance even if we are slightly off\n            const margin = pick(bbMargin, 10), yOverlap = a.yMax + margin > b.yMin - margin &&\n                a.yMin - margin < b.yMax + margin, xOverlap = a.xMax + margin > b.xMin - margin &&\n                a.xMin - margin < b.xMax + margin, xDistance = yOverlap ? (a.xMin > b.xMax ? a.xMin - b.xMax : b.xMin - a.xMax) : Infinity, yDistance = xOverlap ? (a.yMin > b.yMax ? a.yMin - b.yMax : b.yMin - a.yMax) : Infinity;\n            // If the rectangles collide, try recomputing with smaller margin.\n            // If they collide anyway, discard the obstacle.\n            if (xOverlap && yOverlap) {\n                return (margin ?\n                    calculateObstacleDistance(a, b, Math.floor(margin / 2)) :\n                    Infinity);\n            }\n            return min(xDistance, yDistance);\n        }\n        /**\n         * Calculate margin to place around obstacles for the pathfinder in pixels.\n         * Returns a minimum of 1 pixel margin.\n         *\n         * @private\n         * @function\n         *\n         * @param {Array<object>} obstacles\n         *        Obstacles to calculate margin from.\n         *\n         * @return {number}\n         *         The calculated margin in pixels. At least 1.\n         */\n        function calculateObstacleMargin(obstacles) {\n            const len = obstacles.length, distances = [];\n            let onstacleDistance;\n            // Go over all obstacles and compare them to the others.\n            for (let i = 0; i < len; ++i) {\n                // Compare to all obstacles ahead. We will already have compared this\n                // obstacle to the ones before.\n                for (let j = i + 1; j < len; ++j) {\n                    onstacleDistance =\n                        calculateObstacleDistance(obstacles[i], obstacles[j]);\n                    // TODO: Magic number 80\n                    if (onstacleDistance < 80) { // Ignore large distances\n                        distances.push(onstacleDistance);\n                    }\n                }\n            }\n            // Ensure we always have at least one value, even in very spacious charts\n            distances.push(80);\n            return max(Math.floor(distances.sort(function (a, b) {\n                return (a - b);\n            })[\n            // Discard first 10% of the relevant distances, and then grab\n            // the smallest one.\n            Math.floor(distances.length / 10)] / 2 - 1 // Divide the distance by 2 and subtract 1.\n            ), 1 // 1 is the minimum margin\n            );\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The Pathfinder class.\n         *\n         * @private\n         * @class\n         * @name Highcharts.Pathfinder\n         *\n         * @param {Highcharts.Chart} chart\n         *        The chart to operate on.\n         */\n        class Pathfinder {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            static compose(ChartClass, PointClass) {\n                PathfinderComposition.compose(ChartClass, Pathfinder, PointClass);\n            }\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart) {\n                this.init(chart);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Initialize the Pathfinder object.\n             *\n             * @function Highcharts.Pathfinder#init\n             *\n             * @param {Highcharts.Chart} chart\n             *        The chart context.\n             */\n            init(chart) {\n                // Initialize pathfinder with chart context\n                this.chart = chart;\n                // Init connection reference list\n                this.connections = [];\n                // Recalculate paths/obstacles on chart redraw\n                addEvent(chart, 'redraw', function () {\n                    this.pathfinder.update();\n                });\n            }\n            /**\n             * Update Pathfinder connections from scratch.\n             *\n             * @function Highcharts.Pathfinder#update\n             *\n             * @param {boolean} [deferRender]\n             *        Whether or not to defer rendering of connections until\n             *        series.afterAnimate event has fired. Used on first render.\n             */\n            update(deferRender) {\n                const chart = this.chart, pathfinder = this, oldConnections = pathfinder.connections;\n                // Rebuild pathfinder connections from options\n                pathfinder.connections = [];\n                chart.series.forEach(function (series) {\n                    if (series.visible && !series.options.isInternal) {\n                        series.points.forEach(function (point) {\n                            const ganttPointOptions = point.options;\n                            // For Gantt series the connect could be\n                            // defined as a dependency\n                            if (ganttPointOptions && ganttPointOptions.dependency) {\n                                ganttPointOptions.connect = ganttPointOptions\n                                    .dependency;\n                            }\n                            const connects = (point.options?.connect &&\n                                splat(point.options.connect));\n                            let to;\n                            if (point.visible && point.isInside !== false && connects) {\n                                connects.forEach(function (connect) {\n                                    to = chart.get(typeof connect === 'string' ?\n                                        connect : connect.to);\n                                    if (to instanceof Point &&\n                                        to.series.visible &&\n                                        to.visible &&\n                                        to.isInside !== false) {\n                                        // Add new connection\n                                        pathfinder.connections.push(new Connection(point, // From\n                                        to, typeof connect === 'string' ?\n                                            {} :\n                                            connect));\n                                    }\n                                });\n                            }\n                        });\n                    }\n                });\n                // Clear connections that should not be updated, and move old info over\n                // to new connections.\n                for (let j = 0, k, found, lenOld = oldConnections.length, lenNew = pathfinder.connections.length; j < lenOld; ++j) {\n                    found = false;\n                    const oldCon = oldConnections[j];\n                    for (k = 0; k < lenNew; ++k) {\n                        const newCon = pathfinder.connections[k];\n                        if ((oldCon.options && oldCon.options.type) ===\n                            (newCon.options && newCon.options.type) &&\n                            oldCon.fromPoint === newCon.fromPoint &&\n                            oldCon.toPoint === newCon.toPoint) {\n                            newCon.graphics = oldCon.graphics;\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        oldCon.destroy();\n                    }\n                }\n                // Clear obstacles to force recalculation. This must be done on every\n                // redraw in case positions have changed. Recalculation is handled in\n                // Connection.getPath on demand.\n                delete this.chartObstacles;\n                delete this.lineObstacles;\n                // Draw the pending connections\n                pathfinder.renderConnections(deferRender);\n            }\n            /**\n             * Draw the chart's connecting paths.\n             *\n             * @function Highcharts.Pathfinder#renderConnections\n             *\n             * @param {boolean} [deferRender]\n             *        Whether or not to defer render until series animation is finished.\n             *        Used on first render.\n             */\n            renderConnections(deferRender) {\n                if (deferRender) {\n                    // Render after series are done animating\n                    this.chart.series.forEach(function (series) {\n                        const render = function () {\n                            // Find pathfinder connections belonging to this series\n                            // that haven't rendered, and render them now.\n                            const pathfinder = series.chart.pathfinder, conns = pathfinder && pathfinder.connections || [];\n                            conns.forEach(function (connection) {\n                                if (connection.fromPoint &&\n                                    connection.fromPoint.series === series) {\n                                    connection.render();\n                                }\n                            });\n                            if (series.pathfinderRemoveRenderEvent) {\n                                series.pathfinderRemoveRenderEvent();\n                                delete series.pathfinderRemoveRenderEvent;\n                            }\n                        };\n                        if (series.options.animation === false) {\n                            render();\n                        }\n                        else {\n                            series.pathfinderRemoveRenderEvent = addEvent(series, 'afterAnimate', render);\n                        }\n                    });\n                }\n                else {\n                    // Go through connections and render them\n                    this.connections.forEach(function (connection) {\n                        connection.render();\n                    });\n                }\n            }\n            /**\n             * Get obstacles for the points in the chart. Does not include connecting\n             * lines from Pathfinder. Applies algorithmMargin to the obstacles.\n             *\n             * @function Highcharts.Pathfinder#getChartObstacles\n             *\n             * @param {Object} options\n             *        Options for the calculation. Currently only\n             *        options.algorithmMargin.\n             *\n             * @return {Array<object>}\n             *         An array of calculated obstacles. Each obstacle is defined as an\n             *         object with xMin, xMax, yMin and yMax properties.\n             */\n            getChartObstacles(options) {\n                const series = this.chart.series, margin = pick(options.algorithmMargin, 0);\n                let obstacles = [], calculatedMargin;\n                for (let i = 0, sLen = series.length; i < sLen; ++i) {\n                    if (series[i].visible && !series[i].options.isInternal) {\n                        for (let j = 0, pLen = series[i].points.length, bb, point; j < pLen; ++j) {\n                            point = series[i].points[j];\n                            if (point.visible) {\n                                bb = getPointBB(point);\n                                if (bb) {\n                                    obstacles.push({\n                                        xMin: bb.xMin - margin,\n                                        xMax: bb.xMax + margin,\n                                        yMin: bb.yMin - margin,\n                                        yMax: bb.yMax + margin\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n                // Sort obstacles by xMin for optimization\n                obstacles = obstacles.sort(function (a, b) {\n                    return a.xMin - b.xMin;\n                });\n                // Add auto-calculated margin if the option is not defined\n                if (!defined(options.algorithmMargin)) {\n                    calculatedMargin =\n                        options.algorithmMargin =\n                            calculateObstacleMargin(obstacles);\n                    obstacles.forEach(function (obstacle) {\n                        obstacle.xMin -= calculatedMargin;\n                        obstacle.xMax += calculatedMargin;\n                        obstacle.yMin -= calculatedMargin;\n                        obstacle.yMax += calculatedMargin;\n                    });\n                }\n                return obstacles;\n            }\n            /**\n             * Utility function to get metrics for obstacles:\n             * - Widest obstacle width\n             * - Tallest obstacle height\n             *\n             * @function Highcharts.Pathfinder#getObstacleMetrics\n             *\n             * @param {Array<object>} obstacles\n             *        An array of obstacles to inspect.\n             *\n             * @return {Object}\n             *         The calculated metrics, as an object with maxHeight and maxWidth\n             *         properties.\n             */\n            getObstacleMetrics(obstacles) {\n                let maxWidth = 0, maxHeight = 0, width, height, i = obstacles.length;\n                while (i--) {\n                    width = obstacles[i].xMax - obstacles[i].xMin;\n                    height = obstacles[i].yMax - obstacles[i].yMin;\n                    if (maxWidth < width) {\n                        maxWidth = width;\n                    }\n                    if (maxHeight < height) {\n                        maxHeight = height;\n                    }\n                }\n                return {\n                    maxHeight: maxHeight,\n                    maxWidth: maxWidth\n                };\n            }\n            /**\n             * Utility to get which direction to start the pathfinding algorithm\n             * (X vs Y), calculated from a set of marker options.\n             *\n             * @function Highcharts.Pathfinder#getAlgorithmStartDirection\n             *\n             * @param {Highcharts.ConnectorsMarkerOptions} markerOptions\n             *        Marker options to calculate from.\n             *\n             * @return {boolean}\n             *         Returns true for X, false for Y, and undefined for autocalculate.\n             */\n            getAlgorithmStartDirection(markerOptions) {\n                const xCenter = markerOptions.align !== 'left' &&\n                    markerOptions.align !== 'right', yCenter = markerOptions.verticalAlign !== 'top' &&\n                    markerOptions.verticalAlign !== 'bottom';\n                return xCenter ?\n                    (yCenter ? void 0 : false) : // When x is centered\n                    (yCenter ? true : void 0); // When x is off-center\n            }\n        }\n        /**\n         * @name Highcharts.Pathfinder#algorithms\n         * @type {Highcharts.Dictionary<Function>}\n         */\n        Pathfinder.prototype.algorithms = PathfinderAlgorithms;\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * The default pathfinder algorithm to use for a chart. It is possible to define\n         * your own algorithms by adding them to the\n         * `Highcharts.Pathfinder.prototype.algorithms`\n         * object before the chart has been created.\n         *\n         * The default algorithms are as follows:\n         *\n         * `straight`:      Draws a straight line between the connecting\n         *                  points. Does not avoid other points when drawing.\n         *\n         * `simpleConnect`: Finds a path between the points using right angles\n         *                  only. Takes only starting/ending points into\n         *                  account, and will not avoid other points.\n         *\n         * `fastAvoid`:     Finds a path between the points using right angles\n         *                  only. Will attempt to avoid other points, but its\n         *                  focus is performance over accuracy. Works well with\n         *                  less dense datasets.\n         *\n         * @typedef {\"fastAvoid\"|\"simpleConnect\"|\"straight\"|string} Highcharts.PathfinderTypeValue\n         */\n        ''; // Keeps doclets above in JS file\n\n        return Pathfinder;\n    });\n    _registerModule(_modules, 'masters/modules/pathfinder.src.js', [_modules['Core/Globals.js'], _modules['Gantt/Pathfinder.js'], _modules['Extensions/ArrowSymbols.js']], function (Highcharts, Pathfinder, ArrowSymbols) {\n\n        const G = Highcharts;\n        G.Pathfinder = G.Pathfinder || Pathfinder;\n        ArrowSymbols.compose(G.SVGRenderer);\n        G.Pathfinder.compose(G.Chart, G.Point);\n\n        return Highcharts;\n    });\n    _registerModule(_modules, 'Extensions/StaticScale.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2016-2024 Torstein Honsi, Lars Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { addEvent, defined, isNumber, pick } = U;\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        /** @private */\n        function compose(AxisClass, ChartClass) {\n            const chartProto = ChartClass.prototype;\n            if (!chartProto.adjustHeight) {\n                addEvent(AxisClass, 'afterSetOptions', onAxisAfterSetOptions);\n                chartProto.adjustHeight = chartAdjustHeight;\n                addEvent(ChartClass, 'render', chartProto.adjustHeight);\n            }\n        }\n        /** @private */\n        function onAxisAfterSetOptions() {\n            const chartOptions = this.chart.options.chart;\n            if (!this.horiz &&\n                isNumber(this.options.staticScale) &&\n                (!chartOptions.height ||\n                    (chartOptions.scrollablePlotArea &&\n                        chartOptions.scrollablePlotArea.minHeight))) {\n                this.staticScale = this.options.staticScale;\n            }\n        }\n        /** @private */\n        function chartAdjustHeight() {\n            const chart = this;\n            if (chart.redrawTrigger !== 'adjustHeight') {\n                for (const axis of (chart.axes || [])) {\n                    const chart = axis.chart, animate = !!chart.initiatedScale &&\n                        chart.options.animation, staticScale = axis.options.staticScale;\n                    if (axis.staticScale && defined(axis.min)) {\n                        let height = pick(axis.brokenAxis && axis.brokenAxis.unitLength, axis.max + axis.tickInterval - axis.min) * staticScale;\n                        // Minimum height is 1 x staticScale.\n                        height = Math.max(height, staticScale);\n                        let diff = height - chart.plotHeight;\n                        if (!chart.scrollablePixelsY && Math.abs(diff) >= 1) {\n                            chart.plotHeight = height;\n                            chart.redrawTrigger = 'adjustHeight';\n                            chart.setSize(void 0, chart.chartHeight + diff, animate);\n                        }\n                        // Make sure clip rects have the right height before initial\n                        // animation.\n                        axis.series.forEach(function (series) {\n                            const clipRect = series.sharedClipKey &&\n                                chart.sharedClips[series.sharedClipKey];\n                            if (clipRect) {\n                                clipRect.attr(chart.inverted ? {\n                                    width: chart.plotHeight\n                                } : {\n                                    height: chart.plotHeight\n                                });\n                            }\n                        });\n                    }\n                }\n                this.initiatedScale = true;\n            }\n            this.redrawTrigger = null;\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const StaticScale = {\n            compose\n        };\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * For vertical axes only. Setting the static scale ensures that each tick unit\n         * is translated into a fixed pixel height. For example, setting the static\n         * scale to 24 results in each Y axis category taking up 24 pixels, and the\n         * height of the chart adjusts. Adding or removing items will make the chart\n         * resize.\n         *\n         * @sample gantt/xrange-series/demo/\n         *         X-range series with static scale\n         *\n         * @type      {number}\n         * @default   50\n         * @since     6.2.0\n         * @product   gantt\n         * @apioption yAxis.staticScale\n         */\n        ''; // keeps doclets above in JS file\n\n        return StaticScale;\n    });\n    _registerModule(_modules, 'masters/modules/static-scale.src.js', [_modules['Core/Globals.js'], _modules['Extensions/StaticScale.js']], function (Highcharts, StaticScale) {\n\n        const G = Highcharts;\n        StaticScale.compose(G.Axis, G.Chart);\n\n        return Highcharts;\n    });\n    _registerModule(_modules, 'Series/XRange/XRangeSeriesDefaults.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  X-range series module\n         *\n         *  (c) 2010-2024 Torstein Honsi, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { correctFloat, isNumber, isObject } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * The X-range series displays ranges on the X axis, typically time\n         * intervals with a start and end date.\n         *\n         * @sample {highcharts} highcharts/demo/x-range/\n         *         X-range\n         * @sample {highcharts} highcharts/css/x-range/\n         *         Styled mode X-range\n         * @sample {highcharts} highcharts/chart/inverted-xrange/\n         *         Inverted X-range\n         *\n         * @extends      plotOptions.column\n         * @since        6.0.0\n         * @product      highcharts highstock gantt\n         * @excluding    boostThreshold, crisp, cropThreshold, depth, edgeColor,\n         *               edgeWidth, findNearestPointBy, getExtremesFromAll,\n         *               negativeColor, pointInterval, pointIntervalUnit,\n         *               pointPlacement, pointRange, pointStart, softThreshold,\n         *               stacking, threshold, data, dataSorting, boostBlending\n         * @requires     modules/xrange\n         * @optionparent plotOptions.xrange\n         */\n        const XRangeSeriesDefaults = {\n            /**\n             * A partial fill for each point, typically used to visualize how much\n             * of a task is performed. The partial fill object can be set either on\n             * series or point level.\n             *\n             * @sample {highcharts} highcharts/demo/x-range\n             *         X-range with partial fill\n             *\n             * @product   highcharts highstock gantt\n             * @apioption plotOptions.xrange.partialFill\n             */\n            /**\n             * The fill color to be used for partial fills. Defaults to a darker\n             * shade of the point color.\n             *\n             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             * @product   highcharts highstock gantt\n             * @apioption plotOptions.xrange.partialFill.fill\n             */\n            /**\n             * A partial fill for each point, typically used to visualize how much\n             * of a task is performed. See [completed](series.gantt.data.completed).\n             *\n             * @sample gantt/demo/progress-indicator\n             *         Gantt with progress indicator\n             *\n             * @product   gantt\n             * @apioption plotOptions.gantt.partialFill\n             */\n            /**\n             * In an X-range series, this option makes all points of the same Y-axis\n             * category the same color.\n             */\n            colorByPoint: true,\n            dataLabels: {\n                formatter: function () {\n                    let point = this.point, amount = point.partialFill;\n                    if (isObject(amount)) {\n                        amount = amount.amount;\n                    }\n                    if (isNumber(amount) && amount > 0) {\n                        return correctFloat(amount * 100) + '%';\n                    }\n                },\n                inside: true,\n                verticalAlign: 'middle',\n                style: {\n                    whiteSpace: 'nowrap'\n                }\n            },\n            tooltip: {\n                headerFormat: '<span style=\"font-size: 0.8em\">{point.x} - {point.x2}</span><br/>',\n                pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.yCategory}</b><br/>'\n            },\n            borderRadius: 3,\n            pointRange: 0\n        };\n        /* *\n         *\n         *  Export Default\n         *\n         * */\n        /* *\n         *\n         * API Options\n         *\n         * */\n        /**\n         * An `xrange` series. If the [type](#series.xrange.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.xrange\n         * @excluding boostThreshold, crisp, cropThreshold, depth, edgeColor, edgeWidth,\n         *            findNearestPointBy, getExtremesFromAll, negativeColor,\n         *            pointInterval, pointIntervalUnit, pointPlacement, pointRange,\n         *            pointStart, softThreshold, stacking, threshold, dataSorting,\n         *            boostBlending\n         * @product   highcharts highstock gantt\n         * @requires  modules/xrange\n         * @apioption series.xrange\n         */\n        /**\n         * An array of data points for the series. For the `xrange` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of objects with named values. The objects are point configuration\n         *    objects as seen below.\n         *    ```js\n         *    data: [{\n         *        x: Date.UTC(2017, 0, 1),\n         *        x2: Date.UTC(2017, 0, 3),\n         *        name: \"Test\",\n         *        y: 0,\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: Date.UTC(2017, 0, 4),\n         *        x2: Date.UTC(2017, 0, 5),\n         *        name: \"Deploy\",\n         *        y: 1,\n         *        color: \"#FF0000\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @declare   Highcharts.XrangePointOptionsObject\n         * @type      {Array<*>}\n         * @extends   series.line.data\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data\n         */\n        /**\n         * The starting X value of the range point.\n         *\n         * @sample {highcharts} highcharts/demo/x-range\n         *         X-range\n         *\n         * @type      {number}\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data.x\n         */\n        /**\n         * The ending X value of the range point.\n         *\n         * @sample {highcharts} highcharts/demo/x-range\n         *         X-range\n         *\n         * @type      {number}\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data.x2\n         */\n        /**\n         * The Y value of the range point.\n         *\n         * @sample {highcharts} highcharts/demo/x-range\n         *         X-range\n         *\n         * @type      {number}\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data.y\n         */\n        /**\n         * A partial fill for each point, typically used to visualize how much of\n         * a task is performed. The partial fill object can be set either on series\n         * or point level.\n         *\n         * @sample {highcharts} highcharts/demo/x-range\n         *         X-range with partial fill\n         *\n         * @declare   Highcharts.XrangePointPartialFillOptionsObject\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data.partialFill\n         */\n        /**\n         * The amount of the X-range point to be filled. Values can be 0-1 and are\n         * converted to percentages in the default data label formatter.\n         *\n         * @type      {number}\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data.partialFill.amount\n         */\n        /**\n         * The fill color to be used for partial fills. Defaults to a darker shade\n         * of the point color.\n         *\n         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data.partialFill.fill\n         */\n        (''); // adds doclets above to transpiled file\n\n        return XRangeSeriesDefaults;\n    });\n    _registerModule(_modules, 'Series/XRange/XRangePoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (SeriesRegistry, U) {\n        /* *\n         *\n         *  X-range series module\n         *\n         *  (c) 2010-2024 Torstein Honsi, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { column: { prototype: { pointClass: ColumnPoint } } } = SeriesRegistry.seriesTypes;\n        const { extend } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class XRangePoint extends ColumnPoint {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            /**\n             * Return color of a point based on its category.\n             *\n             * @private\n             * @function getColorByCategory\n             *\n             * @param {object} series\n             *        The series which the point belongs to.\n             *\n             * @param {object} point\n             *        The point to calculate its color for.\n             *\n             * @return {object}\n             *         Returns an object containing the properties color and colorIndex.\n             */\n            static getColorByCategory(series, point) {\n                const colors = series.options.colors || series.chart.options.colors, colorCount = colors ?\n                    colors.length :\n                    series.chart.options.chart.colorCount, colorIndex = point.y % colorCount, color = colors && colors[colorIndex];\n                return {\n                    colorIndex: colorIndex,\n                    color: color\n                };\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            resolveColor() {\n                const series = this.series;\n                if (series.options.colorByPoint && !this.options.color) {\n                    const colorByPoint = XRangePoint.getColorByCategory(series, this);\n                    if (!series.chart.styledMode) {\n                        this.color = colorByPoint.color;\n                    }\n                    if (!this.options.colorIndex) {\n                        this.colorIndex = colorByPoint.colorIndex;\n                    }\n                }\n                else {\n                    this.color = this.options.color || series.color;\n                }\n            }\n            /**\n             * Extend init to have y default to 0.\n             *\n             * @private\n             */\n            constructor(series, options) {\n                super(series, options);\n                if (!this.y) {\n                    this.y = 0;\n                }\n            }\n            /**\n             * @private\n             */\n            setState() {\n                super.setState.apply(this, arguments);\n                this.series.drawPoint(this, this.series.getAnimationVerb());\n            }\n            /**\n             * Add x2 and yCategory to the available properties for tooltip formats.\n             *\n             * @private\n             */\n            getLabelConfig() {\n                const cfg = super.getLabelConfig.call(this), yCats = this.series.yAxis.categories;\n                cfg.x2 = this.x2;\n                cfg.yCategory = this.yCategory = yCats && yCats[this.y];\n                // Use 'category' as 'key' to ensure tooltip datetime formatting.\n                // Use 'name' only when 'category' is undefined.\n                cfg.key = this.category || this.name;\n                return cfg;\n            }\n            /**\n             * @private\n             */\n            isValid() {\n                return typeof this.x === 'number' &&\n                    typeof this.x2 === 'number';\n            }\n        }\n        extend(XRangePoint.prototype, {\n            ttBelow: false,\n            tooltipDateKeys: ['x', 'x2']\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * The ending X value of the range point.\n         * @name Highcharts.Point#x2\n         * @type {number|undefined}\n         * @requires modules/xrange\n         */\n        /**\n         * Extend applyOptions so that `colorByPoint` for x-range means that one\n         * color is applied per Y axis category.\n         *\n         * @private\n         * @function Highcharts.Point#applyOptions\n         *\n         * @return {Highcharts.Series}\n         */\n        /**\n         * @interface Highcharts.PointOptionsObject in parts/Point.ts\n         */ /**\n        * The ending X value of the range point.\n        * @name Highcharts.PointOptionsObject#x2\n        * @type {number|undefined}\n        * @requires modules/xrange\n        */\n        (''); // keeps doclets above in JS file\n\n        return XRangePoint;\n    });\n    _registerModule(_modules, 'Series/XRange/XRangeSeries.js', [_modules['Core/Globals.js'], _modules['Core/Color/Color.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js'], _modules['Series/XRange/XRangeSeriesDefaults.js'], _modules['Series/XRange/XRangePoint.js']], function (H, Color, SeriesRegistry, U, XRangeSeriesDefaults, XRangePoint) {\n        /* *\n         *\n         *  X-range series module\n         *\n         *  (c) 2010-2024 Torstein Honsi, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { composed, noop } = H;\n        const { parse: color } = Color;\n        const { column: ColumnSeries } = SeriesRegistry.seriesTypes;\n        const { addEvent, clamp, defined, extend, find, isNumber, isObject, merge, pick, pushUnique, relativeLength } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Max x2 should be considered in xAxis extremes\n         * @private\n         */\n        function onAxisAfterGetSeriesExtremes() {\n            let dataMax, modMax;\n            if (this.isXAxis) {\n                dataMax = pick(this.dataMax, -Number.MAX_VALUE);\n                for (const series of this.series) {\n                    if (series.x2Data) {\n                        for (const val of series.x2Data) {\n                            if (val && val > dataMax) {\n                                dataMax = val;\n                                modMax = true;\n                            }\n                        }\n                    }\n                }\n                if (modMax) {\n                    this.dataMax = dataMax;\n                }\n            }\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.xrange\n         *\n         * @augments Highcharts.Series\n         */\n        class XRangeSeries extends ColumnSeries {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            static compose(AxisClass) {\n                if (pushUnique(composed, 'Series.XRange')) {\n                    addEvent(AxisClass, 'afterGetSeriesExtremes', onAxisAfterGetSeriesExtremes);\n                }\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            init() {\n                super.init.apply(this, arguments);\n                this.options.stacking = void 0; // #13161\n            }\n            /**\n             * Borrow the column series metrics, but with swapped axes. This gives\n             * free access to features like groupPadding, grouping, pointWidth etc.\n             * @private\n             */\n            getColumnMetrics() {\n                const swapAxes = () => {\n                    for (const series of this.chart.series) {\n                        const xAxis = series.xAxis;\n                        series.xAxis = series.yAxis;\n                        series.yAxis = xAxis;\n                    }\n                };\n                swapAxes();\n                const metrics = super.getColumnMetrics();\n                swapAxes();\n                return metrics;\n            }\n            /**\n             * Override cropData to show a point where x or x2 is outside visible range,\n             * but one of them is inside.\n             * @private\n             */\n            cropData(xData, yData, min, max) {\n                // Replace xData with x2Data to find the appropriate cropStart\n                const crop = super.cropData(this.x2Data, yData, min, max);\n                // Re-insert the cropped xData\n                crop.xData = xData.slice(crop.start, crop.end);\n                return crop;\n            }\n            /**\n             * Finds the index of an existing point that matches the given point\n             * options.\n             *\n             * @private\n             *\n             * @param {Highcharts.XRangePointOptions} options\n             *        The options of the point.\n             *\n             * @return {number|undefined}\n             *         Returns index of a matching point, or undefined if no match is\n             *         found.\n             */\n            findPointIndex(options) {\n                const { cropStart, points } = this;\n                const { id } = options;\n                let pointIndex;\n                if (id) {\n                    const point = find(points, (point) => point.id === id);\n                    pointIndex = point ? point.index : void 0;\n                }\n                if (typeof pointIndex === 'undefined') {\n                    const point = find(points, (point) => (point.x === options.x &&\n                        point.x2 === options.x2 &&\n                        !point.touched));\n                    pointIndex = point ? point.index : void 0;\n                }\n                // Reduce pointIndex if data is cropped\n                if (this.cropped &&\n                    isNumber(pointIndex) &&\n                    isNumber(cropStart) &&\n                    pointIndex >= cropStart) {\n                    pointIndex -= cropStart;\n                }\n                return pointIndex;\n            }\n            alignDataLabel(point) {\n                const oldPlotX = point.plotX;\n                point.plotX = pick(point.dlBox && point.dlBox.centerX, point.plotX);\n                if (point.dataLabel && point.shapeArgs?.width) {\n                    point.dataLabel.css({\n                        width: `${point.shapeArgs.width}px`\n                    });\n                }\n                super.alignDataLabel.apply(this, arguments);\n                point.plotX = oldPlotX;\n            }\n            /**\n             * @private\n             */\n            translatePoint(point) {\n                const xAxis = this.xAxis, yAxis = this.yAxis, metrics = this.columnMetrics, options = this.options, minPointLength = options.minPointLength || 0, oldColWidth = (point.shapeArgs && point.shapeArgs.width || 0) / 2, seriesXOffset = this.pointXOffset = metrics.offset, posX = pick(point.x2, point.x + (point.len || 0)), borderRadius = options.borderRadius, plotTop = this.chart.plotTop, plotLeft = this.chart.plotLeft;\n                let plotX = point.plotX, plotX2 = xAxis.translate(posX, 0, 0, 0, 1);\n                const length = Math.abs(plotX2 - plotX), inverted = this.chart.inverted, borderWidth = pick(options.borderWidth, 1), crisper = borderWidth % 2 / 2;\n                let widthDifference, partialFill, yOffset = metrics.offset, pointHeight = Math.round(metrics.width), dlLeft, dlRight, dlWidth, clipRectWidth;\n                if (minPointLength) {\n                    widthDifference = minPointLength - length;\n                    if (widthDifference < 0) {\n                        widthDifference = 0;\n                    }\n                    plotX -= widthDifference / 2;\n                    plotX2 += widthDifference / 2;\n                }\n                plotX = Math.max(plotX, -10);\n                plotX2 = clamp(plotX2, -10, xAxis.len + 10);\n                // Handle individual pointWidth\n                if (defined(point.options.pointWidth)) {\n                    yOffset -= ((Math.ceil(point.options.pointWidth) - pointHeight) / 2);\n                    pointHeight = Math.ceil(point.options.pointWidth);\n                }\n                // Apply pointPlacement to the Y axis\n                if (options.pointPlacement &&\n                    isNumber(point.plotY) &&\n                    yAxis.categories) {\n                    point.plotY = yAxis.translate(point.y, 0, 1, 0, 1, options.pointPlacement);\n                }\n                const x = Math.floor(Math.min(plotX, plotX2)) + crisper, x2 = Math.floor(Math.max(plotX, plotX2)) + crisper, width = x2 - x;\n                const r = Math.min(relativeLength((typeof borderRadius === 'object' ?\n                    borderRadius.radius :\n                    borderRadius || 0), pointHeight), Math.min(width, pointHeight) / 2);\n                const shapeArgs = {\n                    x,\n                    y: Math.floor(point.plotY + yOffset) + crisper,\n                    width,\n                    height: pointHeight,\n                    r\n                };\n                point.shapeArgs = shapeArgs;\n                // Move tooltip to default position\n                if (!inverted) {\n                    point.tooltipPos[0] -= oldColWidth +\n                        seriesXOffset -\n                        shapeArgs.width / 2;\n                }\n                else {\n                    point.tooltipPos[1] += seriesXOffset +\n                        oldColWidth;\n                }\n                // Align data labels inside the shape and inside the plot area\n                dlLeft = shapeArgs.x;\n                dlRight = dlLeft + shapeArgs.width;\n                if (dlLeft < 0 || dlRight > xAxis.len) {\n                    dlLeft = clamp(dlLeft, 0, xAxis.len);\n                    dlRight = clamp(dlRight, 0, xAxis.len);\n                    dlWidth = dlRight - dlLeft;\n                    point.dlBox = merge(shapeArgs, {\n                        x: dlLeft,\n                        width: dlRight - dlLeft,\n                        centerX: dlWidth ? dlWidth / 2 : null\n                    });\n                }\n                else {\n                    point.dlBox = null;\n                }\n                // Tooltip position\n                const tooltipPos = point.tooltipPos;\n                const xIndex = !inverted ? 0 : 1;\n                const yIndex = !inverted ? 1 : 0;\n                const tooltipYOffset = (this.columnMetrics ?\n                    this.columnMetrics.offset :\n                    -metrics.width / 2);\n                // Centering tooltip position (#14147)\n                if (inverted) {\n                    tooltipPos[xIndex] += shapeArgs.width / 2;\n                }\n                else {\n                    tooltipPos[xIndex] = clamp(tooltipPos[xIndex] +\n                        (xAxis.reversed ? -1 : 0) * shapeArgs.width, xAxis.left - plotLeft, xAxis.left + xAxis.len - plotLeft - 1);\n                }\n                tooltipPos[yIndex] = clamp(tooltipPos[yIndex] + ((inverted ? -1 : 1) * tooltipYOffset), yAxis.top - plotTop, yAxis.top + yAxis.len - plotTop - 1);\n                // Add a partShapeArgs to the point, based on the shapeArgs property\n                partialFill = point.partialFill;\n                if (partialFill) {\n                    // Get the partial fill amount\n                    if (isObject(partialFill)) {\n                        partialFill = partialFill.amount;\n                    }\n                    // If it was not a number, assume 0\n                    if (!isNumber(partialFill)) {\n                        partialFill = 0;\n                    }\n                    point.partShapeArgs = merge(shapeArgs);\n                    clipRectWidth = Math.max(Math.round(length * partialFill + point.plotX -\n                        plotX), 0);\n                    point.clipRectArgs = {\n                        x: xAxis.reversed ? // #10717\n                            shapeArgs.x + length - clipRectWidth :\n                            shapeArgs.x,\n                        y: shapeArgs.y,\n                        width: clipRectWidth,\n                        height: shapeArgs.height\n                    };\n                }\n            }\n            /**\n             * @private\n             */\n            translate() {\n                super.translate.apply(this, arguments);\n                for (const point of this.points) {\n                    this.translatePoint(point);\n                }\n            }\n            /**\n             * Draws a single point in the series. Needed for partial fill.\n             *\n             * This override turns point.graphic into a group containing the\n             * original graphic and an overlay displaying the partial fill.\n             *\n             * @private\n             *\n             * @param {Highcharts.Point} point\n             *        An instance of Point in the series.\n             *\n             * @param {\"animate\"|\"attr\"} verb\n             *        'animate' (animates changes) or 'attr' (sets options)\n             */\n            drawPoint(point, verb) {\n                const seriesOpts = this.options, renderer = this.chart.renderer, type = point.shapeType, shapeArgs = point.shapeArgs, partShapeArgs = point.partShapeArgs, clipRectArgs = point.clipRectArgs, pointState = point.state, stateOpts = (seriesOpts.states[pointState || 'normal'] ||\n                    {}), pointStateVerb = typeof pointState === 'undefined' ?\n                    'attr' : verb, pointAttr = this.pointAttribs(point, pointState), animation = pick(this.chart.options.chart.animation, stateOpts.animation);\n                let graphic = point.graphic, pfOptions = point.partialFill;\n                if (!point.isNull && point.visible !== false) {\n                    // Original graphic\n                    if (graphic) { // update\n                        graphic.rect[verb](shapeArgs);\n                    }\n                    else {\n                        point.graphic = graphic = renderer.g('point')\n                            .addClass(point.getClassName())\n                            .add(point.group || this.group);\n                        graphic.rect = renderer[type](merge(shapeArgs))\n                            .addClass(point.getClassName())\n                            .addClass('highcharts-partfill-original')\n                            .add(graphic);\n                    }\n                    // Partial fill graphic\n                    if (partShapeArgs) {\n                        if (graphic.partRect) {\n                            graphic.partRect[verb](merge(partShapeArgs));\n                            graphic.partialClipRect[verb](merge(clipRectArgs));\n                        }\n                        else {\n                            graphic.partialClipRect = renderer.clipRect(clipRectArgs.x, clipRectArgs.y, clipRectArgs.width, clipRectArgs.height);\n                            graphic.partRect =\n                                renderer[type](partShapeArgs)\n                                    .addClass('highcharts-partfill-overlay')\n                                    .add(graphic)\n                                    .clip(graphic.partialClipRect);\n                        }\n                    }\n                    // Presentational\n                    if (!this.chart.styledMode) {\n                        graphic\n                            .rect[verb](pointAttr, animation)\n                            .shadow(seriesOpts.shadow);\n                        if (partShapeArgs) {\n                            // Ensure pfOptions is an object\n                            if (!isObject(pfOptions)) {\n                                pfOptions = {};\n                            }\n                            if (isObject(seriesOpts.partialFill)) {\n                                pfOptions = merge(seriesOpts.partialFill, pfOptions);\n                            }\n                            const fill = (pfOptions.fill ||\n                                color(pointAttr.fill).brighten(-0.3).get() ||\n                                color(point.color || this.color)\n                                    .brighten(-0.3).get());\n                            pointAttr.fill = fill;\n                            graphic\n                                .partRect[pointStateVerb](pointAttr, animation)\n                                .shadow(seriesOpts.shadow);\n                        }\n                    }\n                }\n                else if (graphic) {\n                    point.graphic = graphic.destroy(); // #1269\n                }\n            }\n            /**\n             * @private\n             */\n            drawPoints() {\n                const verb = this.getAnimationVerb();\n                // Draw the columns\n                for (const point of this.points) {\n                    this.drawPoint(point, verb);\n                }\n            }\n            /**\n             * Returns \"animate\", or \"attr\" if the number of points is above the\n             * animation limit.\n             *\n             * @private\n             */\n            getAnimationVerb() {\n                return (this.chart.pointCount < (this.options.animationLimit || 250) ?\n                    'animate' :\n                    'attr');\n            }\n            /**\n             * @private\n             */\n            isPointInside(point) {\n                const shapeArgs = point.shapeArgs, plotX = point.plotX, plotY = point.plotY;\n                if (!shapeArgs) {\n                    return super.isPointInside.apply(this, arguments);\n                }\n                const isInside = typeof plotX !== 'undefined' &&\n                    typeof plotY !== 'undefined' &&\n                    plotY >= 0 &&\n                    plotY <= this.yAxis.len &&\n                    (shapeArgs.x || 0) + (shapeArgs.width || 0) >= 0 &&\n                    plotX <= this.xAxis.len;\n                return isInside;\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        XRangeSeries.defaultOptions = merge(ColumnSeries.defaultOptions, XRangeSeriesDefaults);\n        extend(XRangeSeries.prototype, {\n            pointClass: XRangePoint,\n            pointArrayMap: ['x2', 'y'],\n            getExtremesFromAll: true,\n            parallelArrays: ['x', 'x2', 'y'],\n            requireSorting: false,\n            type: 'xrange',\n            animate: SeriesRegistry.series.prototype.animate,\n            autoIncrement: noop,\n            buildKDTree: noop\n        });\n        SeriesRegistry.registerSeriesType('xrange', XRangeSeries);\n        /* *\n         *\n         * Default Export\n         *\n         * */\n\n        return XRangeSeries;\n    });\n    _registerModule(_modules, 'masters/modules/xrange.src.js', [_modules['Core/Globals.js'], _modules['Series/XRange/XRangeSeries.js']], function (Highcharts, XRangeSeries) {\n\n        const G = Highcharts;\n        XRangeSeries.compose(G.Axis);\n\n        return Highcharts;\n    });\n    _registerModule(_modules, 'Series/Gantt/GanttPoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *\n         *  Author: Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { xrange: { prototype: { pointClass: XRangePoint } } } = SeriesRegistry.seriesTypes;\n        const { pick } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class GanttPoint extends XRangePoint {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            static setGanttPointAliases(options) {\n                /**\n                 * Add a value to options if the value exists.\n                 * @private\n                 */\n                function addIfExists(prop, val) {\n                    if (typeof val !== 'undefined') {\n                        options[prop] = val;\n                    }\n                }\n                addIfExists('x', pick(options.start, options.x));\n                addIfExists('x2', pick(options.end, options.x2));\n                addIfExists('partialFill', pick(options.completed, options.partialFill));\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Applies the options containing the x and y data and possible some\n             * extra properties. This is called on point init or from point.update.\n             *\n             * @private\n             * @function Highcharts.Point#applyOptions\n             *\n             * @param {Object} options\n             *        The point options\n             *\n             * @param {number} x\n             *        The x value\n             *\n             * @return {Highcharts.Point}\n             *         The Point instance\n             */\n            applyOptions(options, x) {\n                const ganttPoint = super.applyOptions(options, x);\n                GanttPoint.setGanttPointAliases(ganttPoint);\n                return ganttPoint;\n            }\n            isValid() {\n                return ((typeof this.start === 'number' ||\n                    typeof this.x === 'number') &&\n                    (typeof this.end === 'number' ||\n                        typeof this.x2 === 'number' ||\n                        this.milestone));\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return GanttPoint;\n    });\n    _registerModule(_modules, 'Series/Gantt/GanttSeriesDefaults.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *\n         *  Author: Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { isNumber } = U;\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A `gantt` series. If the [type](#series.gantt.type) option is not specified,\n         * it is inherited from [chart.type](#chart.type).\n         *\n         * @extends      plotOptions.xrange\n         * @product      gantt\n         * @requires     highcharts-gantt\n         * @optionparent plotOptions.gantt\n         */\n        const GanttSeriesDefaults = {\n            // options - default options merged with parent\n            grouping: false,\n            dataLabels: {\n                enabled: true\n            },\n            tooltip: {\n                headerFormat: '<span style=\"font-size: 0.8em\">{series.name}</span><br/>',\n                pointFormat: null,\n                pointFormatter: function () {\n                    const point = this, series = point.series, xAxis = series.xAxis, formats = series.tooltipOptions.dateTimeLabelFormats, startOfWeek = xAxis.options.startOfWeek, ttOptions = series.tooltipOptions, milestone = point.options.milestone;\n                    let format = ttOptions.xDateFormat, retVal = '<b>' + (point.name || point.yCategory) + '</b>';\n                    if (ttOptions.pointFormat) {\n                        return point.tooltipFormatter(ttOptions.pointFormat);\n                    }\n                    if (!format && isNumber(point.start)) {\n                        format = series.chart.time.getDateFormat(xAxis.closestPointRange, point.start, startOfWeek, formats || {});\n                    }\n                    const start = series.chart.time.dateFormat(format, point.start), end = series.chart.time.dateFormat(format, point.end);\n                    retVal += '<br/>';\n                    if (!milestone) {\n                        retVal += 'Start: ' + start + '<br/>';\n                        retVal += 'End: ' + end + '<br/>';\n                    }\n                    else {\n                        retVal += start + '<br/>';\n                    }\n                    return retVal;\n                }\n            },\n            connectors: {\n                type: 'simpleConnect',\n                /**\n                 * @declare Highcharts.ConnectorsAnimationOptionsObject\n                 */\n                animation: {\n                    reversed: true // Dependencies go from child to parent\n                },\n                radius: 0,\n                startMarker: {\n                    enabled: true,\n                    symbol: 'arrow-filled',\n                    radius: 4,\n                    fill: '#fa0',\n                    align: 'left'\n                },\n                endMarker: {\n                    enabled: false,\n                    align: 'right'\n                }\n            }\n        };\n        /**\n         * A `gantt` series.\n         *\n         * @extends   series,plotOptions.gantt\n         * @excluding boostThreshold, dashStyle, findNearestPointBy,\n         *            getExtremesFromAll, marker, negativeColor, pointInterval,\n         *            pointIntervalUnit, pointPlacement, pointStart\n         * @product   gantt\n         * @requires  highcharts-gantt\n         * @apioption series.gantt\n         */\n        /**\n         * Data for a Gantt series.\n         *\n         * @declare   Highcharts.GanttPointOptionsObject\n         * @type      {Array<*>}\n         * @extends   series.xrange.data\n         * @excluding className, connect, dataLabels, events,\n         *            partialFill, selected, x, x2\n         * @product   gantt\n         * @apioption series.gantt.data\n         */\n        /**\n         * Whether the grid node belonging to this point should start as collapsed. Used\n         * in axes of type treegrid.\n         *\n         * @sample {gantt} gantt/treegrid-axis/collapsed/\n         *         Start as collapsed\n         *\n         * @type      {boolean}\n         * @default   false\n         * @product   gantt\n         * @apioption series.gantt.data.collapsed\n         */\n        /**\n         * The start time of a task.\n         *\n         * @type      {number}\n         * @product   gantt\n         * @apioption series.gantt.data.start\n         */\n        /**\n         * The end time of a task.\n         *\n         * @type      {number}\n         * @product   gantt\n         * @apioption series.gantt.data.end\n         */\n        /**\n         * The Y value of a task.\n         *\n         * @type      {number}\n         * @product   gantt\n         * @apioption series.gantt.data.y\n         */\n        /**\n         * The name of a task. If a `treegrid` y-axis is used (default in Gantt charts),\n         * this will be picked up automatically, and used to calculate the y-value.\n         *\n         * @type      {string}\n         * @product   gantt\n         * @apioption series.gantt.data.name\n         */\n        /**\n         * Progress indicator, how much of the task completed. If it is a number, the\n         * `fill` will be applied automatically.\n         *\n         * @sample {gantt} gantt/demo/progress-indicator\n         *         Progress indicator\n         *\n         * @type      {number|*}\n         * @extends   series.xrange.data.partialFill\n         * @product   gantt\n         * @apioption series.gantt.data.completed\n         */\n        /**\n         * The amount of the progress indicator, ranging from 0 (not started) to 1\n         * (finished).\n         *\n         * @type      {number}\n         * @default   0\n         * @apioption series.gantt.data.completed.amount\n         */\n        /**\n         * The fill of the progress indicator. Defaults to a darkened variety of the\n         * main color.\n         *\n         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         * @apioption series.gantt.data.completed.fill\n         */\n        /**\n         * The ID of the point (task) that this point depends on in Gantt charts.\n         * Aliases [connect](series.xrange.data.connect). Can also be an object,\n         * specifying further connecting [options](series.gantt.connectors) between the\n         * points. Multiple connections can be specified by providing an array.\n         *\n         * @sample gantt/demo/project-management\n         *         Dependencies\n         * @sample gantt/pathfinder/demo\n         *         Different connection types\n         *\n         * @type      {string|Array<string|*>|*}\n         * @extends   series.xrange.data.connect\n         * @since     6.2.0\n         * @product   gantt\n         * @apioption series.gantt.data.dependency\n         */\n        /**\n         * Whether this point is a milestone. If so, only the `start` option is handled,\n         * while `end` is ignored.\n         *\n         * @sample gantt/gantt/milestones\n         *         Milestones\n         *\n         * @type      {boolean}\n         * @since     6.2.0\n         * @product   gantt\n         * @apioption series.gantt.data.milestone\n         */\n        /**\n         * The ID of the parent point (task) of this point in Gantt charts.\n         *\n         * @sample gantt/demo/subtasks\n         *         Gantt chart with subtasks\n         *\n         * @type      {string}\n         * @since     6.2.0\n         * @product   gantt\n         * @apioption series.gantt.data.parent\n         */\n        /**\n         * @excluding afterAnimate\n         * @apioption series.gantt.events\n         */\n        ''; // detachs doclets above\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return GanttSeriesDefaults;\n    });\n    _registerModule(_modules, 'Core/Axis/BrokenAxis.js', [_modules['Core/Axis/Stacking/StackItem.js'], _modules['Core/Utilities.js']], function (StackItem, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { addEvent, find, fireEvent, isArray, isNumber, pick } = U;\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        /**\n         * Axis with support of broken data rows.\n         * @private\n         */\n        var BrokenAxis;\n        (function (BrokenAxis) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Adds support for broken axes.\n             * @private\n             */\n            function compose(AxisClass, SeriesClass) {\n                if (!AxisClass.keepProps.includes('brokenAxis')) {\n                    AxisClass.keepProps.push('brokenAxis');\n                    addEvent(AxisClass, 'init', onAxisInit);\n                    addEvent(AxisClass, 'afterInit', onAxisAfterInit);\n                    addEvent(AxisClass, 'afterSetTickPositions', onAxisAfterSetTickPositions);\n                    addEvent(AxisClass, 'afterSetOptions', onAxisAfterSetOptions);\n                    const seriesProto = SeriesClass.prototype;\n                    seriesProto.drawBreaks = seriesDrawBreaks;\n                    seriesProto.gappedPath = seriesGappedPath;\n                    addEvent(SeriesClass, 'afterGeneratePoints', onSeriesAfterGeneratePoints);\n                    addEvent(SeriesClass, 'afterRender', onSeriesAfterRender);\n                }\n                return AxisClass;\n            }\n            BrokenAxis.compose = compose;\n            /**\n             * @private\n             */\n            function onAxisAfterInit() {\n                if (typeof this.brokenAxis !== 'undefined') {\n                    this.brokenAxis.setBreaks(this.options.breaks, false);\n                }\n            }\n            /**\n             * Force Axis to be not-ordinal when breaks are defined.\n             * @private\n             */\n            function onAxisAfterSetOptions() {\n                const axis = this;\n                if (axis.brokenAxis?.hasBreaks) {\n                    axis.options.ordinal = false;\n                }\n            }\n            /**\n             * @private\n             */\n            function onAxisAfterSetTickPositions() {\n                const axis = this, brokenAxis = axis.brokenAxis;\n                if (brokenAxis?.hasBreaks) {\n                    const tickPositions = axis.tickPositions, info = axis.tickPositions.info, newPositions = [];\n                    for (let i = 0; i < tickPositions.length; i++) {\n                        if (!brokenAxis.isInAnyBreak(tickPositions[i])) {\n                            newPositions.push(tickPositions[i]);\n                        }\n                    }\n                    axis.tickPositions = newPositions;\n                    axis.tickPositions.info = info;\n                }\n            }\n            /**\n             * @private\n             */\n            function onAxisInit() {\n                const axis = this;\n                if (!axis.brokenAxis) {\n                    axis.brokenAxis = new Additions(axis);\n                }\n            }\n            /**\n             * @private\n             */\n            function onSeriesAfterGeneratePoints() {\n                const { isDirty, options: { connectNulls }, points, xAxis, yAxis } = this;\n                // Set, or reset visibility of the points. Axis.setBreaks marks\n                // the series as isDirty\n                if (isDirty) {\n                    let i = points.length;\n                    while (i--) {\n                        const point = points[i];\n                        // Respect nulls inside the break (#4275)\n                        const nullGap = point.y === null && connectNulls === false;\n                        const isPointInBreak = (!nullGap && (xAxis?.brokenAxis?.isInAnyBreak(point.x, true) ||\n                            yAxis?.brokenAxis?.isInAnyBreak(point.y, true)));\n                        // Set point.visible if in any break.\n                        // If not in break, reset visible to original value.\n                        point.visible = isPointInBreak ?\n                            false :\n                            point.options.visible !== false;\n                    }\n                }\n            }\n            /**\n             * @private\n             */\n            function onSeriesAfterRender() {\n                this.drawBreaks(this.xAxis, ['x']);\n                this.drawBreaks(this.yAxis, pick(this.pointArrayMap, ['y']));\n            }\n            /**\n             * @private\n             */\n            function seriesDrawBreaks(axis, keys) {\n                const series = this, points = series.points;\n                let breaks, threshold, y;\n                if (axis?.brokenAxis?.hasBreaks) {\n                    const brokenAxis = axis.brokenAxis;\n                    keys.forEach(function (key) {\n                        breaks = brokenAxis?.breakArray || [];\n                        threshold = axis.isXAxis ?\n                            axis.min :\n                            pick(series.options.threshold, axis.min);\n                        // Array of breaks that have been \"zoomed-out\" which means that\n                        // they were shown previously, but now after zoom, they are not\n                        // (#19885).\n                        const breaksOutOfRange = axis?.options?.breaks?.filter(function (brk) {\n                            let isOut = true;\n                            // Iterate to see if \"brk\" is in axis range\n                            for (let i = 0; i < breaks.length; i++) {\n                                const otherBreak = breaks[i];\n                                if (otherBreak.from === brk.from &&\n                                    otherBreak.to === brk.to) {\n                                    isOut = false;\n                                    break;\n                                }\n                            }\n                            return isOut;\n                        });\n                        points.forEach(function (point) {\n                            y = pick(point['stack' + key.toUpperCase()], point[key]);\n                            breaks.forEach(function (brk) {\n                                if (isNumber(threshold) && isNumber(y)) {\n                                    let eventName = '';\n                                    if ((threshold < brk.from && y > brk.to) ||\n                                        (threshold > brk.from && y < brk.from)) {\n                                        eventName = 'pointBreak';\n                                    }\n                                    else if ((threshold < brk.from &&\n                                        y > brk.from &&\n                                        y < brk.to) || (threshold > brk.from &&\n                                        y > brk.to &&\n                                        y < brk.from)) {\n                                        eventName = 'pointInBreak';\n                                    }\n                                    if (eventName) {\n                                        fireEvent(axis, eventName, { point, brk });\n                                    }\n                                }\n                            });\n                            breaksOutOfRange?.forEach(function (brk) {\n                                fireEvent(axis, 'pointOutsideOfBreak', { point, brk });\n                            });\n                        });\n                    });\n                }\n            }\n            /**\n             * Extend getGraphPath by identifying gaps in the data so that we\n             * can draw a gap in the line or area. This was moved from ordinal\n             * axis module to broken axis module as of #5045.\n             *\n             * @private\n             * @function Highcharts.Series#gappedPath\n             *\n             * @return {Highcharts.SVGPathArray}\n             * Gapped path\n             */\n            function seriesGappedPath() {\n                const currentDataGrouping = this.currentDataGrouping, groupingSize = currentDataGrouping?.gapSize, points = this.points.slice(), yAxis = this.yAxis;\n                let gapSize = this.options.gapSize, i = points.length - 1, stack;\n                /**\n                 * Defines when to display a gap in the graph, together with the\n                 * [gapUnit](plotOptions.series.gapUnit) option.\n                 *\n                 * In case when `dataGrouping` is enabled, points can be grouped\n                 * into a larger time span. This can make the grouped points to\n                 * have a greater distance than the absolute value of `gapSize`\n                 * property, which will result in disappearing graph completely.\n                 * To prevent this situation the mentioned distance between\n                 * grouped points is used instead of previously defined\n                 * `gapSize`.\n                 *\n                 * In practice, this option is most often used to visualize gaps\n                 * in time series. In a stock chart, intraday data is available\n                 * for daytime hours, while gaps will appear in nights and\n                 * weekends.\n                 *\n                 * @see [gapUnit](plotOptions.series.gapUnit)\n                 * @see [xAxis.breaks](#xAxis.breaks)\n                 *\n                 * @sample {highstock} stock/plotoptions/series-gapsize/\n                 * Setting the gap size to 2 introduces gaps for weekends in\n                 * daily datasets.\n                 *\n                 * @type      {number}\n                 * @default   0\n                 * @product   highstock\n                 * @requires  modules/broken-axis\n                 * @apioption plotOptions.series.gapSize\n                 */\n                /**\n                 * Together with [gapSize](plotOptions.series.gapSize), this\n                 * option defines where to draw gaps in the graph.\n                 *\n                 * When the `gapUnit` is `\"relative\"` (default), a gap size of 5\n                 * means that if the distance between two points is greater than\n                 * 5 times that of the two closest points, the graph will be\n                 * broken.\n                 *\n                 * When the `gapUnit` is `\"value\"`, the gap is based on absolute\n                 * axis values, which on a datetime axis is milliseconds. This\n                 * also applies to the navigator series that inherits gap\n                 * options from the base series.\n                 *\n                 * @see [gapSize](plotOptions.series.gapSize)\n                 *\n                 * @type       {string}\n                 * @default    relative\n                 * @since      5.0.13\n                 * @product    highstock\n                 * @validvalue [\"relative\", \"value\"]\n                 * @requires   modules/broken-axis\n                 * @apioption  plotOptions.series.gapUnit\n                 */\n                if (gapSize && i > 0) { // #5008\n                    // Gap unit is relative\n                    if (this.options.gapUnit !== 'value') {\n                        gapSize *= this.basePointRange;\n                    }\n                    // Setting a new gapSize in case dataGrouping is enabled\n                    // (#7686)\n                    if (groupingSize &&\n                        groupingSize > gapSize &&\n                        // Except when DG is forced (e.g. from other series)\n                        // and has lower granularity than actual points (#11351)\n                        groupingSize >= this.basePointRange) {\n                        gapSize = groupingSize;\n                    }\n                    // extension for ordinal breaks\n                    let current, next;\n                    while (i--) {\n                        // Reassign next if it is not visible\n                        if (!(next && next.visible !== false)) {\n                            next = points[i + 1];\n                        }\n                        current = points[i];\n                        // Skip iteration if one of the points is not visible\n                        if (next.visible === false || current.visible === false) {\n                            continue;\n                        }\n                        if (next.x - current.x > gapSize) {\n                            const xRange = (current.x + next.x) / 2;\n                            points.splice(// insert after this one\n                            i + 1, 0, {\n                                isNull: true,\n                                x: xRange\n                            });\n                            // For stacked chart generate empty stack items, #6546\n                            if (yAxis.stacking && this.options.stacking) {\n                                stack = yAxis.stacking.stacks[this.stackKey][xRange] = new StackItem(yAxis, yAxis.options.stackLabels, false, xRange, this.stack);\n                                stack.total = 0;\n                            }\n                        }\n                        // Assign current to next for the upcoming iteration\n                        next = current;\n                    }\n                }\n                // Call base method\n                return this.getGraphPath(points);\n            }\n            /* *\n             *\n             *  Class\n             *\n             * */\n            /**\n             * Provides support for broken axes.\n             * @private\n             * @class\n             */\n            class Additions {\n                /* *\n                 *\n                 *  Static Functions\n                 *\n                 * */\n                /**\n                 * @private\n                 */\n                static isInBreak(brk, val) {\n                    const repeat = brk.repeat || Infinity, from = brk.from, length = brk.to - brk.from, test = (val >= from ?\n                        (val - from) % repeat :\n                        repeat - ((from - val) % repeat));\n                    let ret;\n                    if (!brk.inclusive) {\n                        ret = test < length && test !== 0;\n                    }\n                    else {\n                        ret = test <= length;\n                    }\n                    return ret;\n                }\n                /**\n                 * @private\n                 */\n                static lin2Val(val) {\n                    const axis = this;\n                    const brokenAxis = axis.brokenAxis;\n                    const breakArray = brokenAxis && brokenAxis.breakArray;\n                    if (!breakArray || !isNumber(val)) {\n                        return val;\n                    }\n                    let nval = val, brk, i;\n                    for (i = 0; i < breakArray.length; i++) {\n                        brk = breakArray[i];\n                        if (brk.from >= nval) {\n                            break;\n                        }\n                        else if (brk.to < nval) {\n                            nval += brk.len;\n                        }\n                        else if (Additions.isInBreak(brk, nval)) {\n                            nval += brk.len;\n                        }\n                    }\n                    return nval;\n                }\n                /**\n                 * @private\n                 */\n                static val2Lin(val) {\n                    const axis = this;\n                    const brokenAxis = axis.brokenAxis;\n                    const breakArray = brokenAxis && brokenAxis.breakArray;\n                    if (!breakArray || !isNumber(val)) {\n                        return val;\n                    }\n                    let nval = val, brk, i;\n                    for (i = 0; i < breakArray.length; i++) {\n                        brk = breakArray[i];\n                        if (brk.to <= val) {\n                            nval -= brk.len;\n                        }\n                        else if (brk.from >= val) {\n                            break;\n                        }\n                        else if (Additions.isInBreak(brk, val)) {\n                            nval -= (val - brk.from);\n                            break;\n                        }\n                    }\n                    return nval;\n                }\n                /* *\n                 *\n                 *  Constructors\n                 *\n                 * */\n                constructor(axis) {\n                    this.hasBreaks = false;\n                    this.axis = axis;\n                }\n                /* *\n                 *\n                 *  Functions\n                 *\n                 * */\n                /**\n                 * Returns the first break found where the x is larger then break.from\n                 * and smaller then break.to.\n                 *\n                 * @param {number} x\n                 * The number which should be within a break.\n                 *\n                 * @param {Array<Highcharts.XAxisBreaksOptions>} breaks\n                 * The array of breaks to search within.\n                 *\n                 * @return {Highcharts.XAxisBreaksOptions|undefined}\n                 * Returns the first break found that matches, returns false if no break\n                 * is found.\n                 */\n                findBreakAt(x, breaks) {\n                    return find(breaks, function (b) {\n                        return b.from < x && x < b.to;\n                    });\n                }\n                /**\n                 * @private\n                 */\n                isInAnyBreak(val, testKeep) {\n                    const brokenAxis = this, axis = brokenAxis.axis, breaks = axis.options.breaks || [];\n                    let i = breaks.length, inbrk, keep, ret;\n                    if (i && isNumber(val)) {\n                        while (i--) {\n                            if (Additions.isInBreak(breaks[i], val)) {\n                                inbrk = true;\n                                if (!keep) {\n                                    keep = pick(breaks[i].showPoints, !axis.isXAxis);\n                                }\n                            }\n                        }\n                        if (inbrk && testKeep) {\n                            ret = inbrk && !keep;\n                        }\n                        else {\n                            ret = inbrk;\n                        }\n                    }\n                    return ret;\n                }\n                /**\n                 * Dynamically set or unset breaks in an axis. This function in lighter\n                 * than using Axis.update, and it also preserves animation.\n                 *\n                 * @private\n                 * @function Highcharts.Axis#setBreaks\n                 *\n                 * @param {Array<Highcharts.XAxisBreaksOptions>} [breaks]\n                 * The breaks to add. When `undefined` it removes existing breaks.\n                 *\n                 * @param {boolean} [redraw=true]\n                 * Whether to redraw the chart immediately.\n                 */\n                setBreaks(breaks, redraw) {\n                    const brokenAxis = this;\n                    const axis = brokenAxis.axis;\n                    const hasBreaks = isArray(breaks) &&\n                        !!breaks.length &&\n                        !!Object.keys(breaks[0]).length; // Check for [{}], #16368.\n                    axis.isDirty = brokenAxis.hasBreaks !== hasBreaks;\n                    brokenAxis.hasBreaks = hasBreaks;\n                    if (breaks !== axis.options.breaks) {\n                        axis.options.breaks = axis.userOptions.breaks = breaks;\n                    }\n                    axis.forceRedraw = true; // Force recalculation in setScale\n                    // Recalculate series related to the axis.\n                    axis.series.forEach(function (series) {\n                        series.isDirty = true;\n                    });\n                    if (!hasBreaks && axis.val2lin === Additions.val2Lin) {\n                        // Revert to prototype functions\n                        delete axis.val2lin;\n                        delete axis.lin2val;\n                    }\n                    if (hasBreaks) {\n                        axis.userOptions.ordinal = false;\n                        axis.lin2val = Additions.lin2Val;\n                        axis.val2lin = Additions.val2Lin;\n                        axis.setExtremes = function (newMin, newMax, redraw, animation, eventArguments) {\n                            // If trying to set extremes inside a break, extend min to\n                            // after, and max to before the break ( #3857 )\n                            if (brokenAxis.hasBreaks) {\n                                const breaks = (this.options.breaks || []);\n                                let axisBreak;\n                                while ((axisBreak = brokenAxis.findBreakAt(newMin, breaks))) {\n                                    newMin = axisBreak.to;\n                                }\n                                while ((axisBreak = brokenAxis.findBreakAt(newMax, breaks))) {\n                                    newMax = axisBreak.from;\n                                }\n                                // If both min and max is within the same break.\n                                if (newMax < newMin) {\n                                    newMax = newMin;\n                                }\n                            }\n                            axis.constructor.prototype.setExtremes.call(this, newMin, newMax, redraw, animation, eventArguments);\n                        };\n                        axis.setAxisTranslation = function () {\n                            axis.constructor.prototype.setAxisTranslation.call(this);\n                            brokenAxis.unitLength = void 0;\n                            if (brokenAxis.hasBreaks) {\n                                const breaks = axis.options.breaks || [], \n                                // Temporary one:\n                                breakArrayT = [], breakArray = [], pointRangePadding = pick(axis.pointRangePadding, 0);\n                                let length = 0, inBrk, repeat, min = axis.userMin || axis.min, max = axis.userMax || axis.max, start, i;\n                                // Min & max check (#4247)\n                                breaks.forEach(function (brk) {\n                                    repeat = brk.repeat || Infinity;\n                                    if (isNumber(min) && isNumber(max)) {\n                                        if (Additions.isInBreak(brk, min)) {\n                                            min += ((brk.to % repeat) -\n                                                (min % repeat));\n                                        }\n                                        if (Additions.isInBreak(brk, max)) {\n                                            max -= ((max % repeat) -\n                                                (brk.from % repeat));\n                                        }\n                                    }\n                                });\n                                // Construct an array holding all breaks in the axis\n                                breaks.forEach(function (brk) {\n                                    start = brk.from;\n                                    repeat = brk.repeat || Infinity;\n                                    if (isNumber(min) && isNumber(max)) {\n                                        while (start - repeat > min) {\n                                            start -= repeat;\n                                        }\n                                        while (start < min) {\n                                            start += repeat;\n                                        }\n                                        for (i = start; i < max; i += repeat) {\n                                            breakArrayT.push({\n                                                value: i,\n                                                move: 'in'\n                                            });\n                                            breakArrayT.push({\n                                                value: i + brk.to - brk.from,\n                                                move: 'out',\n                                                size: brk.breakSize\n                                            });\n                                        }\n                                    }\n                                });\n                                breakArrayT.sort(function (a, b) {\n                                    return ((a.value === b.value) ?\n                                        ((a.move === 'in' ? 0 : 1) -\n                                            (b.move === 'in' ? 0 : 1)) :\n                                        a.value - b.value);\n                                });\n                                // Simplify the breaks\n                                inBrk = 0;\n                                start = min;\n                                breakArrayT.forEach(function (brk) {\n                                    inBrk += (brk.move === 'in' ? 1 : -1);\n                                    if (inBrk === 1 && brk.move === 'in') {\n                                        start = brk.value;\n                                    }\n                                    if (inBrk === 0 && isNumber(start)) {\n                                        breakArray.push({\n                                            from: start,\n                                            to: brk.value,\n                                            len: brk.value - start - (brk.size || 0)\n                                        });\n                                        length += (brk.value -\n                                            start -\n                                            (brk.size || 0));\n                                    }\n                                });\n                                brokenAxis.breakArray = breakArray;\n                                // Used with staticScale, and below the actual axis\n                                // length, when breaks are subtracted.\n                                if (isNumber(min) &&\n                                    isNumber(max) &&\n                                    isNumber(axis.min)) {\n                                    brokenAxis.unitLength = max - min - length +\n                                        pointRangePadding;\n                                    fireEvent(axis, 'afterBreaks');\n                                    if (axis.staticScale) {\n                                        axis.transA = axis.staticScale;\n                                    }\n                                    else if (brokenAxis.unitLength) {\n                                        axis.transA *=\n                                            (max - axis.min + pointRangePadding) /\n                                                brokenAxis.unitLength;\n                                    }\n                                    if (pointRangePadding) {\n                                        axis.minPixelPadding =\n                                            axis.transA * (axis.minPointOffset || 0);\n                                    }\n                                    axis.min = min;\n                                    axis.max = max;\n                                }\n                            }\n                        };\n                    }\n                    if (pick(redraw, true)) {\n                        axis.chart.redraw();\n                    }\n                }\n            }\n            BrokenAxis.Additions = Additions;\n        })(BrokenAxis || (BrokenAxis = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return BrokenAxis;\n    });\n    _registerModule(_modules, 'Core/Axis/GridAxis.js', [_modules['Core/Axis/Axis.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (Axis, H, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { dateFormats } = H;\n        const { addEvent, defined, erase, find, isArray, isNumber, merge, pick, timeUnits, wrap } = U;\n        /* *\n         *\n         *  Enums\n         *\n         * */\n        /**\n         * Enum for which side the axis is on. Maps to axis.side.\n         * @private\n         */\n        var GridAxisSide;\n        (function (GridAxisSide) {\n            GridAxisSide[GridAxisSide[\"top\"] = 0] = \"top\";\n            GridAxisSide[GridAxisSide[\"right\"] = 1] = \"right\";\n            GridAxisSide[GridAxisSide[\"bottom\"] = 2] = \"bottom\";\n            GridAxisSide[GridAxisSide[\"left\"] = 3] = \"left\";\n        })(GridAxisSide || (GridAxisSide = {}));\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function argsToArray(args) {\n            return Array.prototype.slice.call(args, 1);\n        }\n        /**\n         * @private\n         */\n        function isObject(x) {\n            // Always use strict mode\n            return U.isObject(x, true);\n        }\n        /**\n         * @private\n         */\n        function applyGridOptions(axis) {\n            const options = axis.options;\n            // Center-align by default\n            /*\n            if (!options.labels) {\n                options.labels = {};\n            }\n            */\n            options.labels.align = pick(options.labels.align, 'center');\n            // @todo: Check against tickLabelPlacement between/on etc\n            /* Prevents adding the last tick label if the axis is not a category\n               axis.\n               Since numeric labels are normally placed at starts and ends of a\n               range of value, and this module makes the label point at the value,\n               an \"extra\" label would appear. */\n            if (!axis.categories) {\n                options.showLastLabel = false;\n            }\n            // Prevents rotation of labels when squished, as rotating them would not\n            // help.\n            axis.labelRotation = 0;\n            options.labels.rotation = 0;\n            // Allow putting ticks closer than their data points.\n            options.minTickInterval = 1;\n        }\n        /**\n         * Extends axis class with grid support.\n         * @private\n         */\n        function compose(AxisClass, ChartClass, TickClass) {\n            if (!AxisClass.keepProps.includes('grid')) {\n                AxisClass.keepProps.push('grid');\n                AxisClass.prototype.getMaxLabelDimensions = getMaxLabelDimensions;\n                wrap(AxisClass.prototype, 'unsquish', wrapUnsquish);\n                wrap(AxisClass.prototype, 'getOffset', wrapGetOffset);\n                // Add event handlers\n                addEvent(AxisClass, 'init', onInit);\n                addEvent(AxisClass, 'afterGetTitlePosition', onAfterGetTitlePosition);\n                addEvent(AxisClass, 'afterInit', onAfterInit);\n                addEvent(AxisClass, 'afterRender', onAfterRender);\n                addEvent(AxisClass, 'afterSetAxisTranslation', onAfterSetAxisTranslation);\n                addEvent(AxisClass, 'afterSetOptions', onAfterSetOptions);\n                addEvent(AxisClass, 'afterSetOptions', onAfterSetOptions2);\n                addEvent(AxisClass, 'afterSetScale', onAfterSetScale);\n                addEvent(AxisClass, 'afterTickSize', onAfterTickSize);\n                addEvent(AxisClass, 'trimTicks', onTrimTicks);\n                addEvent(AxisClass, 'destroy', onDestroy);\n                addEvent(ChartClass, 'afterSetChartSize', onChartAfterSetChartSize);\n                addEvent(TickClass, 'afterGetLabelPosition', onTickAfterGetLabelPosition);\n                addEvent(TickClass, 'labelFormat', onTickLabelFormat);\n            }\n            return AxisClass;\n        }\n        /**\n         * Get the largest label width and height.\n         *\n         * @private\n         * @function Highcharts.Axis#getMaxLabelDimensions\n         *\n         * @param {Highcharts.Dictionary<Highcharts.Tick>} ticks\n         * All the ticks on one axis.\n         *\n         * @param {Array<number|string>} tickPositions\n         * All the tick positions on one axis.\n         *\n         * @return {Highcharts.SizeObject}\n         * Object containing the properties height and width.\n         *\n         * @todo Move this to the generic axis implementation, as it is used there.\n         */\n        function getMaxLabelDimensions(ticks, tickPositions) {\n            const dimensions = {\n                width: 0,\n                height: 0\n            };\n            tickPositions.forEach(function (pos) {\n                const tick = ticks[pos];\n                let labelHeight = 0, labelWidth = 0, label;\n                if (isObject(tick)) {\n                    label = isObject(tick.label) ? tick.label : {};\n                    // Find width and height of label\n                    labelHeight = label.getBBox ? label.getBBox().height : 0;\n                    if (label.textStr && !isNumber(label.textPxLength)) {\n                        label.textPxLength = label.getBBox().width;\n                    }\n                    labelWidth = isNumber(label.textPxLength) ?\n                        // Math.round ensures crisp lines\n                        Math.round(label.textPxLength) :\n                        0;\n                    if (label.textStr) {\n                        // Set the tickWidth same as the label width after ellipsis\n                        // applied #10281\n                        labelWidth = Math.round(label.getBBox().width);\n                    }\n                    // Update the result if width and/or height are larger\n                    dimensions.height = Math.max(labelHeight, dimensions.height);\n                    dimensions.width = Math.max(labelWidth, dimensions.width);\n                }\n            });\n            // For tree grid, add indentation\n            if (this.options.type === 'treegrid' &&\n                this.treeGrid &&\n                this.treeGrid.mapOfPosToGridNode) {\n                const treeDepth = this.treeGrid.mapOfPosToGridNode[-1].height || 0;\n                dimensions.width += (this.options.labels.indentation *\n                    (treeDepth - 1));\n            }\n            return dimensions;\n        }\n        /**\n         * Handle columns and getOffset.\n         * @private\n         */\n        function wrapGetOffset(proceed) {\n            const { grid } = this, \n            // On the left side we handle the columns first because the offset is\n            // calculated from the plot area and out\n            columnsFirst = this.side === 3;\n            if (!columnsFirst) {\n                proceed.apply(this);\n            }\n            if (!grid?.isColumn) {\n                let columns = grid?.columns || [];\n                if (columnsFirst) {\n                    columns = columns.slice().reverse();\n                }\n                columns\n                    .forEach((column) => {\n                    column.getOffset();\n                });\n            }\n            if (columnsFirst) {\n                proceed.apply(this);\n            }\n        }\n        /**\n         * @private\n         */\n        function onAfterGetTitlePosition(e) {\n            const axis = this;\n            const options = axis.options;\n            const gridOptions = options.grid || {};\n            if (gridOptions.enabled === true) {\n                // compute anchor points for each of the title align options\n                const { axisTitle, height: axisHeight, horiz, left: axisLeft, offset, opposite, options, top: axisTop, width: axisWidth } = axis;\n                const tickSize = axis.tickSize();\n                const titleWidth = axisTitle && axisTitle.getBBox().width;\n                const xOption = options.title.x;\n                const yOption = options.title.y;\n                const titleMargin = pick(options.title.margin, horiz ? 5 : 10);\n                const titleFontSize = axisTitle ? axis.chart.renderer.fontMetrics(axisTitle).f : 0;\n                const crispCorr = tickSize ? tickSize[0] / 2 : 0;\n                // TODO account for alignment\n                // the position in the perpendicular direction of the axis\n                const offAxis = ((horiz ? axisTop + axisHeight : axisLeft) +\n                    (horiz ? 1 : -1) * // horizontal axis reverses the margin\n                        (opposite ? -1 : 1) * // so does opposite axes\n                        crispCorr +\n                    (axis.side === GridAxisSide.bottom ? titleFontSize : 0));\n                e.titlePosition.x = horiz ?\n                    axisLeft - (titleWidth || 0) / 2 - titleMargin + xOption :\n                    offAxis + (opposite ? axisWidth : 0) + offset + xOption;\n                e.titlePosition.y = horiz ?\n                    (offAxis -\n                        (opposite ? axisHeight : 0) +\n                        (opposite ? titleFontSize : -titleFontSize) / 2 +\n                        offset +\n                        yOption) :\n                    axisTop - titleMargin + yOption;\n            }\n        }\n        /**\n         * @private\n         */\n        function onAfterInit() {\n            const axis = this;\n            const { chart, options: { grid: gridOptions = {} }, userOptions } = axis;\n            if (gridOptions.enabled) {\n                applyGridOptions(axis);\n            }\n            if (gridOptions.columns) {\n                const columns = axis.grid.columns = [];\n                let columnIndex = axis.grid.columnIndex = 0;\n                // Handle columns, each column is a grid axis\n                while (++columnIndex < gridOptions.columns.length) {\n                    const columnOptions = merge(userOptions, gridOptions.columns[columnIndex], {\n                        isInternal: true,\n                        linkedTo: 0,\n                        // Disable by default the scrollbar on the grid axis\n                        scrollbar: {\n                            enabled: false\n                        }\n                    }, \n                    // Avoid recursion\n                    {\n                        grid: {\n                            columns: void 0\n                        }\n                    });\n                    const column = new Axis(axis.chart, columnOptions, 'yAxis');\n                    column.grid.isColumn = true;\n                    column.grid.columnIndex = columnIndex;\n                    // Remove column axis from chart axes array, and place it\n                    // in the columns array.\n                    erase(chart.axes, column);\n                    erase(chart[axis.coll] || [], column);\n                    columns.push(column);\n                }\n            }\n        }\n        /**\n         * Draw an extra line on the far side of the outermost axis,\n         * creating floor/roof/wall of a grid. And some padding.\n         * ```\n         * Make this:\n         *             (axis.min) __________________________ (axis.max)\n         *                           |    |    |    |    |\n         * Into this:\n         *             (axis.min) __________________________ (axis.max)\n         *                        ___|____|____|____|____|__\n         * ```\n         * @private\n         */\n        function onAfterRender() {\n            const axis = this, { axisTitle, grid, options } = axis, gridOptions = options.grid || {};\n            if (gridOptions.enabled === true) {\n                const min = axis.min || 0, max = axis.max || 0, firstTick = axis.ticks[axis.tickPositions[0]];\n                // Adjust the title max width to the column width (#19657)\n                if (axisTitle &&\n                    !axis.chart.styledMode &&\n                    firstTick?.slotWidth &&\n                    !axis.options.title.style.width) {\n                    axisTitle.css({ width: `${firstTick.slotWidth}px` });\n                }\n                // @todo actual label padding (top, bottom, left, right)\n                axis.maxLabelDimensions = axis.getMaxLabelDimensions(axis.ticks, axis.tickPositions);\n                // Remove right wall before rendering if updating\n                if (axis.rightWall) {\n                    axis.rightWall.destroy();\n                }\n                /*\n                Draw an extra axis line on outer axes\n                            >\n                Make this:    |______|______|______|___\n\n                            > _________________________\n                Into this:    |______|______|______|__|\n                                                        */\n                if (axis.grid && axis.grid.isOuterAxis() && axis.axisLine) {\n                    const lineWidth = options.lineWidth;\n                    if (lineWidth) {\n                        const linePath = axis.getLinePath(lineWidth), startPoint = linePath[0], endPoint = linePath[1], \n                        // Negate distance if top or left axis\n                        // Subtract 1px to draw the line at the end of the tick\n                        tickLength = (axis.tickSize('tick') || [1])[0], distance = (tickLength - 1) * ((axis.side === GridAxisSide.top ||\n                            axis.side === GridAxisSide.left) ? -1 : 1);\n                        // If axis is horizontal, reposition line path vertically\n                        if (startPoint[0] === 'M' && endPoint[0] === 'L') {\n                            if (axis.horiz) {\n                                startPoint[2] += distance;\n                                endPoint[2] += distance;\n                            }\n                            else {\n                                startPoint[1] += distance;\n                                endPoint[1] += distance;\n                            }\n                        }\n                        // If it doesn't exist, add an upper and lower border\n                        // for the vertical grid axis.\n                        if (!axis.horiz && axis.chart.marginRight) {\n                            const upperBorderStartPoint = startPoint, upperBorderEndPoint = [\n                                'L',\n                                axis.left,\n                                startPoint[2] || 0\n                            ], upperBorderPath = [\n                                upperBorderStartPoint,\n                                upperBorderEndPoint\n                            ], lowerBorderEndPoint = [\n                                'L',\n                                axis.chart.chartWidth - axis.chart.marginRight,\n                                axis.toPixels(max + axis.tickmarkOffset)\n                            ], lowerBorderStartPoint = [\n                                'M',\n                                endPoint[1] || 0,\n                                axis.toPixels(max + axis.tickmarkOffset)\n                            ], lowerBorderPath = [\n                                lowerBorderStartPoint,\n                                lowerBorderEndPoint\n                            ];\n                            if (!axis.grid.upperBorder && min % 1 !== 0) {\n                                axis.grid.upperBorder = axis.grid.renderBorder(upperBorderPath);\n                            }\n                            if (axis.grid.upperBorder) {\n                                axis.grid.upperBorder.attr({\n                                    stroke: options.lineColor,\n                                    'stroke-width': options.lineWidth\n                                });\n                                axis.grid.upperBorder.animate({\n                                    d: upperBorderPath\n                                });\n                            }\n                            if (!axis.grid.lowerBorder && max % 1 !== 0) {\n                                axis.grid.lowerBorder = axis.grid.renderBorder(lowerBorderPath);\n                            }\n                            if (axis.grid.lowerBorder) {\n                                axis.grid.lowerBorder.attr({\n                                    stroke: options.lineColor,\n                                    'stroke-width': options.lineWidth\n                                });\n                                axis.grid.lowerBorder.animate({\n                                    d: lowerBorderPath\n                                });\n                            }\n                        }\n                        // Render an extra line parallel to the existing axes, to\n                        // close the grid.\n                        if (!axis.grid.axisLineExtra) {\n                            axis.grid.axisLineExtra = axis.grid.renderBorder(linePath);\n                        }\n                        else {\n                            axis.grid.axisLineExtra.attr({\n                                stroke: options.lineColor,\n                                'stroke-width': options.lineWidth\n                            });\n                            axis.grid.axisLineExtra.animate({\n                                d: linePath\n                            });\n                        }\n                        // show or hide the line depending on options.showEmpty\n                        axis.axisLine[axis.showAxis ? 'show' : 'hide']();\n                    }\n                }\n                (grid && grid.columns || []).forEach((column) => column.render());\n                // Manipulate the tick mark visibility\n                // based on the axis.max- allows smooth scrolling.\n                if (!axis.horiz &&\n                    axis.chart.hasRendered &&\n                    (axis.scrollbar ||\n                        (axis.linkedParent && axis.linkedParent.scrollbar)) &&\n                    axis.tickPositions.length) {\n                    const tickmarkOffset = axis.tickmarkOffset, lastTick = axis.tickPositions[axis.tickPositions.length - 1], firstTick = axis.tickPositions[0];\n                    let label, tickMark;\n                    while ((label = axis.hiddenLabels.pop()) && label.element) {\n                        label.show(); // #15453\n                    }\n                    while ((tickMark = axis.hiddenMarks.pop()) &&\n                        tickMark.element) {\n                        tickMark.show(); // #16439\n                    }\n                    // Hide/show first tick label.\n                    label = axis.ticks[firstTick].label;\n                    if (label) {\n                        if (min - firstTick > tickmarkOffset) {\n                            axis.hiddenLabels.push(label.hide());\n                        }\n                        else {\n                            label.show();\n                        }\n                    }\n                    // Hide/show last tick mark/label.\n                    label = axis.ticks[lastTick].label;\n                    if (label) {\n                        if (lastTick - max > tickmarkOffset) {\n                            axis.hiddenLabels.push(label.hide());\n                        }\n                        else {\n                            label.show();\n                        }\n                    }\n                    const mark = axis.ticks[lastTick].mark;\n                    if (mark &&\n                        lastTick - max < tickmarkOffset &&\n                        lastTick - max > 0 && axis.ticks[lastTick].isLast) {\n                        axis.hiddenMarks.push(mark.hide());\n                    }\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onAfterSetAxisTranslation() {\n            const axis = this;\n            const tickInfo = axis.tickPositions && axis.tickPositions.info;\n            const options = axis.options;\n            const gridOptions = options.grid || {};\n            const userLabels = axis.userOptions.labels || {};\n            // Fire this only for the Gantt type chart, #14868.\n            if (gridOptions.enabled) {\n                if (axis.horiz) {\n                    axis.series.forEach((series) => {\n                        series.options.pointRange = 0;\n                    });\n                    // Lower level time ticks, like hours or minutes, represent\n                    // points in time and not ranges. These should be aligned\n                    // left in the grid cell by default. The same applies to\n                    // years of higher order.\n                    if (tickInfo &&\n                        options.dateTimeLabelFormats &&\n                        options.labels &&\n                        !defined(userLabels.align) &&\n                        (options.dateTimeLabelFormats[tickInfo.unitName]\n                            .range === false ||\n                            tickInfo.count > 1 // years\n                        )) {\n                        options.labels.align = 'left';\n                        if (!defined(userLabels.x)) {\n                            options.labels.x = 3;\n                        }\n                    }\n                }\n                else {\n                    // Don't trim ticks which not in min/max range but\n                    // they are still in the min/max plus tickInterval.\n                    if (this.options.type !== 'treegrid' &&\n                        axis.grid &&\n                        axis.grid.columns) {\n                        this.minPointOffset = this.tickInterval;\n                    }\n                }\n            }\n        }\n        /**\n         * Creates a left and right wall on horizontal axes:\n         * - Places leftmost tick at the start of the axis, to create a left\n         *   wall\n         * - Ensures that the rightmost tick is at the end of the axis, to\n         *   create a right wall.\n         * @private\n         */\n        function onAfterSetOptions(e) {\n            const options = this.options, userOptions = e.userOptions, gridOptions = ((options && isObject(options.grid)) ? options.grid : {});\n            let gridAxisOptions;\n            if (gridOptions.enabled === true) {\n                // Merge the user options into default grid axis options so\n                // that when a user option is set, it takes precedence.\n                gridAxisOptions = merge(true, {\n                    className: ('highcharts-grid-axis ' + (userOptions.className || '')),\n                    dateTimeLabelFormats: {\n                        hour: {\n                            list: ['%H:%M', '%H']\n                        },\n                        day: {\n                            list: ['%A, %e. %B', '%a, %e. %b', '%E']\n                        },\n                        week: {\n                            list: ['Week %W', 'W%W']\n                        },\n                        month: {\n                            list: ['%B', '%b', '%o']\n                        }\n                    },\n                    grid: {\n                        borderWidth: 1\n                    },\n                    labels: {\n                        padding: 2,\n                        style: {\n                            fontSize: '0.9em'\n                        }\n                    },\n                    margin: 0,\n                    title: {\n                        text: null,\n                        reserveSpace: false,\n                        rotation: 0,\n                        style: {\n                            textOverflow: 'ellipsis'\n                        }\n                    },\n                    // In a grid axis, only allow one unit of certain types,\n                    // for example we shouldn't have one grid cell spanning\n                    // two days.\n                    units: [[\n                            'millisecond',\n                            [1, 10, 100]\n                        ], [\n                            'second',\n                            [1, 10]\n                        ], [\n                            'minute',\n                            [1, 5, 15]\n                        ], [\n                            'hour',\n                            [1, 6]\n                        ], [\n                            'day',\n                            [1]\n                        ], [\n                            'week',\n                            [1]\n                        ], [\n                            'month',\n                            [1]\n                        ], [\n                            'year',\n                            null\n                        ]]\n                }, userOptions);\n                // X-axis specific options\n                if (this.coll === 'xAxis') {\n                    // For linked axes, tickPixelInterval is used only if\n                    // the tickPositioner below doesn't run or returns\n                    // undefined (like multiple years)\n                    if (defined(userOptions.linkedTo) &&\n                        !defined(userOptions.tickPixelInterval)) {\n                        gridAxisOptions.tickPixelInterval = 350;\n                    }\n                    // For the secondary grid axis, use the primary axis'\n                    // tick intervals and return ticks one level higher.\n                    if (\n                    // Check for tick pixel interval in options\n                    !defined(userOptions.tickPixelInterval) &&\n                        // Only for linked axes\n                        defined(userOptions.linkedTo) &&\n                        !defined(userOptions.tickPositioner) &&\n                        !defined(userOptions.tickInterval) &&\n                        !defined(userOptions.units)) {\n                        gridAxisOptions.tickPositioner = function (min, max) {\n                            const parentInfo = (this.linkedParent &&\n                                this.linkedParent.tickPositions &&\n                                this.linkedParent.tickPositions.info);\n                            if (parentInfo) {\n                                const units = (gridAxisOptions.units || []);\n                                let unitIdx, count = 1, unitName = 'year';\n                                for (let i = 0; i < units.length; i++) {\n                                    const unit = units[i];\n                                    if (unit && unit[0] === parentInfo.unitName) {\n                                        unitIdx = i;\n                                        break;\n                                    }\n                                }\n                                // Get the first allowed count on the next unit.\n                                const unit = (isNumber(unitIdx) && units[unitIdx + 1]);\n                                if (unit) {\n                                    unitName = unit[0] || 'year';\n                                    const counts = unit[1];\n                                    count = counts && counts[0] || 1;\n                                    // In case the base X axis shows years, make the\n                                    // secondary axis show ten times the years (#11427)\n                                }\n                                else if (parentInfo.unitName === 'year') {\n                                    // unitName is 'year'\n                                    count = parentInfo.count * 10;\n                                }\n                                const unitRange = timeUnits[unitName];\n                                this.tickInterval = unitRange * count;\n                                return this.chart.time.getTimeTicks({ unitRange, count, unitName }, min, max, this.options.startOfWeek);\n                            }\n                        };\n                    }\n                }\n                // Now merge the combined options into the axis options\n                merge(true, this.options, gridAxisOptions);\n                if (this.horiz) {\n                    /*               _________________________\n                    Make this:    ___|_____|_____|_____|__|\n                                    ^                     ^\n                                    _________________________\n                    Into this:    |_____|_____|_____|_____|\n                                        ^                 ^    */\n                    options.minPadding = pick(userOptions.minPadding, 0);\n                    options.maxPadding = pick(userOptions.maxPadding, 0);\n                }\n                // If borderWidth is set, then use its value for tick and\n                // line width.\n                if (isNumber(options.grid.borderWidth)) {\n                    options.tickWidth = options.lineWidth =\n                        gridOptions.borderWidth;\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onAfterSetOptions2(e) {\n            const axis = this;\n            const userOptions = e.userOptions;\n            const gridOptions = userOptions && userOptions.grid || {};\n            const columns = gridOptions.columns;\n            // Add column options to the parent axis. Children has their column options\n            // set on init in onGridAxisAfterInit.\n            if (gridOptions.enabled && columns) {\n                merge(true, axis.options, columns[0]);\n            }\n        }\n        /**\n         * Handle columns and setScale.\n         * @private\n         */\n        function onAfterSetScale() {\n            const axis = this;\n            (axis.grid.columns || []).forEach((column) => column.setScale());\n        }\n        /**\n         * Draw vertical axis ticks extra long to create cell floors and roofs.\n         * Overrides the tickLength for vertical axes.\n         * @private\n         */\n        function onAfterTickSize(e) {\n            const { horiz, maxLabelDimensions, options: { grid: gridOptions = {} } } = this;\n            if (gridOptions.enabled && maxLabelDimensions) {\n                const labelPadding = this.options.labels.distance * 2;\n                const distance = horiz ?\n                    (gridOptions.cellHeight ||\n                        labelPadding + maxLabelDimensions.height) :\n                    labelPadding + maxLabelDimensions.width;\n                if (isArray(e.tickSize)) {\n                    e.tickSize[0] = distance;\n                }\n                else {\n                    e.tickSize = [distance, 0];\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartAfterSetChartSize() {\n            this.axes.forEach((axis) => {\n                (axis.grid && axis.grid.columns || []).forEach((column) => {\n                    column.setAxisSize();\n                    column.setAxisTranslation();\n                });\n            });\n        }\n        /**\n         * @private\n         */\n        function onDestroy(e) {\n            const { grid } = this;\n            (grid.columns || []).forEach((column) => column.destroy(e.keepEvents));\n            grid.columns = void 0;\n        }\n        /**\n         * Wraps axis init to draw cell walls on vertical axes.\n         * @private\n         */\n        function onInit(e) {\n            const axis = this;\n            const userOptions = e.userOptions || {};\n            const gridOptions = userOptions.grid || {};\n            if (gridOptions.enabled && defined(gridOptions.borderColor)) {\n                userOptions.tickColor = userOptions.lineColor = (gridOptions.borderColor);\n            }\n            if (!axis.grid) {\n                axis.grid = new GridAxisAdditions(axis);\n            }\n            axis.hiddenLabels = [];\n            axis.hiddenMarks = [];\n        }\n        /**\n         * Center tick labels in cells.\n         * @private\n         */\n        function onTickAfterGetLabelPosition(e) {\n            const tick = this, label = tick.label, axis = tick.axis, reversed = axis.reversed, chart = axis.chart, options = axis.options, gridOptions = options.grid || {}, labelOpts = axis.options.labels, align = labelOpts.align, \n            // verticalAlign is currently not supported for axis.labels.\n            verticalAlign = 'middle', // labelOpts.verticalAlign,\n            side = GridAxisSide[axis.side], tickmarkOffset = e.tickmarkOffset, tickPositions = axis.tickPositions, tickPos = tick.pos - tickmarkOffset, nextTickPos = (isNumber(tickPositions[e.index + 1]) ?\n                tickPositions[e.index + 1] - tickmarkOffset :\n                (axis.max || 0) + tickmarkOffset), tickSize = axis.tickSize('tick'), tickWidth = tickSize ? tickSize[0] : 0, crispCorr = tickSize ? tickSize[1] / 2 : 0;\n            // Only center tick labels in grid axes\n            if (gridOptions.enabled === true) {\n                let bottom, top, left, right;\n                // Calculate top and bottom positions of the cell.\n                if (side === 'top') {\n                    bottom = axis.top + axis.offset;\n                    top = bottom - tickWidth;\n                }\n                else if (side === 'bottom') {\n                    top = chart.chartHeight - axis.bottom + axis.offset;\n                    bottom = top + tickWidth;\n                }\n                else {\n                    bottom = axis.top + axis.len - (axis.translate(reversed ? nextTickPos : tickPos) || 0);\n                    top = axis.top + axis.len - (axis.translate(reversed ? tickPos : nextTickPos) || 0);\n                }\n                // Calculate left and right positions of the cell.\n                if (side === 'right') {\n                    left = chart.chartWidth - axis.right + axis.offset;\n                    right = left + tickWidth;\n                }\n                else if (side === 'left') {\n                    right = axis.left + axis.offset;\n                    left = right - tickWidth;\n                }\n                else {\n                    left = Math.round(axis.left + (axis.translate(reversed ? nextTickPos : tickPos) || 0)) - crispCorr;\n                    right = Math.min(// #15742\n                    Math.round(axis.left + (axis.translate(reversed ? tickPos : nextTickPos) || 0)) - crispCorr, axis.left + axis.len);\n                }\n                tick.slotWidth = right - left;\n                // Calculate the positioning of the label based on\n                // alignment.\n                e.pos.x = (align === 'left' ?\n                    left :\n                    align === 'right' ?\n                        right :\n                        left + ((right - left) / 2) // default to center\n                );\n                e.pos.y = (verticalAlign === 'top' ?\n                    top :\n                    verticalAlign === 'bottom' ?\n                        bottom :\n                        top + ((bottom - top) / 2) // default to middle\n                );\n                if (label) {\n                    const lblMetrics = chart.renderer.fontMetrics(label), labelHeight = label.getBBox().height;\n                    // Adjustment to y position to align the label correctly.\n                    // Would be better to have a setter or similar for this.\n                    if (!labelOpts.useHTML) {\n                        const lines = Math.round(labelHeight / lblMetrics.h);\n                        e.pos.y += (\n                        // Center the label\n                        // TODO: why does this actually center the label?\n                        ((lblMetrics.b - (lblMetrics.h - lblMetrics.f)) / 2) +\n                            // Adjust for height of additional lines.\n                            -(((lines - 1) * lblMetrics.h) / 2));\n                    }\n                    else {\n                        e.pos.y += (\n                        // Readjust yCorr in htmlUpdateTransform\n                        lblMetrics.b +\n                            // Adjust for height of html label\n                            -(labelHeight / 2));\n                    }\n                }\n                e.pos.x += (axis.horiz && labelOpts.x) || 0;\n            }\n        }\n        /**\n         * @private\n         */\n        function onTickLabelFormat(ctx) {\n            const { axis, value } = ctx;\n            if (axis.options.grid &&\n                axis.options.grid.enabled) {\n                const tickPos = axis.tickPositions;\n                const series = (axis.linkedParent || axis).series[0];\n                const isFirst = value === tickPos[0];\n                const isLast = value === tickPos[tickPos.length - 1];\n                const point = series && find(series.options.data, function (p) {\n                    return p[axis.isXAxis ? 'x' : 'y'] === value;\n                });\n                let pointCopy;\n                if (point && series.is('gantt')) {\n                    // For the Gantt set point aliases to the pointCopy\n                    // to do not change the original point\n                    pointCopy = merge(point);\n                    H.seriesTypes.gantt.prototype.pointClass\n                        .setGanttPointAliases(pointCopy);\n                }\n                // Make additional properties available for the\n                // formatter\n                ctx.isFirst = isFirst;\n                ctx.isLast = isLast;\n                ctx.point = pointCopy;\n            }\n        }\n        /**\n         * Makes tick labels which are usually ignored in a linked axis\n         * displayed if they are within range of linkedParent.min.\n         * ```\n         *                        _____________________________\n         *                        |   |       |       |       |\n         * Make this:             |   |   2   |   3   |   4   |\n         *                        |___|_______|_______|_______|\n         *                          ^\n         *                        _____________________________\n         *                        |   |       |       |       |\n         * Into this:             | 1 |   2   |   3   |   4   |\n         *                        |___|_______|_______|_______|\n         *                          ^\n         * ```\n         * @private\n         * @todo Does this function do what the drawing says? Seems to affect\n         *       ticks and not the labels directly?\n         */\n        function onTrimTicks() {\n            const axis = this, options = axis.options, gridOptions = options.grid || {}, categoryAxis = axis.categories, tickPositions = axis.tickPositions, firstPos = tickPositions[0], secondPos = tickPositions[1], lastPos = tickPositions[tickPositions.length - 1], beforeLastPos = tickPositions[tickPositions.length - 2], linkedMin = axis.linkedParent && axis.linkedParent.min, linkedMax = axis.linkedParent && axis.linkedParent.max, min = linkedMin || axis.min, max = linkedMax || axis.max, tickInterval = axis.tickInterval, startLessThanMin = ( // #19845\n            isNumber(min) &&\n                min >= firstPos + tickInterval &&\n                min < secondPos), endMoreThanMin = (isNumber(min) &&\n                firstPos < min &&\n                firstPos + tickInterval > min), startLessThanMax = (isNumber(max) &&\n                lastPos > max &&\n                lastPos - tickInterval < max), endMoreThanMax = (isNumber(max) &&\n                max <= lastPos - tickInterval &&\n                max > beforeLastPos);\n            if (gridOptions.enabled === true &&\n                !categoryAxis &&\n                (axis.isXAxis || axis.isLinked)) {\n                if ((endMoreThanMin || startLessThanMin) && !options.startOnTick) {\n                    tickPositions[0] = min;\n                }\n                if ((startLessThanMax || endMoreThanMax) && !options.endOnTick) {\n                    tickPositions[tickPositions.length - 1] = max;\n                }\n            }\n        }\n        /**\n         * Avoid altering tickInterval when reserving space.\n         * @private\n         */\n        function wrapUnsquish(proceed) {\n            const axis = this;\n            const { options: { grid: gridOptions = {} } } = axis;\n            if (gridOptions.enabled === true && axis.categories) {\n                return axis.tickInterval;\n            }\n            return proceed.apply(axis, argsToArray(arguments));\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Additions for grid axes.\n         * @private\n         * @class\n         */\n        class GridAxisAdditions {\n            /* *\n            *\n            *  Constructors\n            *\n            * */\n            constructor(axis) {\n                this.axis = axis;\n            }\n            /* *\n            *\n            *  Functions\n            *\n            * */\n            /**\n             * Checks if an axis is the outer axis in its dimension. Since\n             * axes are placed outwards in order, the axis with the highest\n             * index is the outermost axis.\n             *\n             * Example: If there are multiple x-axes at the top of the chart,\n             * this function returns true if the axis supplied is the last\n             * of the x-axes.\n             *\n             * @private\n             *\n             * @return {boolean}\n             * True if the axis is the outermost axis in its dimension; false if\n             * not.\n             */\n            isOuterAxis() {\n                const axis = this.axis;\n                const chart = axis.chart;\n                const columnIndex = axis.grid.columnIndex;\n                const columns = (axis.linkedParent?.grid.columns ||\n                    axis.grid.columns ||\n                    []);\n                const parentAxis = columnIndex ? axis.linkedParent : axis;\n                let thisIndex = -1, lastIndex = 0;\n                // On the left side, when we have columns (not only multiple axes), the\n                // main axis is to the left\n                if (axis.side === 3 && !chart.inverted && columns.length) {\n                    return !axis.linkedParent;\n                }\n                (chart[axis.coll] || []).forEach((otherAxis, index) => {\n                    if (otherAxis.side === axis.side &&\n                        !otherAxis.options.isInternal) {\n                        lastIndex = index;\n                        if (otherAxis === parentAxis) {\n                            // Get the index of the axis in question\n                            thisIndex = index;\n                        }\n                    }\n                });\n                return (lastIndex === thisIndex &&\n                    (isNumber(columnIndex) ?\n                        columns.length === columnIndex :\n                        true));\n            }\n            /**\n             * Add extra border based on the provided path.\n             * @private\n             * @param {SVGPath} path\n             * The path of the border.\n             * @return {Highcharts.SVGElement}\n             * Border\n             */\n            renderBorder(path) {\n                const axis = this.axis, renderer = axis.chart.renderer, options = axis.options, extraBorderLine = renderer.path(path)\n                    .addClass('highcharts-axis-line')\n                    .add(axis.axisGroup);\n                if (!renderer.styledMode) {\n                    extraBorderLine.attr({\n                        stroke: options.lineColor,\n                        'stroke-width': options.lineWidth,\n                        zIndex: 7\n                    });\n                }\n                return extraBorderLine;\n            }\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        // First letter of the day of the week, e.g. 'M' for 'Monday'.\n        dateFormats.E = function (timestamp) {\n            return this.dateFormat('%a', timestamp, true).charAt(0);\n        };\n        // Adds week date format\n        dateFormats.W = function (timestamp) {\n            const time = this, d = new this.Date(timestamp), unitsToOmit = ['Hours', 'Milliseconds', 'Minutes', 'Seconds'];\n            unitsToOmit.forEach(function (format) {\n                time.set(format, d, 0);\n            });\n            const firstDay = (this.get('Day', d) + 6) % 7;\n            const thursday = new this.Date(d.valueOf());\n            this.set('Date', thursday, this.get('Date', d) - firstDay + 3);\n            const firstThursday = new this.Date(this.get('FullYear', thursday), 0, 1);\n            if (this.get('Day', firstThursday) !== 4) {\n                this.set('Month', d, 0);\n                this.set('Date', d, 1 + (11 - this.get('Day', firstThursday)) % 7);\n            }\n            return (1 +\n                Math.floor((thursday.valueOf() - firstThursday.valueOf()) / 604800000)).toString();\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const GridAxis = {\n            compose\n        };\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * @productdesc {gantt}\n         * For grid axes (like in Gantt charts),\n         * it is possible to declare as a list to provide different\n         * formats depending on available space.\n         *\n         * Defaults to:\n         * ```js\n         * {\n         *     hour: { list: ['%H:%M', '%H'] },\n         *     day: { list: ['%A, %e. %B', '%a, %e. %b', '%E'] },\n         *     week: { list: ['Week %W', 'W%W'] },\n         *     month: { list: ['%B', '%b', '%o'] }\n         * }\n         * ```\n         *\n         * @sample {gantt} gantt/grid-axis/date-time-label-formats\n         *         Gantt chart with custom axis date format.\n         *\n         * @apioption xAxis.dateTimeLabelFormats\n         */\n        /**\n         * Set grid options for the axis labels. Requires Highcharts Gantt.\n         *\n         * @since     6.2.0\n         * @product   gantt\n         * @apioption xAxis.grid\n         */\n        /**\n         * Enable grid on the axis labels. Defaults to true for Gantt charts.\n         *\n         * @type      {boolean}\n         * @default   true\n         * @since     6.2.0\n         * @product   gantt\n         * @apioption xAxis.grid.enabled\n         */\n        /**\n         * Set specific options for each column (or row for horizontal axes) in the\n         * grid. Each extra column/row is its own axis, and the axis options can be set\n         * here.\n         *\n         * @sample gantt/demo/left-axis-table\n         *         Left axis as a table\n         * @sample gantt/demo/treegrid-columns\n         *         Collapsible tree grid with columns\n         *\n         * @type      {Array<Highcharts.XAxisOptions>}\n         * @apioption xAxis.grid.columns\n         */\n        /**\n         * Set border color for the label grid lines.\n         *\n         * @type      {Highcharts.ColorString}\n         * @default   #e6e6e6\n         * @apioption xAxis.grid.borderColor\n         */\n        /**\n         * Set border width of the label grid lines.\n         *\n         * @type      {number}\n         * @default   1\n         * @apioption xAxis.grid.borderWidth\n         */\n        /**\n         * Set cell height for grid axis labels. By default this is calculated from font\n         * size. This option only applies to horizontal axes. For vertical axes, check\n         * the [#yAxis.staticScale](yAxis.staticScale) option.\n         *\n         * @sample gantt/grid-axis/cellheight\n         *         Gant chart with custom cell height\n         * @type      {number}\n         * @apioption xAxis.grid.cellHeight\n         */\n        ''; // keeps doclets above in JS file\n\n        return GridAxis;\n    });\n    _registerModule(_modules, 'Gantt/Tree.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Imports\n         *\n         * */\n        const { extend, isNumber, pick } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Creates an object map from parent id to children's index.\n         *\n         * @private\n         * @function Highcharts.Tree#getListOfParents\n         *\n         * @param {Array<*>} data\n         *        List of points set in options. `Array.parent` is parent id of point.\n         *\n         * @param {Array<string>} ids\n         *        List of all point ids.\n         *\n         * @return {Highcharts.Dictionary<Array<*>>}\n         * Map from parent id to children index in data\n         */\n        function getListOfParents(data) {\n            const root = '', ids = [], listOfParents = data.reduce((prev, curr) => {\n                const { parent = '', id } = curr;\n                if (typeof prev[parent] === 'undefined') {\n                    prev[parent] = [];\n                }\n                prev[parent].push(curr);\n                if (id) {\n                    ids.push(id);\n                }\n                return prev;\n            }, {});\n            Object.keys(listOfParents).forEach((node) => {\n                if ((node !== root) && (ids.indexOf(node) === -1)) {\n                    const adoptedByRoot = listOfParents[node].map(function (orphan) {\n                        const { ...parentExcluded } = orphan; // #15196\n                        return parentExcluded;\n                    });\n                    listOfParents[root].push(...adoptedByRoot);\n                    delete listOfParents[node];\n                }\n            });\n            return listOfParents;\n        }\n        /** @private */\n        function getNode(id, parent, level, data, mapOfIdToChildren, options) {\n            const after = options && options.after, before = options && options.before, node = {\n                data,\n                depth: level - 1,\n                id,\n                level,\n                parent: (parent || '')\n            };\n            let descendants = 0, height = 0, start, end;\n            // Allow custom logic before the children has been created.\n            if (typeof before === 'function') {\n                before(node, options);\n            }\n            // Call getNode recursively on the children. Calculate the height of the\n            // node, and the number of descendants.\n            const children = ((mapOfIdToChildren[id] || [])).map((child) => {\n                const node = getNode(child.id, id, (level + 1), child, mapOfIdToChildren, options), childStart = child.start || NaN, childEnd = (child.milestone === true ?\n                    childStart :\n                    child.end ||\n                        NaN);\n                // Start should be the lowest child.start.\n                start = ((!isNumber(start) || childStart < start) ?\n                    childStart :\n                    start);\n                // End should be the largest child.end.\n                // If child is milestone, then use start as end.\n                end = ((!isNumber(end) || childEnd > end) ?\n                    childEnd :\n                    end);\n                descendants = descendants + 1 + node.descendants;\n                height = Math.max(node.height + 1, height);\n                return node;\n            });\n            // Calculate start and end for point if it is not already explicitly set.\n            if (data) {\n                data.start = pick(data.start, start);\n                data.end = pick(data.end, end);\n            }\n            extend(node, {\n                children: children,\n                descendants: descendants,\n                height: height\n            });\n            // Allow custom logic after the children has been created.\n            if (typeof after === 'function') {\n                after(node, options);\n            }\n            return node;\n        }\n        /** @private */\n        function getTree(data, options) {\n            return getNode('', null, 1, null, getListOfParents(data), options);\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const Tree = {\n            getNode,\n            getTree\n        };\n\n        return Tree;\n    });\n    _registerModule(_modules, 'Core/Axis/TreeGrid/TreeGridTick.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { addEvent, removeEvent, isObject, isNumber, pick, wrap } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function onTickInit() {\n            const tick = this;\n            if (!tick.treeGrid) {\n                tick.treeGrid = new TreeGridTickAdditions(tick);\n            }\n        }\n        /**\n         * @private\n         */\n        function onTickHover(label) {\n            label.addClass('highcharts-treegrid-node-active');\n            if (!label.renderer.styledMode) {\n                label.css({\n                    textDecoration: 'underline'\n                });\n            }\n        }\n        /**\n         * @private\n         */\n        function onTickHoverExit(label, options) {\n            const css = isObject(options.style) ? options.style : {};\n            label.removeClass('highcharts-treegrid-node-active');\n            if (!label.renderer.styledMode) {\n                label.css({ textDecoration: (css.textDecoration || 'none') });\n            }\n        }\n        /**\n         * @private\n         */\n        function renderLabelIcon(tick, params) {\n            const treeGrid = tick.treeGrid, isNew = !treeGrid.labelIcon, renderer = params.renderer, labelBox = params.xy, options = params.options, width = options.width || 0, height = options.height || 0, padding = options.padding ?? tick.axis.linkedParent ? 0 : 5, iconCenter = {\n                x: labelBox.x - (width / 2) - padding,\n                y: labelBox.y - (height / 2)\n            }, rotation = params.collapsed ? 90 : 180, shouldRender = params.show && isNumber(iconCenter.y);\n            let icon = treeGrid.labelIcon;\n            if (!icon) {\n                treeGrid.labelIcon = icon = renderer\n                    .path(renderer.symbols[options.type](options.x || 0, options.y || 0, width, height))\n                    .addClass('highcharts-label-icon')\n                    .add(params.group);\n            }\n            // Set the new position, and show or hide\n            icon[shouldRender ? 'show' : 'hide'](); // #14904, #1338\n            // Presentational attributes\n            if (!renderer.styledMode) {\n                icon\n                    .attr({\n                    cursor: 'pointer',\n                    'fill': pick(params.color, \"#666666\" /* Palette.neutralColor60 */),\n                    'stroke-width': 1,\n                    stroke: options.lineColor,\n                    strokeWidth: options.lineWidth || 0\n                });\n            }\n            // Update the icon positions\n            icon[isNew ? 'attr' : 'animate']({\n                translateX: iconCenter.x,\n                translateY: iconCenter.y,\n                rotation: rotation\n            });\n        }\n        /**\n         * @private\n         */\n        function wrapGetLabelPosition(proceed, x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n            const tick = this, lbOptions = pick(tick.options && tick.options.labels, labelOptions), pos = tick.pos, axis = tick.axis, options = axis.options, isTreeGrid = options.type === 'treegrid', result = proceed.apply(tick, [x, y, label, horiz, lbOptions, tickmarkOffset, index, step]);\n            let mapOfPosToGridNode, node, level;\n            if (isTreeGrid) {\n                const { width = 0, padding = axis.linkedParent ? 0 : 5 } = (lbOptions && isObject(lbOptions.symbol, true) ?\n                    lbOptions.symbol :\n                    {}), indentation = (lbOptions && isNumber(lbOptions.indentation) ?\n                    lbOptions.indentation :\n                    0);\n                mapOfPosToGridNode = axis.treeGrid.mapOfPosToGridNode;\n                node = mapOfPosToGridNode && mapOfPosToGridNode[pos];\n                level = (node && node.depth) || 1;\n                result.x += (\n                // Add space for symbols\n                (width + (padding * 2)) +\n                    // Apply indentation\n                    ((level - 1) * indentation));\n            }\n            return result;\n        }\n        /**\n         * @private\n         */\n        function wrapRenderLabel(proceed) {\n            const tick = this, { pos, axis, label, treeGrid: tickGrid, options: tickOptions } = tick, icon = tickGrid?.labelIcon, labelElement = label?.element, { treeGrid: axisGrid, options: axisOptions, chart, tickPositions } = axis, mapOfPosToGridNode = axisGrid.mapOfPosToGridNode, labelOptions = pick(tickOptions?.labels, axisOptions?.labels), symbolOptions = (labelOptions && isObject(labelOptions.symbol, true) ?\n                labelOptions.symbol :\n                {}), node = mapOfPosToGridNode && mapOfPosToGridNode[pos], { descendants, depth } = node || {}, hasDescendants = node && descendants && descendants > 0, level = depth, isTreeGridElement = (axisOptions.type === 'treegrid') && labelElement, shouldRender = tickPositions.indexOf(pos) > -1, prefixClassName = 'highcharts-treegrid-node-', prefixLevelClass = prefixClassName + 'level-', styledMode = chart.styledMode;\n            let collapsed, addClassName, removeClassName;\n            if (isTreeGridElement && node) {\n                // Add class name for hierarchical styling.\n                label\n                    .removeClass(new RegExp(prefixLevelClass + '.*'))\n                    .addClass(prefixLevelClass + level);\n            }\n            proceed.apply(tick, Array.prototype.slice.call(arguments, 1));\n            if (isTreeGridElement && hasDescendants) {\n                collapsed = axisGrid.isCollapsed(node);\n                renderLabelIcon(tick, {\n                    color: (!styledMode &&\n                        label.styles.color ||\n                        ''),\n                    collapsed: collapsed,\n                    group: label.parentGroup,\n                    options: symbolOptions,\n                    renderer: label.renderer,\n                    show: shouldRender,\n                    xy: label.xy\n                });\n                // Add class name for the node.\n                addClassName = prefixClassName +\n                    (collapsed ? 'collapsed' : 'expanded');\n                removeClassName = prefixClassName +\n                    (collapsed ? 'expanded' : 'collapsed');\n                label\n                    .addClass(addClassName)\n                    .removeClass(removeClassName);\n                if (!styledMode) {\n                    label.css({\n                        cursor: 'pointer'\n                    });\n                }\n                // Add events to both label text and icon\n                [label, icon].forEach((object) => {\n                    if (object && !object.attachedTreeGridEvents) {\n                        // On hover\n                        addEvent(object.element, 'mouseover', function () {\n                            onTickHover(label);\n                        });\n                        // On hover out\n                        addEvent(object.element, 'mouseout', function () {\n                            onTickHoverExit(label, labelOptions);\n                        });\n                        addEvent(object.element, 'click', function () {\n                            tickGrid.toggleCollapse();\n                        });\n                        object.attachedTreeGridEvents = true;\n                    }\n                });\n            }\n            else if (icon) {\n                removeEvent(labelElement);\n                label?.css({ cursor: 'default' });\n                icon.destroy();\n            }\n        }\n        /* *\n         *\n         *  Classes\n         *\n         * */\n        /**\n         * @private\n         * @class\n         */\n        class TreeGridTickAdditions {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            static compose(TickClass) {\n                const tickProto = TickClass.prototype;\n                if (!tickProto.toggleCollapse) {\n                    addEvent(TickClass, 'init', onTickInit);\n                    wrap(tickProto, 'getLabelPosition', wrapGetLabelPosition);\n                    wrap(tickProto, 'renderLabel', wrapRenderLabel);\n                    // backwards compatibility\n                    tickProto.collapse = function (redraw) {\n                        this.treeGrid.collapse(redraw);\n                    };\n                    tickProto.expand = function (redraw) {\n                        this.treeGrid.expand(redraw);\n                    };\n                    tickProto.toggleCollapse = function (redraw) {\n                        this.treeGrid.toggleCollapse(redraw);\n                    };\n                }\n            }\n            /* *\n             *\n             *  Constructors\n             *\n             * */\n            /**\n             * @private\n             */\n            constructor(tick) {\n                this.tick = tick;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Collapse the grid cell. Used when axis is of type treegrid.\n             *\n             * @see gantt/treegrid-axis/collapsed-dynamically/demo.js\n             *\n             * @private\n             * @function Highcharts.Tick#collapse\n             *\n             * @param {boolean} [redraw=true]\n             * Whether to redraw the chart or wait for an explicit call to\n             * {@link Highcharts.Chart#redraw}\n             */\n            collapse(redraw) {\n                const tick = this.tick, axis = tick.axis, brokenAxis = axis.brokenAxis;\n                if (brokenAxis &&\n                    axis.treeGrid.mapOfPosToGridNode) {\n                    const pos = tick.pos, node = axis.treeGrid.mapOfPosToGridNode[pos], breaks = axis.treeGrid.collapse(node);\n                    brokenAxis.setBreaks(breaks, pick(redraw, true));\n                }\n            }\n            /**\n             * Destroy remaining labelIcon if exist.\n             *\n             * @private\n             * @function Highcharts.Tick#destroy\n             */\n            destroy() {\n                if (this.labelIcon) {\n                    this.labelIcon.destroy();\n                }\n            }\n            /**\n             * Expand the grid cell. Used when axis is of type treegrid.\n             *\n             * @see gantt/treegrid-axis/collapsed-dynamically/demo.js\n             *\n             * @private\n             * @function Highcharts.Tick#expand\n             *\n             * @param {boolean} [redraw=true]\n             * Whether to redraw the chart or wait for an explicit call to\n             * {@link Highcharts.Chart#redraw}\n             */\n            expand(redraw) {\n                const { pos, axis } = this.tick, { treeGrid, brokenAxis } = axis, posMappedNodes = treeGrid.mapOfPosToGridNode;\n                if (brokenAxis && posMappedNodes) {\n                    const node = posMappedNodes[pos], breaks = treeGrid.expand(node);\n                    brokenAxis.setBreaks(breaks, pick(redraw, true));\n                }\n            }\n            /**\n             * Toggle the collapse/expand state of the grid cell. Used when axis is\n             * of type treegrid.\n             *\n             * @see gantt/treegrid-axis/collapsed-dynamically/demo.js\n             *\n             * @private\n             * @function Highcharts.Tick#toggleCollapse\n             *\n             * @param {boolean} [redraw=true]\n             * Whether to redraw the chart or wait for an explicit call to\n             * {@link Highcharts.Chart#redraw}\n             */\n            toggleCollapse(redraw) {\n                const tick = this.tick, axis = tick.axis, brokenAxis = axis.brokenAxis;\n                if (brokenAxis &&\n                    axis.treeGrid.mapOfPosToGridNode) {\n                    const pos = tick.pos, node = axis.treeGrid.mapOfPosToGridNode[pos], breaks = axis.treeGrid.toggleCollapse(node);\n                    brokenAxis.setBreaks(breaks, pick(redraw, true));\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return TreeGridTickAdditions;\n    });\n    _registerModule(_modules, 'Series/TreeUtilities.js', [_modules['Core/Color/Color.js'], _modules['Core/Utilities.js']], function (Color, U) {\n        /* *\n         *\n         *  (c) 2014-2024 Highsoft AS\n         *\n         *  Authors: Jon Arild Nygard / Oystein Moseng\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { extend, isArray, isNumber, isObject, merge, pick, relativeLength } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * @private\n         */\n        function getColor(node, options) {\n            const index = options.index, mapOptionsToLevel = options.mapOptionsToLevel, parentColor = options.parentColor, parentColorIndex = options.parentColorIndex, series = options.series, colors = options.colors, siblings = options.siblings, points = series.points, chartOptionsChart = series.chart.options.chart;\n            let getColorByPoint, point, level, colorByPoint, colorIndexByPoint, color, colorIndex;\n            /**\n             * @private\n             */\n            const variateColor = (color) => {\n                const colorVariation = level && level.colorVariation;\n                if (colorVariation &&\n                    colorVariation.key === 'brightness' &&\n                    index &&\n                    siblings) {\n                    return Color.parse(color).brighten(colorVariation.to * (index / siblings)).get();\n                }\n                return color;\n            };\n            if (node) {\n                point = points[node.i];\n                level = mapOptionsToLevel[node.level] || {};\n                getColorByPoint = point && level.colorByPoint;\n                if (getColorByPoint) {\n                    colorIndexByPoint = point.index % (colors ?\n                        colors.length :\n                        chartOptionsChart.colorCount);\n                    colorByPoint = colors && colors[colorIndexByPoint];\n                }\n                // Select either point color, level color or inherited color.\n                if (!series.chart.styledMode) {\n                    color = pick(point && point.options.color, level && level.color, colorByPoint, parentColor && variateColor(parentColor), series.color);\n                }\n                colorIndex = pick(point && point.options.colorIndex, level && level.colorIndex, colorIndexByPoint, parentColorIndex, options.colorIndex);\n            }\n            return {\n                color: color,\n                colorIndex: colorIndex\n            };\n        }\n        /**\n         * Creates a map from level number to its given options.\n         *\n         * @private\n         *\n         * @param {Object} params\n         * Object containing parameters.\n         * - `defaults` Object containing default options. The default options are\n         *   merged with the userOptions to get the final options for a specific\n         *   level.\n         * - `from` The lowest level number.\n         * - `levels` User options from series.levels.\n         * - `to` The highest level number.\n         *\n         * @return {Highcharts.Dictionary<object>|null}\n         * Returns a map from level number to its given options.\n         */\n        function getLevelOptions(params) {\n            let result = {}, defaults, converted, i, from, to, levels;\n            if (isObject(params)) {\n                from = isNumber(params.from) ? params.from : 1;\n                levels = params.levels;\n                converted = {};\n                defaults = isObject(params.defaults) ? params.defaults : {};\n                if (isArray(levels)) {\n                    converted = levels.reduce((obj, item) => {\n                        let level, levelIsConstant, options;\n                        if (isObject(item) && isNumber(item.level)) {\n                            options = merge({}, item);\n                            levelIsConstant = pick(options.levelIsConstant, defaults.levelIsConstant);\n                            // Delete redundant properties.\n                            delete options.levelIsConstant;\n                            delete options.level;\n                            // Calculate which level these options apply to.\n                            level = item.level + (levelIsConstant ? 0 : from - 1);\n                            if (isObject(obj[level])) {\n                                merge(true, obj[level], options); // #16329\n                            }\n                            else {\n                                obj[level] = options;\n                            }\n                        }\n                        return obj;\n                    }, {});\n                }\n                to = isNumber(params.to) ? params.to : 1;\n                for (i = 0; i <= to; i++) {\n                    result[i] = merge({}, defaults, isObject(converted[i]) ? converted[i] : {});\n                }\n            }\n            return result;\n        }\n        /**\n         * @private\n         * @todo Combine buildTree and buildNode with setTreeValues\n         * @todo Remove logic from Treemap and make it utilize this mixin.\n         */\n        function setTreeValues(tree, options) {\n            const before = options.before, idRoot = options.idRoot, mapIdToNode = options.mapIdToNode, nodeRoot = mapIdToNode[idRoot], levelIsConstant = (options.levelIsConstant !== false), points = options.points, point = points[tree.i], optionsPoint = point && point.options || {}, children = [];\n            let childrenTotal = 0;\n            tree.levelDynamic = tree.level - (levelIsConstant ? 0 : nodeRoot.level);\n            tree.name = pick(point && point.name, '');\n            tree.visible = (idRoot === tree.id ||\n                options.visible === true);\n            if (typeof before === 'function') {\n                tree = before(tree, options);\n            }\n            // First give the children some values\n            tree.children.forEach((child, i) => {\n                const newOptions = extend({}, options);\n                extend(newOptions, {\n                    index: i,\n                    siblings: tree.children.length,\n                    visible: tree.visible\n                });\n                child = setTreeValues(child, newOptions);\n                children.push(child);\n                if (child.visible) {\n                    childrenTotal += child.val;\n                }\n            });\n            // Set the values\n            const value = pick(optionsPoint.value, childrenTotal);\n            tree.visible = value >= 0 && (childrenTotal > 0 || tree.visible);\n            tree.children = children;\n            tree.childrenTotal = childrenTotal;\n            tree.isLeaf = tree.visible && !childrenTotal;\n            tree.val = value;\n            return tree;\n        }\n        /**\n         * Update the rootId property on the series. Also makes sure that it is\n         * accessible to exporting.\n         *\n         * @private\n         *\n         * @param {Object} series\n         * The series to operate on.\n         *\n         * @return {string}\n         * Returns the resulting rootId after update.\n         */\n        function updateRootId(series) {\n            let rootId, options;\n            if (isObject(series)) {\n                // Get the series options.\n                options = isObject(series.options) ? series.options : {};\n                // Calculate the rootId.\n                rootId = pick(series.rootNode, options.rootId, '');\n                // Set rootId on series.userOptions to pick it up in exporting.\n                if (isObject(series.userOptions)) {\n                    series.userOptions.rootId = rootId;\n                }\n                // Set rootId on series to pick it up on next update.\n                series.rootNode = rootId;\n            }\n            return rootId;\n        }\n        /**\n         * Get the node width, which relies on the plot width and the nodeDistance\n         * option.\n         *\n         * @private\n         */\n        function getNodeWidth(series, columnCount) {\n            const { chart, options } = series, { nodeDistance = 0, nodeWidth = 0 } = options, { plotSizeX = 1 } = chart;\n            // Node width auto means they are evenly distributed along the width of\n            // the plot area\n            if (nodeWidth === 'auto') {\n                if (typeof nodeDistance === 'string' && /%$/.test(nodeDistance)) {\n                    const fraction = parseFloat(nodeDistance) / 100, total = columnCount + fraction * (columnCount - 1);\n                    return plotSizeX / total;\n                }\n                const nDistance = Number(nodeDistance);\n                return ((plotSizeX + nDistance) /\n                    (columnCount || 1)) - nDistance;\n            }\n            return relativeLength(nodeWidth, plotSizeX);\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const TreeUtilities = {\n            getColor,\n            getLevelOptions,\n            getNodeWidth,\n            setTreeValues,\n            updateRootId\n        };\n\n        return TreeUtilities;\n    });\n    _registerModule(_modules, 'Core/Axis/TreeGrid/TreeGridAxis.js', [_modules['Core/Axis/BrokenAxis.js'], _modules['Core/Axis/GridAxis.js'], _modules['Gantt/Tree.js'], _modules['Core/Axis/TreeGrid/TreeGridTick.js'], _modules['Series/TreeUtilities.js'], _modules['Core/Utilities.js']], function (BrokenAxis, GridAxis, Tree, TreeGridTick, TU, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { getLevelOptions } = TU;\n        const { addEvent, find, fireEvent, isArray, isObject, isString, merge, pick, removeEvent, wrap } = U;\n        /* *\n         *\n         *  Variables\n         *\n         * */\n        let TickConstructor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function getBreakFromNode(node, max) {\n            const to = node.collapseEnd || 0;\n            let from = node.collapseStart || 0;\n            // In broken-axis, the axis.max is minimized until it is not within a\n            // break. Therefore, if break.to is larger than axis.max, the axis.to\n            // should not add the 0.5 axis.tickMarkOffset, to avoid adding a break\n            // larger than axis.max.\n            // TODO consider simplifying broken-axis and this might solve itself\n            if (to >= max) {\n                from -= 0.5;\n            }\n            return {\n                from: from,\n                to: to,\n                showPoints: false\n            };\n        }\n        /**\n         * Creates a tree structure of the data, and the treegrid. Calculates\n         * categories, and y-values of points based on the tree.\n         *\n         * @private\n         * @function getTreeGridFromData\n         *\n         * @param {Array<Highcharts.GanttPointOptions>} data\n         * All the data points to display in the axis.\n         *\n         * @param {boolean} uniqueNames\n         * Whether or not the data node with the same name should share grid cell. If\n         * true they do share cell. False by default.\n         *\n         * @param {number} numberOfSeries\n         *\n         * @return {Object}\n         * Returns an object containing categories, mapOfIdToNode,\n         * mapOfPosToGridNode, and tree.\n         *\n         * @todo There should be only one point per line.\n         * @todo It should be optional to have one category per point, or merge\n         *       cells\n         * @todo Add unit-tests.\n         */\n        function getTreeGridFromData(data, uniqueNames, numberOfSeries) {\n            const categories = [], collapsedNodes = [], mapOfIdToNode = {}, uniqueNamesEnabled = typeof uniqueNames === 'boolean' ?\n                uniqueNames : false;\n            let mapOfPosToGridNode = {}, posIterator = -1;\n            // Build the tree from the series data.\n            const treeParams = {\n                // After the children has been created.\n                after: function (node) {\n                    const gridNode = mapOfPosToGridNode[node.pos];\n                    let height = 0, descendants = 0;\n                    gridNode.children.forEach(function (child) {\n                        descendants += (child.descendants || 0) + 1;\n                        height = Math.max((child.height || 0) + 1, height);\n                    });\n                    gridNode.descendants = descendants;\n                    gridNode.height = height;\n                    if (gridNode.collapsed) {\n                        collapsedNodes.push(gridNode);\n                    }\n                },\n                // Before the children has been created.\n                before: function (node) {\n                    const data = isObject(node.data, true) ?\n                        node.data :\n                        {}, name = isString(data.name) ? data.name : '', parentNode = mapOfIdToNode[node.parent], parentGridNode = (isObject(parentNode, true) ?\n                        mapOfPosToGridNode[parentNode.pos] :\n                        null), hasSameName = function (x) {\n                        return x.name === name;\n                    };\n                    let gridNode, pos;\n                    // If not unique names, look for sibling node with the same name\n                    if (uniqueNamesEnabled &&\n                        isObject(parentGridNode, true) &&\n                        !!(gridNode = find(parentGridNode.children, hasSameName))) {\n                        // If there is a gridNode with the same name, reuse position\n                        pos = gridNode.pos;\n                        // Add data node to list of nodes in the grid node.\n                        gridNode.nodes.push(node);\n                    }\n                    else {\n                        // If it is a new grid node, increment position.\n                        pos = posIterator++;\n                    }\n                    // Add new grid node to map.\n                    if (!mapOfPosToGridNode[pos]) {\n                        mapOfPosToGridNode[pos] = gridNode = {\n                            depth: parentGridNode ? parentGridNode.depth + 1 : 0,\n                            name: name,\n                            id: data.id,\n                            nodes: [node],\n                            children: [],\n                            pos: pos\n                        };\n                        // If not root, then add name to categories.\n                        if (pos !== -1) {\n                            categories.push(name);\n                        }\n                        // Add name to list of children.\n                        if (isObject(parentGridNode, true)) {\n                            parentGridNode.children.push(gridNode);\n                        }\n                    }\n                    // Add data node to map\n                    if (isString(node.id)) {\n                        mapOfIdToNode[node.id] = node;\n                    }\n                    // If one of the points are collapsed, then start the grid node\n                    // in collapsed state.\n                    if (gridNode &&\n                        data.collapsed === true) {\n                        gridNode.collapsed = true;\n                    }\n                    // Assign pos to data node\n                    node.pos = pos;\n                }\n            };\n            const updateYValuesAndTickPos = function (map, numberOfSeries) {\n                const setValues = function (gridNode, start, result) {\n                    const nodes = gridNode.nodes, padding = 0.5;\n                    let end = start + (start === -1 ? 0 : numberOfSeries - 1);\n                    const diff = (end - start) / 2, pos = start + diff;\n                    nodes.forEach(function (node) {\n                        const data = node.data;\n                        if (isObject(data, true)) {\n                            // Update point\n                            data.y = start + (data.seriesIndex || 0);\n                            // Remove the property once used\n                            delete data.seriesIndex;\n                        }\n                        node.pos = pos;\n                    });\n                    result[pos] = gridNode;\n                    gridNode.pos = pos;\n                    gridNode.tickmarkOffset = diff + padding;\n                    gridNode.collapseStart = end + padding;\n                    gridNode.children.forEach(function (child) {\n                        setValues(child, end + 1, result);\n                        end = (child.collapseEnd || 0) - padding;\n                    });\n                    // Set collapseEnd to the end of the last child node.\n                    gridNode.collapseEnd = end + padding;\n                    return result;\n                };\n                return setValues(map['-1'], -1, {});\n            };\n            // Create tree from data\n            const tree = Tree.getTree(data, treeParams);\n            // Update y values of data, and set calculate tick positions.\n            mapOfPosToGridNode = updateYValuesAndTickPos(mapOfPosToGridNode, numberOfSeries);\n            // Return the resulting data.\n            return {\n                categories: categories,\n                mapOfIdToNode: mapOfIdToNode,\n                mapOfPosToGridNode: mapOfPosToGridNode,\n                collapsedNodes: collapsedNodes,\n                tree: tree\n            };\n        }\n        /**\n         * Builds the tree of categories and calculates its positions.\n         * @private\n         * @param {Object} e Event object\n         * @param {Object} e.target The chart instance which the event was fired on.\n         * @param {object[]} e.target.axes The axes of the chart.\n         */\n        function onBeforeRender(e) {\n            const chart = e.target, axes = chart.axes;\n            axes.filter(function (axis) {\n                return axis.options.type === 'treegrid';\n            }).forEach(function (axis) {\n                const options = axis.options || {}, labelOptions = options.labels, uniqueNames = options.uniqueNames, max = options.max, \n                // Check whether any of series is rendering for the first\n                // time, visibility has changed, or its data is dirty, and\n                // only then update. #10570, #10580. Also check if\n                // mapOfPosToGridNode exists. #10887\n                isDirty = (!axis.treeGrid.mapOfPosToGridNode ||\n                    axis.series.some(function (series) {\n                        return !series.hasRendered ||\n                            series.isDirtyData ||\n                            series.isDirty;\n                    }));\n                let numberOfSeries = 0, data, treeGrid;\n                if (isDirty) {\n                    // Concatenate data from all series assigned to this axis.\n                    data = axis.series.reduce(function (arr, s) {\n                        if (s.visible) {\n                            // Push all data to array\n                            (s.options.data || []).forEach(function (data) {\n                                // For using keys - rebuild the data structure\n                                if (s.options.keys && s.options.keys.length) {\n                                    data = s.pointClass.prototype\n                                        .optionsToObject\n                                        .call({ series: s }, data);\n                                    s.pointClass.setGanttPointAliases(data);\n                                }\n                                if (isObject(data, true)) {\n                                    // Set series index on data. Removed again\n                                    // after use.\n                                    data.seriesIndex = (numberOfSeries);\n                                    arr.push(data);\n                                }\n                            });\n                            // Increment series index\n                            if (uniqueNames === true) {\n                                numberOfSeries++;\n                            }\n                        }\n                        return arr;\n                    }, []);\n                    // If max is higher than set data - add a\n                    // dummy data to render categories #10779\n                    if (max && data.length < max) {\n                        for (let i = data.length; i <= max; i++) {\n                            data.push({\n                                // Use the zero-width character\n                                // to avoid conflict with uniqueNames\n                                name: i + '\\u200B'\n                            });\n                        }\n                    }\n                    // setScale is fired after all the series is initialized,\n                    // which is an ideal time to update the axis.categories.\n                    treeGrid = getTreeGridFromData(data, uniqueNames || false, (uniqueNames === true) ? numberOfSeries : 1);\n                    // Assign values to the axis.\n                    axis.categories = treeGrid.categories;\n                    axis.treeGrid.mapOfPosToGridNode = (treeGrid.mapOfPosToGridNode);\n                    axis.hasNames = true;\n                    axis.treeGrid.tree = treeGrid.tree;\n                    // Update yData now that we have calculated the y values\n                    axis.series.forEach(function (series) {\n                        const axisData = (series.options.data || []).map(function (d) {\n                            if (isArray(d) &&\n                                series.options.keys &&\n                                series.options.keys.length) {\n                                // Get the axisData from the data array used to\n                                // build the treeGrid where has been modified\n                                data.forEach(function (point) {\n                                    if (d.indexOf(point.x) >= 0 &&\n                                        d.indexOf(point.x2) >= 0) {\n                                        d = point;\n                                    }\n                                });\n                            }\n                            return isObject(d, true) ? merge(d) : d;\n                        });\n                        // Avoid destroying points when series is not visible\n                        if (series.visible) {\n                            series.setData(axisData, false);\n                        }\n                    });\n                    // Calculate the label options for each level in the tree.\n                    axis.treeGrid.mapOptionsToLevel =\n                        getLevelOptions({\n                            defaults: labelOptions,\n                            from: 1,\n                            levels: labelOptions && labelOptions.levels,\n                            to: axis.treeGrid.tree && axis.treeGrid.tree.height\n                        });\n                    // Setting initial collapsed nodes\n                    if (e.type === 'beforeRender') {\n                        axis.treeGrid.collapsedNodes = treeGrid.collapsedNodes;\n                    }\n                }\n            });\n        }\n        /**\n         * Generates a tick for initial positioning.\n         *\n         * @private\n         * @function Highcharts.GridAxis#generateTick\n         *\n         * @param {Function} proceed\n         * The original generateTick function.\n         *\n         * @param {number} pos\n         * The tick position in axis values.\n         */\n        function wrapGenerateTick(proceed, pos) {\n            const axis = this, mapOptionsToLevel = axis.treeGrid.mapOptionsToLevel || {}, isTreeGrid = axis.options.type === 'treegrid', ticks = axis.ticks;\n            let tick = ticks[pos], levelOptions, options, gridNode;\n            if (isTreeGrid &&\n                axis.treeGrid.mapOfPosToGridNode) {\n                gridNode = axis.treeGrid.mapOfPosToGridNode[pos];\n                levelOptions = mapOptionsToLevel[gridNode.depth];\n                if (levelOptions) {\n                    options = {\n                        labels: levelOptions\n                    };\n                }\n                if (!tick &&\n                    TickConstructor) {\n                    ticks[pos] = tick =\n                        new TickConstructor(axis, pos, void 0, void 0, {\n                            category: gridNode.name,\n                            tickmarkOffset: gridNode.tickmarkOffset,\n                            options: options\n                        });\n                }\n                else {\n                    // update labels depending on tick interval\n                    tick.parameters.category = gridNode.name;\n                    tick.options = options;\n                    tick.addLabel();\n                }\n            }\n            else {\n                proceed.apply(axis, Array.prototype.slice.call(arguments, 1));\n            }\n        }\n        /**\n         * @private\n         */\n        function wrapInit(proceed, chart, userOptions, coll) {\n            const axis = this, isTreeGrid = userOptions.type === 'treegrid';\n            if (!axis.treeGrid) {\n                axis.treeGrid = new TreeGridAxisAdditions(axis);\n            }\n            // Set default and forced options for TreeGrid\n            if (isTreeGrid) {\n                // Add event for updating the categories of a treegrid.\n                // NOTE Preferably these events should be set on the axis.\n                addEvent(chart, 'beforeRender', onBeforeRender);\n                addEvent(chart, 'beforeRedraw', onBeforeRender);\n                // Add new collapsed nodes on addseries\n                addEvent(chart, 'addSeries', function (e) {\n                    if (e.options.data) {\n                        const treeGrid = getTreeGridFromData(e.options.data, userOptions.uniqueNames || false, 1);\n                        axis.treeGrid.collapsedNodes = (axis.treeGrid.collapsedNodes || []).concat(treeGrid.collapsedNodes);\n                    }\n                });\n                // Collapse all nodes in axis.treegrid.collapsednodes\n                // where collapsed equals true.\n                addEvent(axis, 'foundExtremes', function () {\n                    if (axis.treeGrid.collapsedNodes) {\n                        axis.treeGrid.collapsedNodes.forEach(function (node) {\n                            const breaks = axis.treeGrid.collapse(node);\n                            if (axis.brokenAxis) {\n                                axis.brokenAxis.setBreaks(breaks, false);\n                                // remove the node from the axis collapsedNodes\n                                if (axis.treeGrid.collapsedNodes) {\n                                    axis.treeGrid.collapsedNodes = axis.treeGrid\n                                        .collapsedNodes\n                                        .filter((n) => ((node.collapseStart !==\n                                        n.collapseStart) ||\n                                        node.collapseEnd !== n.collapseEnd));\n                                }\n                            }\n                        });\n                    }\n                });\n                // If staticScale is not defined on the yAxis\n                // and chart height is set, set axis.isDirty\n                // to ensure collapsing works (#12012)\n                addEvent(axis, 'afterBreaks', function () {\n                    if (axis.coll === 'yAxis' &&\n                        !axis.staticScale &&\n                        axis.chart.options.chart.height) {\n                        axis.isDirty = true;\n                    }\n                });\n                userOptions = merge({\n                    // Default options\n                    grid: {\n                        enabled: true\n                    },\n                    // TODO: add support for align in treegrid.\n                    labels: {\n                        align: 'left',\n                        /**\n                        * Set options on specific levels in a tree grid axis. Takes\n                        * precedence over labels options.\n                        *\n                        * @sample {gantt} gantt/treegrid-axis/labels-levels\n                        *         Levels on TreeGrid Labels\n                        *\n                        * @type      {Array<*>}\n                        * @product   gantt\n                        * @apioption yAxis.labels.levels\n                        *\n                        * @private\n                        */\n                        levels: [{\n                                /**\n                                * Specify the level which the options within this object\n                                * applies to.\n                                *\n                                * @type      {number}\n                                * @product   gantt\n                                * @apioption yAxis.labels.levels.level\n                                *\n                                * @private\n                                */\n                                level: void 0\n                            }, {\n                                level: 1,\n                                /**\n                                 * @type      {Highcharts.CSSObject}\n                                 * @product   gantt\n                                 * @apioption yAxis.labels.levels.style\n                                 *\n                                 * @private\n                                 */\n                                style: {\n                                    /** @ignore-option */\n                                    fontWeight: 'bold'\n                                }\n                            }],\n                        /**\n                         * The symbol for the collapse and expand icon in a\n                         * treegrid.\n                         *\n                         * @product      gantt\n                         * @optionparent yAxis.labels.symbol\n                         *\n                         * @private\n                         */\n                        symbol: {\n                            /**\n                             * The symbol type. Points to a definition function in\n                             * the `Highcharts.Renderer.symbols` collection.\n                             *\n                             * @type {Highcharts.SymbolKeyValue}\n                             *\n                             * @private\n                             */\n                            type: 'triangle',\n                            x: -5,\n                            y: -5,\n                            height: 10,\n                            width: 10\n                        }\n                    },\n                    uniqueNames: false\n                }, userOptions, {\n                    // Forced options\n                    reversed: true\n                });\n            }\n            // Now apply the original function with the original arguments, which are\n            // sliced off this function's arguments\n            proceed.apply(axis, [chart, userOptions, coll]);\n            if (isTreeGrid) {\n                axis.hasNames = true;\n                axis.options.showLastLabel = true;\n            }\n        }\n        /**\n         * Set the tick positions, tickInterval, axis min and max.\n         *\n         * @private\n         * @function Highcharts.GridAxis#setTickInterval\n         *\n         * @param {Function} proceed\n         * The original setTickInterval function.\n         */\n        function wrapSetTickInterval(proceed) {\n            const axis = this, options = axis.options, linkedParent = typeof options.linkedTo === 'number' ?\n                this.chart[axis.coll]?.[options.linkedTo] :\n                void 0, isTreeGrid = options.type === 'treegrid';\n            if (isTreeGrid) {\n                axis.min = pick(axis.userMin, options.min, axis.dataMin);\n                axis.max = pick(axis.userMax, options.max, axis.dataMax);\n                fireEvent(axis, 'foundExtremes');\n                // `setAxisTranslation` modifies the min and max according to axis\n                // breaks.\n                axis.setAxisTranslation();\n                axis.tickInterval = 1;\n                axis.tickmarkOffset = 0.5;\n                axis.tickPositions = axis.treeGrid.mapOfPosToGridNode ?\n                    axis.treeGrid.getTickPositions() :\n                    [];\n                if (linkedParent) {\n                    const linkedParentExtremes = linkedParent.getExtremes();\n                    axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);\n                    axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);\n                    axis.tickPositions = linkedParent.tickPositions;\n                }\n                axis.linkedParent = linkedParent;\n            }\n            else {\n                proceed.apply(axis, Array.prototype.slice.call(arguments, 1));\n            }\n        }\n        /**\n         * Wrap axis redraw to remove TreeGrid events from ticks\n         *\n         * @private\n         * @function Highcharts.GridAxis#redraw\n         *\n         * @param {Function} proceed\n         * The original setTickInterval function.\n         */\n        function wrapRedraw(proceed) {\n            const axis = this, options = axis.options, isTreeGrid = options.type === 'treegrid';\n            if (isTreeGrid && axis.visible) {\n                axis.tickPositions.forEach(function (pos) {\n                    const tick = axis.ticks[pos];\n                    if (tick.label && tick.label.attachedTreeGridEvents) {\n                        removeEvent(tick.label.element);\n                        tick.label.attachedTreeGridEvents = false;\n                    }\n                });\n            }\n            proceed.apply(axis, Array.prototype.slice.call(arguments, 1));\n        }\n        /* *\n         *\n         *  Classes\n         *\n         * */\n        /**\n         * @private\n         * @class\n         */\n        class TreeGridAxisAdditions {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            static compose(AxisClass, ChartClass, SeriesClass, TickClass) {\n                if (!AxisClass.keepProps.includes('treeGrid')) {\n                    const axisProps = AxisClass.prototype;\n                    AxisClass.keepProps.push('treeGrid');\n                    wrap(axisProps, 'generateTick', wrapGenerateTick);\n                    wrap(axisProps, 'init', wrapInit);\n                    wrap(axisProps, 'setTickInterval', wrapSetTickInterval);\n                    wrap(axisProps, 'redraw', wrapRedraw);\n                    // Make utility functions available for testing.\n                    axisProps.utils = {\n                        getNode: Tree.getNode\n                    };\n                    if (!TickConstructor) {\n                        TickConstructor = TickClass;\n                    }\n                }\n                GridAxis.compose(AxisClass, ChartClass, TickClass);\n                BrokenAxis.compose(AxisClass, SeriesClass);\n                TreeGridTick.compose(TickClass);\n                return AxisClass;\n            }\n            /* *\n             *\n             *  Constructors\n             *\n             * */\n            /**\n             * @private\n             */\n            constructor(axis) {\n                this.axis = axis;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Set the collapse status.\n             *\n             * @private\n             *\n             * @param {Highcharts.Axis} axis\n             * The axis to check against.\n             *\n             * @param {Highcharts.GridNode} node\n             * The node to collapse.\n             */\n            setCollapsedStatus(node) {\n                const axis = this.axis, chart = axis.chart;\n                axis.series.forEach(function (series) {\n                    const data = series.options.data;\n                    if (node.id && data) {\n                        const point = chart.get(node.id), dataPoint = data[series.data.indexOf(point)];\n                        if (point && dataPoint) {\n                            point.collapsed = node.collapsed;\n                            dataPoint.collapsed = node.collapsed;\n                        }\n                    }\n                });\n            }\n            /**\n             * Calculates the new axis breaks to collapse a node.\n             *\n             * @private\n             *\n             * @param {Highcharts.Axis} axis\n             * The axis to check against.\n             *\n             * @param {Highcharts.GridNode} node\n             * The node to collapse.\n             *\n             * @param {number} pos\n             * The tick position to collapse.\n             *\n             * @return {Array<object>}\n             * Returns an array of the new breaks for the axis.\n             */\n            collapse(node) {\n                const axis = this.axis, breaks = (axis.options.breaks || []), obj = getBreakFromNode(node, axis.max);\n                breaks.push(obj);\n                // Change the collapsed flag #13838\n                node.collapsed = true;\n                axis.treeGrid.setCollapsedStatus(node);\n                return breaks;\n            }\n            /**\n             * Calculates the new axis breaks to expand a node.\n             *\n             * @private\n             *\n             * @param {Highcharts.Axis} axis\n             * The axis to check against.\n             *\n             * @param {Highcharts.GridNode} node\n             * The node to expand.\n             *\n             * @param {number} pos\n             * The tick position to expand.\n             *\n             * @return {Array<object>}\n             * Returns an array of the new breaks for the axis.\n             */\n            expand(node) {\n                const axis = this.axis, breaks = (axis.options.breaks || []), obj = getBreakFromNode(node, axis.max);\n                // Change the collapsed flag #13838\n                node.collapsed = false;\n                axis.treeGrid.setCollapsedStatus(node);\n                // Remove the break from the axis breaks array.\n                return breaks.reduce(function (arr, b) {\n                    if (b.to !== obj.to || b.from !== obj.from) {\n                        arr.push(b);\n                    }\n                    return arr;\n                }, []);\n            }\n            /**\n             * Creates a list of positions for the ticks on the axis. Filters out\n             * positions that are outside min and max, or is inside an axis break.\n             *\n             * @private\n             *\n             * @return {Array<number>}\n             * List of positions.\n             */\n            getTickPositions() {\n                const axis = this.axis, roundedMin = Math.floor(axis.min / axis.tickInterval) * axis.tickInterval, roundedMax = Math.ceil(axis.max / axis.tickInterval) * axis.tickInterval;\n                return Object.keys(axis.treeGrid.mapOfPosToGridNode || {}).reduce(function (arr, key) {\n                    const pos = +key;\n                    if (pos >= roundedMin &&\n                        pos <= roundedMax &&\n                        !(axis.brokenAxis && axis.brokenAxis.isInAnyBreak(pos))) {\n                        arr.push(pos);\n                    }\n                    return arr;\n                }, []);\n            }\n            /**\n             * Check if a node is collapsed.\n             *\n             * @private\n             *\n             * @param {Highcharts.Axis} axis\n             * The axis to check against.\n             *\n             * @param {Object} node\n             * The node to check if is collapsed.\n             *\n             * @param {number} pos\n             * The tick position to collapse.\n             *\n             * @return {boolean}\n             * Returns true if collapsed, false if expanded.\n             */\n            isCollapsed(node) {\n                const axis = this.axis, breaks = (axis.options.breaks || []), obj = getBreakFromNode(node, axis.max);\n                return breaks.some(function (b) {\n                    return b.from === obj.from && b.to === obj.to;\n                });\n            }\n            /**\n             * Calculates the new axis breaks after toggling the collapse/expand\n             * state of a node. If it is collapsed it will be expanded, and if it is\n             * expanded it will be collapsed.\n             *\n             * @private\n             *\n             * @param {Highcharts.Axis} axis\n             * The axis to check against.\n             *\n             * @param {Highcharts.GridNode} node\n             * The node to toggle.\n             *\n             * @return {Array<object>}\n             * Returns an array of the new breaks for the axis.\n             */\n            toggleCollapse(node) {\n                return (this.isCollapsed(node) ?\n                    this.expand(node) :\n                    this.collapse(node));\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return TreeGridAxisAdditions;\n    });\n    _registerModule(_modules, 'Series/Gantt/GanttSeries.js', [_modules['Series/Gantt/GanttPoint.js'], _modules['Series/Gantt/GanttSeriesDefaults.js'], _modules['Gantt/Pathfinder.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Extensions/StaticScale.js'], _modules['Core/Axis/TreeGrid/TreeGridAxis.js'], _modules['Core/Utilities.js']], function (GanttPoint, GanttSeriesDefaults, Pathfinder, SeriesRegistry, StaticScale, TreeGridAxis, U) {\n        /* *\n         *\n         *  (c) 2016-2024 Highsoft AS\n         *\n         *  Author: Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { series: Series, seriesTypes: { xrange: XRangeSeries } } = SeriesRegistry;\n        const { extend, isNumber, merge } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.gantt\n         *\n         * @augments Highcharts.Series\n         */\n        class GanttSeries extends XRangeSeries {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            static compose(AxisClass, ChartClass, SeriesClass, TickClass) {\n                XRangeSeries.compose(AxisClass);\n                if (!ChartClass) {\n                    return;\n                }\n                StaticScale.compose(AxisClass, ChartClass);\n                if (!SeriesClass) {\n                    return;\n                }\n                Pathfinder.compose(ChartClass, SeriesClass.prototype.pointClass);\n                if (!TickClass) {\n                    return;\n                }\n                TreeGridAxis.compose(AxisClass, ChartClass, SeriesClass, TickClass);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Draws a single point in the series.\n             *\n             * This override draws the point as a diamond if point.options.milestone\n             * is true, and uses the original drawPoint() if it is false or not set.\n             *\n             * @requires highcharts-gantt\n             *\n             * @private\n             * @function Highcharts.seriesTypes.gantt#drawPoint\n             *\n             * @param {Highcharts.Point} point\n             *        An instance of Point in the series\n             *\n             * @param {\"animate\"|\"attr\"} verb\n             *        'animate' (animates changes) or 'attr' (sets options)\n             */\n            drawPoint(point, verb) {\n                const series = this, seriesOpts = series.options, renderer = series.chart.renderer, shapeArgs = point.shapeArgs, plotY = point.plotY, state = point.selected && 'select', cutOff = seriesOpts.stacking && !seriesOpts.borderRadius;\n                let graphic = point.graphic, diamondShape;\n                if (point.options.milestone) {\n                    if (isNumber(plotY) &&\n                        point.y !== null &&\n                        point.visible !== false) {\n                        diamondShape = renderer.symbols.diamond(shapeArgs.x || 0, shapeArgs.y || 0, shapeArgs.width || 0, shapeArgs.height || 0);\n                        if (graphic) {\n                            graphic[verb]({\n                                d: diamondShape\n                            });\n                        }\n                        else {\n                            point.graphic = graphic = renderer.path(diamondShape)\n                                .addClass(point.getClassName(), true)\n                                .add(point.group || series.group);\n                        }\n                        // Presentational\n                        if (!series.chart.styledMode) {\n                            point.graphic\n                                .attr(series.pointAttribs(point, state))\n                                .shadow(seriesOpts.shadow, null, cutOff);\n                        }\n                    }\n                    else if (graphic) {\n                        point.graphic = graphic.destroy(); // #1269\n                    }\n                }\n                else {\n                    super.drawPoint(point, verb);\n                }\n            }\n            /**\n             * Handle milestones, as they have no x2.\n             * @private\n             */\n            translatePoint(point) {\n                let shapeArgs, size;\n                super.translatePoint(point);\n                if (point.options.milestone) {\n                    shapeArgs = point.shapeArgs;\n                    size = shapeArgs.height || 0;\n                    point.shapeArgs = {\n                        x: (shapeArgs.x || 0) - (size / 2),\n                        y: shapeArgs.y,\n                        width: size,\n                        height: size\n                    };\n                }\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        GanttSeries.defaultOptions = merge(XRangeSeries.defaultOptions, GanttSeriesDefaults);\n        extend(GanttSeries.prototype, {\n            pointArrayMap: ['start', 'end', 'y'],\n            pointClass: GanttPoint,\n            setData: Series.prototype.setData\n        });\n        SeriesRegistry.registerSeriesType('gantt', GanttSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return GanttSeries;\n    });\n    _registerModule(_modules, 'masters/modules/gantt.src.js', [_modules['Core/Globals.js'], _modules['Extensions/ArrowSymbols.js'], _modules['Gantt/Connection.js'], _modules['Extensions/CurrentDateIndication.js'], _modules['Core/Chart/GanttChart.js'], _modules['Stock/Navigator/Navigator.js'], _modules['Stock/RangeSelector/RangeSelector.js'], _modules['Stock/Scrollbar/Scrollbar.js'], _modules['Series/Gantt/GanttSeries.js']], function (Highcharts, ArrowSymbols, Connection, CurrentDateIndication, GanttChart, Navigator, RangeSelector, Scrollbar, GanttSeries) {\n\n        // Series\n        const G = Highcharts;\n        // Classes\n        G.Connection = G.Connection || Connection;\n        G.GanttChart = G.GanttChart || GanttChart;\n        G.Navigator = G.Navigator || Navigator;\n        G.RangeSelector = G.RangeSelector || RangeSelector;\n        G.Scrollbar = G.Scrollbar || Scrollbar;\n        // Functions\n        G.ganttChart = G.GanttChart.ganttChart;\n        // Compositions\n        ArrowSymbols.compose(G.SVGRenderer);\n        CurrentDateIndication.compose(G.Axis, G.PlotLineOrBand);\n        GanttSeries.compose(G.Axis, G.Chart, G.Series, G.Tick);\n        G.Navigator.compose(G.Chart, G.Axis, G.Series);\n        G.RangeSelector.compose(G.Axis, G.Chart);\n        G.Scrollbar.compose(G.Axis);\n\n        return Highcharts;\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","arrow","x","y","w","h","arrowHalf","triangleLeft","triangleLeftHalf","compose","SVGRendererClass","symbols","prototype","H","U","defined","error","merge","objectEach","deg2rad","max","Math","min","constructor","from","to","options","init","fromPoint","toPoint","chart","series","pathfinder","renderPath","attribs","styledMode","anim","pathGraphic","connection","graphics","group","renderer","g","addClass","attr","zIndex","add","seriesGroup","translate","plotLeft","plotTop","opacity","d","animate","addMarker","type","markerVector","radians","rotation","box","width","height","pathVector","segment","point","anchor","getPathfinderAnchorPoint","enabled","length","getRadiansToVector","getMarkerVector","radius","rotationOriginX","rotationOriginY","symbol","colorIndex","fill","color","stroke","lineColor","lineWidth","animation","getPath","algorithm","algorithms","chartObstacles","obstacles","requiresObstacles","getChartObstacles","connectors","algorithmMargin","chartObstacleMetrics","getObstacleMetrics","startMarker","endMarker","lineObstacles","obstacleMetrics","hardBounds","xMin","xMax","plotWidth","yMin","yMax","plotHeight","obstacleOptions","margin","startDirectionX","getAlgorithmStartDirection","render","dashStyle","dashstyle","marker","ceil","pathResult","concat","destroy","val","composed","addEvent","pushUnique","wrap","defaultOptions","label","format","formatter","value","axis","time","dateFormat","style","fontSize","onAxisAfterSetOptions","cdiOptions","currentDateIndicator","plotLineOptions","Date","now","className","plotLines","push","onPlotLineOrBandRender","text","getLabelText","wrapPlotLineOrBandGetLabelText","defaultMethod","defaultLabelOptions","indexOf","call","AxisClass","PlotLineOrBandClass","Chart","D","GanttChart","isArray","splat","userOptions","callback","defaultLinkedTo","xAxisOptions","xAxis","yAxisOptions","yAxis","title","legend","navigator","isGantt","map","i","grid","borderColor","opposite","linkedTo","staticScale","reversed","categories","ganttChart","a","b","c","NavigatorConstructor","isTouchDevice","pick","composedMembers","onChartAfterAddSeries","setBaseSeries","onChartAfterSetChartSize","legendOptions","scrollbarHeight","scrollButtonSize","inverted","left","chartWidth","spacing","top","navigatorOptions","chartHeight","scrollbar","rangeSelector","extraBottomMargin","getHeight","verticalAlign","layout","floating","legendHeight","titleOffset","setAxisSize","onChartAfterUpdate","event","scroller","redraw","onChartBeforeRender","onChartBeforeShowResetZoom","chartOptions","zooming","pinchType","onChartCallback","extremes","getExtremes","onChartUpdate","e","scrollbarOptions","ChartClass","NavigatorClass","chartProto","callbacks","correctFloat","isNumber","onAxisInit","navigatorAxis","NavigatorAxisAdditions","onAxisSetExtremes","zoomed","zoomType","isXAxis","trigger","range","previousZoom","preventDefault","keepProps","includes","toFixedRange","pxMin","pxMax","fixedMin","fixedMax","overscroll","ordinal","convertOverscroll","newMin","horiz","newMax","fixedRange","halfPointRange","pointRange","dataMin","dataMax","maxWithOverscroll","Color","SeriesRegistry","parse","seriesTypes","maskInside","handles","backgroundColor","maskFill","setOpacity","get","outlineColor","outlineWidth","areaspline","fillOpacity","compare","sonification","dataGrouping","approximation","groupPixelWidth","firstAnchor","lastAnchor","units","dataLabels","id","threshold","tickLength","gridLineColor","gridLineWidth","tickPixelInterval","labels","align","textOutline","crosshair","startOnTick","endOnTick","minPadding","maxPadding","tickWidth","_x","_y","halfWidth","markerPosition","round","setFixedRange","NavigatorDefaults","NavigatorSymbols","RendererRegistry","StockUtilities","setOptions","getRendererType","extend","onSeriesAfterUpdate","isInternal","SeriesClass","ScrollbarAxis","Scrollbar","axisMin","axisMax","scrollMin","Infinity","scrollMax","onAxisAfterGetOffset","index","scrollbarsOffsets","axisOffset","size","onAxisAfterInit","vertical","unitedMin","unitedMax","shouldUpdateExtremes","DOMType","setExtremes","setRange","onAxisAfterRender","offsetsIndex","offset","axisTitleMargin","axisMargin","position","xPosition","isNaN","ScrollbarClass","barBorderRadius","buttonBorderRadius","buttonsEnabled","liveRedraw","minWidth","step","barBackgroundColor","barBorderWidth","barBorderColor","buttonArrowColor","buttonBackgroundColor","buttonBorderColor","buttonBorderWidth","rifleColor","trackBackgroundColor","trackBorderColor","trackBorderRadius","trackBorderWidth","ScrollbarDefaults","destroyObjectProperties","fireEvent","removeEvent","swapXY","forEach","seg","temp","len","_events","chartX","chartY","scrollbarButtons","scrollbarLeft","scrollbarStrokeWidth","scrollbarTop","addEvents","buttonsOrder","buttons","bar","scrollbarGroup","element","track","mouseDownHandler","bind","mouseMoveHandler","mouseUpHandler","buttonToMinClick","buttonToMaxClick","trackClick","ownerDocument","updatePosition","DOMEvent","cursorToScrollbarPosition","normalizedEvent","minWidthDifference","calculatedWidth","xOffset","barWidth","yOffset","removeEvents","prop","drawScrollbarButton","rect","crisp","r","strokeWidth","pointer","normalize","mousePosition","initPositions","grabbedCenter","change","direction","touches","chartPosition","hasDragged","method","rendered","show","translateX","translateY","hide","scrollbarRifles","fromPX","newSize","fullWidth","toPX","newPos","floor","newRiflesPos","showFull","eventType","svg","boosted","update","Axis","ChartNavigatorComposition","NavigatorComposition","clamp","erase","find","numExt","extreme","numbers","filter","Navigator","drawHandle","verb","parseInt","drawOutline","zoomedMin","zoomedMax","outline","halfOutline","outlineCorrection","navigatorSize","navigatorTop","lineTop","lineBtm","verticalMin","drawMasks","navigatorHeight","shades","shade","renderElements","mouseCursor","cursor","navigatorGroup","visibility","hasMask","css","handlesOptions","baseSeries","navigatorSeries","scrollbarXAxis","fake","navigatorEnabled","minRange","maxRange","navigatorWidth","toPixels","abs","toValue","currentRange","grabbedLeft","grabbedRight","fixedWidth","addMouseEvents","container","eventsToUnbind","onMouseMove","onMouseUp","getPartsEvents","renderTo","modifyNavigatorAxisExtremes","eventName","events","name","navigatorItem","shadesMousedown","navigatorPosition","ext","dragOffset","reversedExtremes","getUnionExtremes","eventArguments","handlesMousedown","baseXAxis","reverse","otherHandlePos","fixedExtreme","pageX","setTimeout","unionExtremes","triggerOp","Object","keys","unbind","removeBaseSeriesEvents","adaptToUpdatedData","updatedDataHandler","modifyBaseAxisExtremes","scrollbarEnabled","Boolean","xAxisIndex","yAxisIndex","baseXaxis","isDirtyBox","breaks","keepOrdinalPadding","zoomEnabled","offsets","alignTicks","data","updateNavigatorSeries","unbindRedraw","scrollTrackWidth","valueRange","addBaseSeriesEvents","addChartEvents","returnFalseOnNoBaseSeries","ret","baseAxis","navAxis","navAxisOptions","baseAxisOptions","baseSeriesOptions","s","showInNavigator","navSeriesMixin","enableMouseTracking","padXAxis","showInLegend","stacking","states","inactive","navSeries","base","baseOptions","mergedNavSeriesOptions","chartNavigatorSeriesOptions","baseNavigatorOptions","linkedNavSeries","userNavOptions","visible","plotOptions","navigatorSeriesData","hasNavigatorData","slice","initSeries","setSortedData","userSeriesOptions","colors","setVisible","remove","getBaseSeriesMin","currentSeriesMin","reduce","xData","baseExtremes","baseMin","baseMax","baseDataMin","baseDataMax","stickToMin","stickToMax","hasSetExtremes","eventArgs","Number","MAX_VALUE","userMin","userMax","shouldStickToMax","shouldStickToMin","pointStart","setData","xDataMin","marginName","axes","coll","lang","rangeSelectorZoom","rangeSelectorFrom","rangeSelectorTo","allButtonsEnabled","buttonSpacing","dropdown","buttonTheme","padding","inputBoxBorderColor","inputBoxHeight","inputBoxWidth","inputDateFormat","inputDateParser","inputEditDateFormat","inputEnabled","inputPosition","inputSpacing","selected","buttonPosition","inputStyle","labelStyle","RangeSelectorDefaults","RangeSelectorConstructor","chartDestroyEvents","axisMinFromRange","rangeOptions","getTrueRange","count","timeName","date","basePeriod","set","getTime","MIN_VALUE","_offsetMin","onChartAfterGetContainer","deferredYTDClick","clickButton","updateNames","setScale","getAxisMargins","extraTopMargin","alignTo","display","spacingBox","placed","onChartDestroy","iEnd","splice","onChartGetMargins","rangeSelectorHeight","marginBottom","onChartRender","optionsRangeSelector","extraBottomMarginWas","extraTopMarginWas","RangeSelectorClass","minFromRange","RangeSelectorComposition","SVGElement","createElement","discardElement","pad","pInt","RangeSelector","buttonOptions","defaultButtons","initialButtonGroupWidth","baseXAxisOptions","_range","rangeMin","minSetting","rangeSetting","ctx","ytdExtremes","addOffsetMin","setSelected","forcedDataGrouping","setDataGrouping","frozenStates","preserveDataGrouping","getYTDExtremes","useUTC","_offsetMax","selectedIndex","rangeSelectorButton","selectedOption","blurInputs","minInput","maxInput","blur","computeButtonRange","updateButtonStates","actualRange","hasNoData","hasVisibleSeries","day","ytdMin","ytdMax","selectedExists","isSelectedTooGreat","button","offsetRange","isSelected","isTooGreatRange","isTooSmallRange","state","isYTDButNotSelected","isAllButAlreadyShowingAll","isSameRange","isOrdinal","positions","month","year","disable","select","setState","disabled","fixedTimes","millisecond","second","minute","hour","week","offsetMin","offsetMax","getInputValue","input","defaultInputDateParser","setInputValue","inputTime","dateBox","minDateBox","maxDateBox","hcTimeAttr","getAttribute","updatedTime","previousTime","setAttribute","inputTypeFormats","setInputExtremes","showInput","inputGroup","isTextInput","border","offsetWidth","offsetHeight","hideInput","inputDate","split","join","str","isSafari","lastIndexOf","getTimezoneOffset","parts","UTC","drawInput","div","chartStyle","isMin","updateExtremes","chartAxis","on","focus","preferredInputType","some","char","boxShadow","textAlign","fontFamily","onfocus","onblur","doc","activeElement","keyDown","onchange","onkeypress","keyCode","onkeydown","onkeyup","getPosition","buttonTop","inputTop","startOfYear","ts","inputsZIndex","renderButtons","parentNode","insertBefore","minElems","minLabel","maxElems","maxLabel","getBBox","alignElements","buttonGroup","isMS","currentButtonIndex","zoomText","paddingLeft","paddingRight","textContent","textStr","callDefaultEvent","buttonEvents","click","isActive","hover","navButtonOptions","exporting","navigation","getXOffsetForExportButton","titleCollision","positionButtons","xOffsetForExportButton","alignButtonGroup","hasLoaded","handleCollision","alignTranslateY","alignAttr","groupHeight","marginTop","buttonLeft","maxButtonWidth","buttonWidth","bBox","groupsOverlap","buttonGroupWidth","inputGroupX","alignOptions","inputGroupWidth","buttonGroupX","moveInputsDown","collapseButtons","expandButtons","isCollapsed","userButtonTheme","getAttribs","hasActiveButton","showDropdown","hideDropdown","hasVisibleDropdown","rangeSelectorGroup","yPosition","buttonPositionY","inputPositionY","subtitle","rSelector","key","HTMLElement","applyRadius","prevSeg","nextSeg","x1","y1","x2","y2","directionX","directionY","getLinkPath","pathParams","parentVisible","straight","curved","PathUtilities","findLastObstacleBefore","startIx","right","cmp","findObstacleFromPoint","obstacle","pathFromSegments","segments","start","end","limitObstacleToBounds","bounds","simpleConnect","startObstacleIx","endObstacleIx","endSegment","dir","startObstacle","waypoint","useMax","endPoint","copyFromPoint","fromKey","toKey","getMeOut","prevWaypoint","waypoint2","fastAvoid","dirIsX","endSegments","metrics","softMinX","maxWidth","softMaxX","softMinY","maxHeight","softMaxY","extractedEndPoint","forceObstacleBreak","pivotPoint","directionIsX","firstPoint","lastPoint","highestPoint","lowestPoint","searchDirection","getDodgeDirection","softBounds","soft","hard","toPointMax","toPointMin","maxOutOfSoftBounds","minOutOfSoftBounds","maxOutOfHardBounds","minOutOfHardBounds","minDistance","maxDistance","minPivot","maxPivot","extractFromObstacle","goalPoint","clearPathTo","pivot","waypointUseMax","envelopingObstacle","secondEnvelopingObstacle","envelopWaypoint","obstacleMargin","inside","ConnectorsDefaults","ConnectionComposition","getPointBB","shapeArgs","bb","graphic","plotX","plotY","pointGetPathfinderAnchorPoint","markerOptions","pointGetRadiansToVector","v1","v2","atan2","pointGetMarkerVector","markerRadius","twoPI","PI","rectWidth","rectHeight","rAtan","rectHalfWidth","rectHalfHeight","rectHorizontalCenter","rectVerticalCenter","edgePoint","theta","tanTheta","leftOrRightRegion","xFactor","yFactor","tan","cos","sin","PathfinderClass","PointClass","pointProto","acc","Connection","PathfinderAlgorithms","PathfinderComposition","Point","Pathfinder","connections","deferRender","oldConnections","points","ganttPointOptions","dependency","connect","connects","isInside","j","k","found","lenOld","lenNew","oldCon","newCon","renderConnections","conns","pathfinderRemoveRenderEvent","calculatedMargin","sLen","pLen","sort","calculateObstacleMargin","onstacleDistance","distances","calculateObstacleDistance","bbMargin","yOverlap","xOverlap","xDistance","yDistance","xCenter","yCenter","ArrowSymbols","G","SVGRenderer","scrollablePlotArea","minHeight","chartAdjustHeight","redrawTrigger","initiatedScale","brokenAxis","unitLength","tickInterval","diff","scrollablePixelsY","setSize","clipRect","sharedClipKey","sharedClips","adjustHeight","StaticScale","isObject","colorByPoint","amount","partialFill","whiteSpace","tooltip","headerFormat","pointFormat","borderRadius","column","pointClass","ColumnPoint","XRangePoint","getColorByCategory","colorCount","resolveColor","arguments","drawPoint","getAnimationVerb","getLabelConfig","cfg","yCats","yCategory","category","isValid","ttBelow","tooltipDateKeys","XRangeSeriesDefaults","noop","ColumnSeries","relativeLength","onAxisAfterGetSeriesExtremes","modMax","x2Data","XRangeSeries","getColumnMetrics","swapAxes","cropData","yData","crop","findPointIndex","pointIndex","cropStart","touched","cropped","alignDataLabel","oldPlotX","dlBox","centerX","dataLabel","translatePoint","columnMetrics","minPointLength","oldColWidth","seriesXOffset","pointXOffset","posX","plotX2","crisper","borderWidth","widthDifference","pointHeight","dlLeft","dlRight","dlWidth","clipRectWidth","pointWidth","pointPlacement","tooltipPos","xIndex","yIndex","tooltipYOffset","partShapeArgs","clipRectArgs","seriesOpts","shapeType","pointState","stateOpts","pointStateVerb","pointAttr","pointAttribs","pfOptions","isNull","getClassName","partRect","partialClipRect","clip","shadow","brighten","drawPoints","pointCount","animationLimit","isPointInside","pointArrayMap","getExtremesFromAll","parallelArrays","requireSorting","autoIncrement","buildKDTree","registerSeriesType","xrange","GanttPoint","setGanttPointAliases","addIfExists","completed","applyOptions","ganttPoint","milestone","grouping","pointFormatter","formats","tooltipOptions","dateTimeLabelFormats","startOfWeek","ttOptions","xDateFormat","retVal","tooltipFormatter","getDateFormat","closestPointRange","StackItem","BrokenAxis","setBreaks","hasBreaks","onAxisAfterSetTickPositions","tickPositions","info","newPositions","isInAnyBreak","Additions","onSeriesAfterGeneratePoints","isDirty","connectNulls","isPointInBreak","onSeriesAfterRender","drawBreaks","seriesDrawBreaks","breakArray","breaksOutOfRange","brk","isOut","otherBreak","toUpperCase","seriesGappedPath","currentDataGrouping","groupingSize","gapSize","current","next","gapUnit","basePointRange","xRange","stack","stacks","stackKey","stackLabels","total","getGraphPath","seriesProto","gappedPath","isInBreak","repeat","test","inclusive","lin2Val","nval","val2Lin","findBreakAt","testKeep","inbrk","keep","showPoints","forceRedraw","val2lin","lin2val","axisBreak","setAxisTranslation","breakArrayT","pointRangePadding","inBrk","move","breakSize","transA","minPixelPadding","minPointOffset","GridAxisSide","dateFormats","timeUnits","getMaxLabelDimensions","ticks","dimensions","pos","tick","labelHeight","labelWidth","textPxLength","treeGrid","mapOfPosToGridNode","treeDepth","indentation","wrapGetOffset","proceed","columnsFirst","side","isColumn","columns","getOffset","onAfterGetTitlePosition","gridOptions","axisTitle","axisHeight","axisLeft","axisTop","axisWidth","tickSize","titleWidth","xOption","yOption","titleMargin","titleFontSize","fontMetrics","f","offAxis","bottom","titlePosition","onAfterInit","applyGridOptions","showLastLabel","labelRotation","minTickInterval","columnIndex","columnOptions","onAfterRender","firstTick","slotWidth","maxLabelDimensions","rightWall","isOuterAxis","axisLine","linePath","getLinePath","startPoint","distance","marginRight","upperBorderEndPoint","upperBorderPath","lowerBorderEndPoint","tickmarkOffset","lowerBorderPath","upperBorder","renderBorder","lowerBorder","axisLineExtra","showAxis","hasRendered","linkedParent","tickMark","lastTick","hiddenLabels","pop","hiddenMarks","mark","isLast","onAfterSetAxisTranslation","tickInfo","userLabels","unitName","onAfterSetOptions","gridAxisOptions","list","reserveSpace","textOverflow","tickPositioner","parentInfo","unitIdx","unit","counts","unitRange","getTimeTicks","onAfterSetOptions2","onAfterSetScale","onAfterTickSize","labelPadding","cellHeight","onDestroy","keepEvents","onInit","tickColor","GridAxisAdditions","onTickAfterGetLabelPosition","labelOpts","tickPos","nextTickPos","crispCorr","lblMetrics","useHTML","lines","onTickLabelFormat","pointCopy","isFirst","p","is","gantt","onTrimTicks","categoryAxis","firstPos","secondPos","lastPos","beforeLastPos","linkedMin","linkedMax","startLessThanMin","endMoreThanMin","startLessThanMax","endMoreThanMax","isLinked","wrapUnsquish","Array","parentAxis","thisIndex","lastIndex","otherAxis","extraBorderLine","axisGroup","E","timestamp","charAt","W","unitsToOmit","firstDay","thursday","valueOf","firstThursday","toString","TickClass","getNode","parent","level","mapOfIdToChildren","after","before","node","depth","descendants","children","child","childStart","NaN","childEnd","getTree","getListOfParents","ids","listOfParents","prev","curr","adoptedByRoot","orphan","parentExcluded","onTickInit","TreeGridTickAdditions","wrapGetLabelPosition","labelOptions","lbOptions","isTreeGrid","result","wrapRenderLabel","collapsed","addClassName","removeClassName","tickGrid","tickOptions","icon","labelIcon","labelElement","axisGrid","axisOptions","symbolOptions","hasDescendants","isTreeGridElement","shouldRender","prefixClassName","prefixLevelClass","removeClass","RegExp","renderLabelIcon","params","isNew","labelBox","xy","iconCenter","styles","parentGroup","object","attachedTreeGridEvents","textDecoration","onTickHoverExit","toggleCollapse","tickProto","collapse","expand","posMappedNodes","getColor","colorIndexByPoint","mapOptionsToLevel","parentColor","parentColorIndex","siblings","chartOptionsChart","variateColor","colorVariation","getLevelOptions","defaults","converted","levels","item","levelIsConstant","getNodeWidth","columnCount","nodeDistance","nodeWidth","plotSizeX","fraction","parseFloat","nDistance","setTreeValues","tree","idRoot","nodeRoot","mapIdToNode","optionsPoint","childrenTotal","levelDynamic","newOptions","isLeaf","updateRootId","rootId","rootNode","GridAxis","Tree","TreeGridTick","TU","TickConstructor","isString","getBreakFromNode","collapseEnd","collapseStart","getTreeGridFromData","uniqueNames","numberOfSeries","collapsedNodes","mapOfIdToNode","uniqueNamesEnabled","posIterator","gridNode","parentGridNode","nodes","updateYValuesAndTickPos","setValues","seriesIndex","onBeforeRender","target","isDirtyData","arr","optionsToObject","hasNames","axisData","wrapGenerateTick","levelOptions","parameters","addLabel","wrapInit","TreeGridAxisAdditions","n","fontWeight","wrapSetTickInterval","getTickPositions","linkedParentExtremes","wrapRedraw","axisProps","utils","setCollapsedStatus","dataPoint","roundedMin","roundedMax","GanttSeriesDefaults","TreeGridAxis","Series","GanttSeries","cutOff","diamondShape","diamond","CurrentDateIndication","PlotLineOrBand","Tick"],"mappings":"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"}